Directory Tree: ./
================================================================================

├── .env

////////////////////////////////////////////////////////////////////////////////
PORT = 3000
NODE_ENV = development
DATABASE_URL="postgresql://mealflow:mealflow@mealflow.ddns.net:5432/mealflow?schema=public"

SMTP_HOST=smtp-relay.brevo.com
SMTP_PORT=587
SMTP_USER=864f48001@smtp-brevo.com
SMTP_PASS=Hd7cLsjtSw1pRyA5
SMTP_PASS_NODE=xsmtpsib-08fbd981606216e803e1572cccd277c2eeb4962d1bfd6002ac2b2bdb8fa240cb-ZnAy5hROzmt6N9sS
BREVO_API_KEY =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

COST_FACTOR = 10

JWT_SECRET = 512ffef55e8fe91f270acd298bc208c52101bd5305a2014850489bdaa7807c213bdc9582a4f67fd0ea666fdb945e7f6627b30ef574a4d4678ef0d6ce79a670e7c46e81216508c6c47560879346f5d3de5ccd85afe66fd9b618165fb3e9f4d759fe1ef55d7f4749d52247f368bc89230fb267278e8c5940b74c1395294f6be0980458fa66e82f60911f67739ee6c9e82c2059bd9dd13c66f874e18688c08134c2f0c2d032ac6c75f4310926735733344568b0f94e8e22e153d51ccc8a4b8962813ff9e1d19ed069493b2103bb9d8138f51b0181f16918d862deca368b56696bc2568d1a13a1928af875deaa98b89e7f2aee6c8689aeec7106f309487d9a990727
JWT_ACCESS_TOKEN_LIFETIME = 6h
JWT_REFRESH_TOKEN_LIFETIME = 1y

CLOUDINARY_CLOUD_NAME=dtz7ml4c3
CLOUDINARY_API_KEY=331854897438254
CLOUDINARY_API_SECRET=nVN0gpJWYrCGp5SObg6p9bTfOcg


MONGO_URI = mongodb+srv://amr:287491@clustertaskmanager.4tqui.mongodb.net/someday_to_do_list?retryWrites=true&w=majority&appName=ClusterTaskManager

# Python Recommendation Service Settings
PYTHON_SERVICE_URL=http://127.0.0.1:9999
PYTHON_API_VERSION=v1
PYTHON_SERVICE_TIMEOUT=30000
DEFAULT_USER_ID=default_user
////////////////////////////////////////////////////////////////////////////////

├── README.md

////////////////////////////////////////////////////////////////////////////////
# To-Do List Application

## Project Overview
This is a simple to-do list application with:
- **Frontend**: Built using Kotlin for Android.
- **Backend**: Powered by a server-side framework (Express.js).

The application enables users to:
- View a shared task list.
- Add new tasks.
- Manage task completion status.

---

## Features

### Frontend (Android App)
- **Task List Display**: View tasks in a RecyclerView.
- **Add Task**: Add tasks via a dedicated screen.
- **Task Completion**: Mark tasks as completed with visual cues.
- **API Integration**: Communicates with the backend to manage tasks.
- **Error Handling**: Provides feedback via Toast messages.

### Backend
- **Task Management API**: Endpoints to fetch and add tasks.
- **Basic Authentication**: Hardcoded user authentication for simplicity.
- **Database Integration**: Stores tasks and user information.
- **Deployment**: Hosted on a free service (e.g., Render or Heroku).

---

## Project Setup

### Frontend
1. Clone the repository.
2. Open the project in **Android Studio**.
3. Install dependencies in `build.gradle` (e.g., Retrofit, Coroutines).
4. Run the app on an emulator or physical device.

### Backend
1. Clone the repository.
2. Install dependencies:
   ```bash
   npm install  # For Node.js

////////////////////////////////////////////////////////////////////////////////

├── app.js

////////////////////////////////////////////////////////////////////////////////
const express = require("express");
require("express-async-errors");
require("dotenv").config();
require("./jobs/cron"); // This will automatically start the cleanup job
const { PrismaClient } = require("@prisma/client");
const cors = require("cors");
const path = require("path");

const prisma = new PrismaClient();
const app = express();

const uploadRouter = require("./routes/upload.routes");
const authRouter = require("./routes/auth.routes");
const userRouter = require("./routes/user.routes");
const communityRouter = require("./routes/community.routes");
const mealRouter = require("./routes/meal.routes");
const systemRouter = require("./routes/system.routes"); // Add the system routes
const notFound = require("./middlewares/notFound");
const errorHandlerMiddleware = require("./middlewares/errorHandler");

app.use(cors());
app.use(express.json());
app.use("/api/v1/users", authRouter);
app.use("/api/v1/users", userRouter);
app.use("/api/v1/community", communityRouter);
app.use("/api/v1/upload", uploadRouter);
app.use("/api/v1/meal", mealRouter);
app.use("/api/v1/system", systemRouter); // Use the system routes

app.get("/", (req, res) => {
  res.send("Hello ma man");
});

app.use(notFound);
app.use(errorHandlerMiddleware);

const port = process.env.PORT || 3001;

const startServer = async () => {
  try {
    await prisma.$connect();
    const server = app.listen(port, () =>
      console.log(`Server is listening on ${port}...`)
    );

    // Graceful shutdown
    process.on("SIGINT", async () => {
      await prisma.$disconnect();
      console.log("Prisma disconnected. Server shutting down...");
      server.close(() => process.exit(0));
    });

    process.on("SIGTERM", async () => {
      await prisma.$disconnect();
      console.log("Prisma disconnected due to termination signal.");
      server.close(() => process.exit(0));
    });
  } catch (error) {
    console.error("Error starting server:", error);
    process.exit(1);
  }
};

// Only start the server if this file is executed directly (not when imported in tests)
if (require.main === module) {
  startServer();
}

// Export the Express app (without starting the server) for testing
module.exports = app;
////////////////////////////////////////////////////////////////////////////////

├── config
│   ├── cloudinary.js

////////////////////////////////////////////////////////////////////////////////
const cloudinary = require("cloudinary").v2;
require("dotenv").config();

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

module.exports = cloudinary;

////////////////////////////////////////////////////////////////////////////////

│   ├── prismaClient.js

////////////////////////////////////////////////////////////////////////////////
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

module.exports = prisma;

////////////////////////////////////////////////////////////////////////////////

│   └── pythonService.js

////////////////////////////////////////////////////////////////////////////////
const axios = require('axios');
const config = require('../config/pythonService');
const recipeTransformer = require('../transformers/recipeTransformer');
// config/pythonService.js
require('dotenv').config();



class RecipeService {
  constructor() {
    this.client = axios.create({
      baseURL: `${config.baseUrl}/api/${config.apiVersion}`,
      timeout: config.timeout
    });
  }

  async getRecommendedMeals(userId = config.defaultUserId, limit = 10) {
    try {
      const response = await this.client.get(`/recommend/user/${userId}`, {
        params: { limit, recommendation_type: 'hybrid' }
      });
      
      return this._transformItems(response.data.items);
    } catch (error) {
      console.error('Failed to fetch recommended meals:', error);
      throw error;
    }
  }

  async getTrendingMeals(limit = 10, timeWindow = 'week') {
    try {
      const response = await this.client.get('/trending', {
        params: { limit, time_window: timeWindow }
      });
      
      return this._transformItems(response.data.items);
    } catch (error) {
      console.error('Failed to fetch trending meals:', error);
      throw error;
    }
  }

  async getSimilarMeals(recipeId, limit = 5) {
    try {
      const response = await this.client.get(`/recommend/similar/${recipeId}`, {
        params: { limit }
      });
      
      return this._transformItems(response.data.items);
    } catch (error) {
      console.error(`Failed to fetch similar meals for recipe ${recipeId}:`, error);
      throw error;
    }
  }

  async getMealDetails(recipeId) {
    try {
      const response = await this.client.get(`/recipes/${recipeId}`);
      return recipeTransformer.transformToMeal(response.data);
    } catch (error) {
      console.error(`Failed to fetch meal details for recipe ${recipeId}:`, error);
      throw error;
    }
  }

  async recordInteraction(userId, mealId, interactionType, rating = null) {
    try {
      await this.client.post('/interactions', {
        user_id: userId,
        meal_id: mealId,
        interaction_type: interactionType,
        rating
      });
      return true;
    } catch (error) {
      console.error(`Failed to record interaction for user ${userId} on meal ${mealId}:`, error);
      throw error;
    }
  }

  // NEW ENDPOINTS

  async getQuickMeals(maxTime = 30, limit = 10, cuisine = null, dietaryRestriction = null) {
    try {
      const response = await this.client.get('/recommend/quick', {
        params: { 
          max_time: maxTime, 
          limit, 
          cuisine, 
          dietary_restriction: dietaryRestriction
        }
      });
      
      return this._transformItems(response.data.items);
    } catch (error) {
      console.error('Failed to fetch quick meals:', error);
      throw error;
    }
  }

  async getCuisineRecommendations(cuisineId, limit = 10) {
    try {
      const response = await this.client.get(`/recommend/cuisine/${cuisineId}`, {
        params: { limit }
      });
      
      return this._transformItems(response.data.items);
    } catch (error) {
      console.error(`Failed to fetch cuisine recommendations for ${cuisineId}:`, error);
      throw error;
    }
  }

  async getDietaryRecommendations(dietaryRestriction, limit = 10) {
    try {
      const response = await this.client.get(`/recommend/dietary/${dietaryRestriction}`, {
        params: { limit }
      });
      
      return this._transformItems(response.data.items);
    } catch (error) {
      console.error(`Failed to fetch dietary recommendations for ${dietaryRestriction}:`, error);
      throw error;
    }
  }

  async getFilteredRecipes(options = {}) {
    try {
      const { page = 1, limit = 20, region, subRegion, minCalories, maxCalories } = options;
      
      const response = await this.client.get('/recipes', {
        params: {
          page,
          limit,
          region,
          sub_region: subRegion,
          min_calories: minCalories,
          max_calories: maxCalories
        }
      });
      
      return response.data.map(recipe => recipeTransformer.transformToMeal(recipe));
    } catch (error) {
      console.error('Failed to fetch filtered recipes:', error);
      throw error;
    }
  }

  async getRecipesByCalories(min = 0, max = 1000, page = 1, limit = 20) {
    try {
      const response = await this.client.get('/recipes/filter/calories', {
        params: { min, max, page, limit }
      });
      
      return response.data.map(recipe => recipeTransformer.transformToMeal(recipe));
    } catch (error) {
      console.error('Failed to fetch recipes by calories:', error);
      throw error;
    }
  }

  _transformItems(items) {
    if (!items || !Array.isArray(items)) return [];
    return Promise.all(items.map(item => 
      this.getMealDetails(item.id)
    ));
  }
}

module.exports = new RecipeService();
module.exports = {
  baseUrl: process.env.PYTHON_SERVICE_URL || 'http://127.0.0.1:9999',
  apiVersion: process.env.PYTHON_API_VERSION || 'v1',
  timeout: parseInt(process.env.PYTHON_SERVICE_TIMEOUT || '30000'),
  defaultUserId: process.env.DEFAULT_USER_ID || 'default_user'
};
////////////////////////////////////////////////////////////////////////////////

├── controllers
│   ├── auth.controller.js

////////////////////////////////////////////////////////////////////////////////
const {
  registerUser,
  generateAuthToken,
  comparePassword,
} = require("../models/userModel");
const BadRequestError = require("../errors/BadRequestError");
const CustomAPIError = require("../errors");
const UnauthenticatedError = require("../errors/UnauthenticatedError");
const { StatusCodes } = require("http-status-codes");
const { generateOTP, hashOTP, verifyHashedOTP } = require("../utils/otpUtlis");
const passwordUtils = require("../utils/passwordUtils");
const {
  sendVerificationEmail,
  sendPasswordResetEmail,
} = require("../utils/emailUtlis");
const tokenUtils = require("../utils/tokenUtils");
const prisma = require("../config/prismaClient");

// @desc (POST) register a new user
// @route api/v1/auth/register
// @access Public
const registerUserController = async (req, res) => {
  const { username, email, password } = req.body;

  // // Check if email or username exist
  const existingUser = await prisma.user.findFirst({
    where: {
      OR: [
        { email: email.toLowerCase() },
        { username: username.toLowerCase() },
      ],
    },
  });
  if (existingUser) {
    if (existingUser.username === username.toLowerCase()) {
      throw new CustomAPIError.ConflictError("Username already registered");
    }
    if (existingUser.email === email.toLowerCase()) {
      throw new CustomAPIError.ConflictError("Email already registered");
    }
  }

  // hash the password
  const hashedPassword = await passwordUtils.hash(password);

  // generate and hash OTP
  const otp = generateOTP();
  const hashedOTP = await hashOTP(otp);

  // Set OTP expiration time (15 minutes)
  const expirationTime = new Date();
  expirationTime.setMinutes(expirationTime.getMinutes() + 15);

  // store the user data in the database with isVerified: false
  const user = await prisma.$transaction(async (prisma) => {
    const newUser = await prisma.user.create({
      data: {
        username: username.toLowerCase(),
        email: email.toLowerCase(),
        password: hashedPassword,
        isVerified: false,
      },
    });

    await prisma.verificationCode.create({
      data: {
        code: hashedOTP,
        expiresAt: expirationTime,
        userId: newUser.id,
      },
    });

    return newUser;
  });

  // send the verification code to the user email
  await sendVerificationEmail(email, otp);

  // send response
  res.status(StatusCodes.CREATED).json({
    success: true,
    message:
      "User account created successfully. Please check your email for the verification code.",
  });
};

// @desc (POST) verify the otp code and activate the account
// @route api/v1/auth/verify-email
// @access Public
const verifyEmail = async (req, res) => {
  const { otp, email } = req.body;

  // Find the verification entry for the given email
  const otpExists = await prisma.verificationCode.findFirst({
    where: {
      isUsed: false,
      expiresAt: { gt: new Date() },
      user: { email: email.toLowerCase() },
    },
    include: { user: true },
  });

  if (!otpExists || !(await verifyHashedOTP(otp, otpExists.code))) {
    throw new UnauthenticatedError("Invalid or expired OTP");
  }

  const userId = otpExists.user.id;

  await prisma.$transaction(async (prisma) => {
    // Mark the user as verified
    await prisma.user.update({
      where: { id: userId },
      data: {
        isVerified: true,
        verifiedAt: new Date(),
      },
    });

    // Remove the used OTP entry
    await prisma.verificationCode.delete({
      where: { id: otpExists.id },
    });
  });

  // Generate short-lived access token
  const accessToken = tokenUtils.signAccessToken({ userId });

  // Generate long-lived refresh token
  const refreshToken = tokenUtils.signRefreshToken({ userId });
  const refreshTokenExpiry = new Date();
  refreshTokenExpiry.setFullYear(refreshTokenExpiry.getFullYear() + 1); // 1 year expiry

  // Store refresh token in database
  await prisma.refreshToken.create({
    data: {
      token: refreshToken,
      userId,
      expiresAt: refreshTokenExpiry,
    },
  });

  res.status(StatusCodes.ACCEPTED).json({
    success: true,
    message: "Email verified successfully",
    data: {
      accessToken,
      refreshToken,
      user: {
        id: userId,
        email: otpExists.user.email,
        isVerified: true,
      },
    },
  });
};

// @desc (POST) login a user
// @route api/v1/auth/login
// @access Public
const loginUser = async (req, res) => {
  const { email, password } = req.body;

  // Find user by email
  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) throw new UnauthenticatedError("Invalid email");

  // ensure the user is verified
  if (user.isVerified === false) {
    throw new UnauthenticatedError(
      "Account not verified. Please verify your email"
    );
  }

  // check password is correct
  const isPasswordCorrect = await comparePassword(password, user.password);
  if (!isPasswordCorrect) throw new UnauthenticatedError("Invalid password");

  // Generate short-lived access token
  const accessToken = tokenUtils.signAccessToken({ userId: user.id });

  // Generate long-lived refresh token
  const refreshToken = tokenUtils.signRefreshToken({ userId: user.id });
  const refreshTokenExpiry = new Date();
  refreshTokenExpiry.setFullYear(refreshTokenExpiry.getFullYear() + 1); // 1 year expiry

  await prisma.$transaction(async (prisma) => {
    // Remove existing refresh tokens before adding a new one
    await prisma.refreshToken.deleteMany({ where: { userId: user.id } });

    // Store refresh token in the database
    await prisma.refreshToken.create({
      data: {
        token: refreshToken,
        userId: user.id,
        expiresAt: refreshTokenExpiry,
      },
    });
  });

  res.status(StatusCodes.OK).json({
    success: true,
    message: "Login successful",
    data: {
      accessToken: accessToken,
      refreshToken: refreshToken,
      user: {
        id: user.id,
        email: user.email,
        isVerified: user.isVerified,
      },
    },
  });
};

// @desc (POST) logout a user
// @route api/v1/auth/logout
// @access Public
const logoutUser = async (req, res) => {
  const { refreshToken } = req.body;

  // Verify refresh token signature and expiration
  let decoded = tokenUtils.verify(refreshToken);

  if (!decoded) {
    throw new CustomAPIError.UnauthenticatedError(
      "Invalid or expired refresh token"
    );
  }

  // Find the refresh token first
  const tokenExists = await prisma.refreshToken.findFirst({
    where: { token: refreshToken },
  });

  if (!tokenExists) {
    throw new UnauthenticatedError("No tokens are found");
  }

  // deactivate token
  const token = await prisma.refreshToken.updateMany({
    where: { token: refreshToken },
    data: { isActive: false },
  });

  if (!token) {
    throw new UnauthenticatedError("No tokens are found");
  }

  return res.status(StatusCodes.OK).json({
    success: true,
    message: "User logged out successfully.",
  });
};

// @desc (POST) resend verification code otp
// @route api/v1/auth/resend-verification
// @access Public
const resendVerification = async (req, res) => {
  // getting the inputs
  const { email } = req.body;

  const user = await prisma.user.findUnique({
    where: {
      email: email,
    },
  });

  // Ensure the user exists in the database
  if (!user) {
    throw new BadRequestError("User not found");
  }

  // Ensure the user is not already verified
  if (user.isVerified === true) {
    throw new BadRequestError(
      "User is already verified, Please go to login page"
    );
  }

  // getting the last otp if exists
  const lastOtp = await prisma.verificationCode.findFirst({
    where: {
      userId: user.id,
    },
    orderBy: {
      createdAt: "desc",
    },
  });

  console.log(lastOtp);

  // Check rate limiting (only allow resending once per minute)
  if (lastOtp) {
    const now = new Date();
    const lastRequestTime = new Date(lastOtp.createdAt);
    lastRequestTime.setMinutes(lastRequestTime.getMinutes() + 1);

    console.log(now);
    console.log(lastRequestTime);

    if (now < lastRequestTime) {
      throw new CustomAPIError.TooManyRequestsError(
        "Please wait before requesting another OTP."
      );
    }
  }

  // generate and hash new OTP
  const otp = generateOTP();
  const hashedOTP = await hashOTP(otp);
  const expirationTime = new Date();
  expirationTime.setMinutes(expirationTime.getMinutes() + 15);

  // store hashed otp and delete old ones
  await prisma.$transaction(async (prisma) => {
    await prisma.verificationCode.deleteMany({ where: { userId: user.id } });
    await prisma.verificationCode.create({
      data: {
        code: hashedOTP,
        expiresAt: expirationTime,
        userId: user.id,
      },
    });
  });

  // send the OTP to the user email
  await sendVerificationEmail(email, otp);

  res.status(StatusCodes.OK).json({
    success: true,
    message: "A new verification code has been sent to your email.",
  });
};

// @desc (POST) send link to reset the password
// @route api/v1/auth/forgot-password
// @access Public
const forgotPassword = async (req, res) => {
  const BASE_WEB_URL = "https://mealflow.ddns.net/passwordrecovery"; // Web fallback
  const BASE_APP_URL = "mealflow://reset-password"; // Deep Link for the app

  const { email } = req.body;

  const user = await prisma.user.findUnique({
    where: { email },
  });

  if (!user) {
    throw new BadRequestError("User not found");
  }

  // Check if a reset token already exists
  await prisma.passwordResetToken.deleteMany({
    where: { userId: user.id },
  });

  // Generate a password reset token
  const resetToken = tokenUtils.signPasswordResetToken({ userId: user.id });
  const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour expiration

  // store the reset token in db
  const newToken = await prisma.passwordResetToken.create({
    data: {
      token: resetToken,
      userId: user.id,
      expiresAt: expiresAt,
    },
  });

  // Construct deep link & web fallback
  const queryParams = new URLSearchParams({
    // $deep_link: "true",
    token: resetToken,
  }).toString();
  const resetLink = `${BASE_WEB_URL}?${queryParams}`;
  const appResetLink = `${BASE_APP_URL}?${queryParams}`;

  // Send email with both links
  await sendPasswordResetEmail(email, resetLink, appResetLink);

  res.status(StatusCodes.OK).json({
    success: true,
    message: "Password reset email sent successfully",
    data: {
      token: resetToken,
    },
  });
};

// @desc (POST) update a new password instead of the fogotten old one
// @route api/v1/auth/reset-password
// @access Private
const resetPassword = async (req, res) => {
  const { token, password } = req.body;

  // Verify the token
  const decoded = tokenUtils.verify(token);
  if (!decoded) {
    throw new UnauthenticatedError("Invalid or expired token");
  }

  // Check if token exists in database and is valid
  const resetTokenEntry = await prisma.passwordResetToken.findFirst({
    where: {
      token: token,
      isUsed: false,
      expiresAt: { gt: new Date() },
      userId: decoded.userId,
    },
  });

  if (!resetTokenEntry) {
    throw new UnauthenticatedError("Invalid or expired token");
  }

  // Hash new password
  const hashedPassword = await passwordUtils.hash(password);

  // Update password and mark token as used
  await prisma.$transaction(async (prisma) => {
    await prisma.user.update({
      where: { id: decoded.userId },
      data: { password: hashedPassword },
    });

    await prisma.passwordResetToken.update({
      where: { id: resetTokenEntry.id },
      data: { isUsed: true },
    });
  });

  res.status(StatusCodes.OK).json({
    success: true,
    message: "Password reset successfully",
  });
};

// @desc (GET) generate new access token
// @route api/v1/auth/refresh-token
// @access Public
const refreshAccessToken = async (req, res) => {
  const { refreshToken } = req.body;

  // Verify refresh token signature and expiration
  let decoded = tokenUtils.verify(refreshToken);

  if (!decoded) {
    throw new CustomAPIError.UnauthenticatedError(
      "Invalid or expired refresh token"
    );
  }

  // Find matching refresh token in database
  const existingToken = await prisma.refreshToken.findFirst({
    where: {
      token: refreshToken,
      userId: decoded.userId,
      expiresAt: { gt: new Date() },
    },
  });

  if (!existingToken) {
    throw new UnauthenticatedError("Invalid or expired refresh token");
  }

  if (existingToken.isActive === false) {
    throw new CustomAPIError.UnauthorizedError("Deactivated refresh token");
  }

  // Generate a new access token
  const newAccessToken = tokenUtils.signAccessToken({ userId: decoded.userId });

  res.status(StatusCodes.OK).json({
    success: true,
    message: "New access token generated",
    data: { accessToken: newAccessToken },
  });
};

// @desc (POST) login a user from pop up menu of previous accounts
// @route api/v1/auth/quick-login
// @access Public
const quickLoginUser = async (req, res) => {
  const { refreshToken } = req.body;

  // Verify refresh token signature and expiration
  let decoded = tokenUtils.verify(refreshToken);

  if (!decoded) {
    throw new CustomAPIError.UnauthenticatedError(
      "Invalid or expired refresh token"
    );
  }

  const { existingToken, user } = await prisma.$transaction(async (tx) => {
    // Find matching refresh token and include user details
    const token = await tx.refreshToken.findFirst({
      where: {
        token: refreshToken,
        userId: decoded.userId,
        expiresAt: { gt: new Date() },
        isActive: false,
      },
      include: {
        user: true, // Fetch the user data along with the token
      },
    });

    if (!token || !token.user) {
      throw new CustomAPIError.UnauthenticatedError(
        "Invalid or expired refresh token"
      );
    }

    // Update isActive to true
    await tx.refreshToken.update({
      where: { id: token.id },
      data: { isActive: true },
    });

    return { existingToken: token, user: token.user }; // Return both token and user
  });

  // Generate a new access token
  const newAccessToken = tokenUtils.signAccessToken({ userId: user.id });

  res.status(StatusCodes.OK).json({
    success: true,
    message: "Login successful",
    data: {
      accessToken: newAccessToken,
      refreshToken: refreshToken,
      user: {
        id: user.id,
        email: user.email,
        isVerified: user.isVerified,
      },
    },
  });
};

// @desc (POST) change the password of a user
// @route api/v1/auth/change-password
// @access Private
const changePassword = async (req, res) => {
  res.send("Change password");
};

module.exports = {
  registerUser: registerUserController, // Renamed to avoid conflict with imported function
  loginUser,
  logoutUser,
  changePassword,
  verifyEmail,
  resendVerification,
  forgotPassword,
  refreshAccessToken,
  resetPassword,
  quickLoginUser,
};

////////////////////////////////////////////////////////////////////////////////

│   ├── community.controller.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const communityService = require("../services/community.service");
const CustomAPIError = require("../errors");

/**
 * Creates a new community
 * @route POST /api/v1/community
 * @access Private
 */
const createCommunity = async (req, res) => {
  const { userId } = req.user;

  // Use the service to create the community
  const community = await communityService.createCommunity(req.body, userId);

  res.status(StatusCodes.CREATED).json({
    success: true,
    message: "Community created successfully",
    community,
  });
};

/**
 * Gets a single community by ID
 * @route GET /api/v1/community/:id
 * @access Private
 */
const getSingleCommunity = async (req, res) => {
  const { id } = req.params;

  // Use the service to get the community
  const community = await communityService.getCommunityById(id);

  res.status(StatusCodes.OK).json({
    success: true,
    community,
  });
};

/**
 * Gets all communities
 * @route GET /api/v1/community
 * @access Private
 */
const getAllCommunities = async (req, res) => {
  // Use the service to get all communities
  const communities = await communityService.getAllCommunities();

  res.status(StatusCodes.OK).json({
    success: true,
    count: communities.length,
    communities,
  });
};

/**
 * Joins a user (as a member) to a community
 * @route POST /api/v1/community/:id/members
 * @acess Private
 */
const joinCommunity = async (req, res) => {
  // Get the user id from the auth layer
  const { userId } = req.user;
  const { id } = req.params;

  console.log(`Community id: ${id}`);
  const community = await communityService.getCommunityById(id);

  console.log(community);
  const addedMember = await communityService.joinCommunity(id, userId);

  res.status(StatusCodes.CREATED).json({
    message: "Successfully joined the community.",
    community: addedMember,
  });
};

/**
 * Leaves a user (as a member) from a community
 * @route DELETE /api/v1/community/:id/leave
 * @acess Private
 */
const leaveCommunity = async (req, res) => {
  // Get the user id from the auth layer
  const { userId } = req.user;

  const { id } = req.params;

  console.log(`Community id: ${id}`);
  const community = await communityService.leaveCommunity(id);

  console.log(community);
  const addedMember = await communityService.joinCommunity(id, userId);

  res.status(StatusCodes.CREATED).json({
    message: "Successfully joined the community.",
    community: addedMember,
  });
};

/**
 * Gets all members of a community
 * @route GET /api/v1/communiy/:id/members
 * @access Private
 */
const getAllMembers = async (req, res) => {
  const { id } = req.params;

  const members = await communityService.getAllMembers(id);

  res.status(StatusCodes.OK).json({
    success: true,
    count: members.length,
    members: members,
  });
};

module.exports = {
  createCommunity,
  getSingleCommunity,
  getAllCommunities,
  joinCommunity,
  getAllMembers,
  leaveCommunity,
};

////////////////////////////////////////////////////////////////////////////////

│   ├── df.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const CustomAPIError = require("../errors");
const prisma = require("../config/prismaClient");

// Constants
const DEFAULT_CATEGORIES = [];
const SELECT_FIELDS = {
  id: true,
  name: true,
  description: true,
  privacy: true,
  recipeCreationPermission: true,
  createdAt: true,
  image: true,
  ownerId: true,
};

/**
 * Service class for handling community-related operations
 */
class CommunityService {
  /**
   * Validates if a community name is available
   * @param {string} name - The community name to check
   * @throws {ConflictError} If community name already exists
   */
  static async validateCommunityName(name) {
    const existingCommunity = await prisma.community.findUnique({
      where: { name },
      select: { id: true },
    });

    if (existingCommunity) {
      throw new CustomAPIError.ConflictError(
        "A community with this name already exists"
      );
    }
  }

  /**
   * Validates and retrieves category IDs from category names
   * @param {string[]} categoryNames - Array of category names
   * @returns {Promise<{categoryIds: string[], invalidCategories: string[]}>}
   */
  static async validateCategories(categoryNames) {
    if (!Array.isArray(categoryNames) || categoryNames.length === 0) {
      return { categoryIds: [], invalidCategories: [] };
    }

    const existingCategories = await prisma.category.findMany({
      where: { name: { in: categoryNames } },
      select: { id: true, name: true },
    });

    const categoryMap = new Map(
      existingCategories.map(({ name, id }) => [name, id])
    );

    const invalidCategories = categoryNames.filter(
      (name) => !categoryMap.has(name)
    );

    return {
      categoryIds: existingCategories.map(({ id }) => id),
      invalidCategories,
    };
  }

  /**
   * Creates a new community with optional categories
   * @param {Object} data - Community data
   * @param {string[]} categoryIds - Array of category IDs
   * @returns {Promise<Object>} Created community
   */
  static async createCommunity(data, categoryIds = []) {
    const createData = {
      ...data,
      ...(categoryIds.length > 0 && {
        categories: {
          connect: categoryIds.map((id) => ({ id })),
        },
      }),
    };

    return prisma.community.create({
      data: createData,
      select: SELECT_FIELDS,
    });
  }

  /**
   * Parses categories from request body
   * @param {string|string[]} categories - Categories from request
   * @returns {string[]} Parsed categories
   */
  static parseCategories(categories) {
    if (!categories) return DEFAULT_CATEGORIES;
    
    try {
      return typeof categories === "string"
        ? JSON.parse(categories)
        : categories;
    } catch (error) {
      throw new CustomAPIError.BadRequestError(
        "Invalid categories format. Expected JSON array of strings."
      );
    }
  }
}

/**
 * Creates a new community
 * @route POST /api/v1/community
 * @access Private
 */
const createCommunity = async (req, res) => {
  const { name, description, image, recipeCreationPermission, privacy } = req.body;
  const { userId } = req.user;

  try {
    // Validate community name
    await CommunityService.validateCommunityName(name);

    // Parse and validate categories
    const parsedCategories = CommunityService.parseCategories(req.body.categories);
    
    // Validate categories and get IDs
    const { categoryIds, invalidCategories } = 
      await CommunityService.validateCategories(parsedCategories);

    if (invalidCategories.length > 0) {
      throw new CustomAPIError.BadRequestError(
        "Some categories do not exist.",
        { invalidCategories }
      );
    }

    // Prepare community data
    const communityData = {
      name,
      description,
      image,
      privacy,
      recipeCreationPermission,
      ownerId: userId,
    };

    // Create community (with transaction if needed)
    const newCommunity = categoryIds.length > 0
      ? await prisma.$transaction(async () => {
          return CommunityService.createCommunity(communityData, categoryIds);
        })
      : await CommunityService.createCommunity(communityData);

    return res.status(StatusCodes.CREATED).json({
      success: true,
      message: "Community created successfully",
      data: newCommunity,
    });
  } catch (error) {
    // Let the global error handler handle known errors
    if (error instanceof CustomAPIError.CustomAPIError) {
      throw error;
    }

    // Log unexpected errors here (you can add proper logging)
    console.error("Unexpected error in createCommunity:", error);
    throw new CustomAPIError.InternalServerError(
      "An unexpected error occurred while creating the community"
    );
  }
};

module.exports = {
  createCommunity,
  // Export service for testing
  CommunityService,
};
////////////////////////////////////////////////////////////////////////////////

│   ├── meal.controller.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const recipeService = require("../services/recipeService");

// Get recommended meals for a user
const getRecommendedMeals = async (req, res) => {
  try {
    let userId = "default_user";
    if (req.user && req.user.userId) {
      userId = req.user.userId;
    }

    const limit = parseInt(req.query.limit) || 10;
    const meals = await recipeService.getRecommendedMeals(userId, limit);

    res.status(StatusCodes.OK).json({
      success: true,
      message: "Recommended meals retrieved successfully",
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error("Error fetching recommended meals:", error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve recommended meals",
      error: error.message
    });
  }
};

// Get a single meal by ID
const getMealById = async (req, res) => {
  try {
    const mealId = req.params.id;
    const meal = await recipeService.getMealDetails(mealId);

    // Record view interaction
    if (req.user && req.user.userId) {
      await recipeService.recordInteraction(req.user.userId, mealId, "view");
    }

    res.status(StatusCodes.OK).json({
      success: true,
      message: "Meal retrieved successfully",
      data: meal
    });
  } catch (error) {
    console.error(`Error fetching meal ${req.params.id}:`, error);
    res.status(StatusCodes.NOT_FOUND).json({
      success: false,
      message: "Meal not found",
      error: error.message
    });
  }
};

// Get trending meals
const getTrendingMeals = async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const timeWindow = req.query.time_window || "week";

    const meals = await recipeService.getTrendingMeals(limit, timeWindow);

    res.status(StatusCodes.OK).json({
      success: true,
      message: "Trending meals retrieved successfully",
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error("Error fetching trending meals:", error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve trending meals",
      error: error.message
    });
  }
};

// Record meal interaction (like, save, etc.)
const recordMealInteraction = async (req, res) => {
  try {
    const { meal_id, interaction_type, rating } = req.body;
    const userId = req.user.userId;

    await recipeService.recordInteraction(userId, meal_id, interaction_type, rating);

    res.status(StatusCodes.OK).json({
      success: true,
      message: `${interaction_type} recorded successfully`
    });
  } catch (error) {
    console.error("Error recording interaction:", error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to record interaction",
      error: error.message
    });
  }
};

// NEW CONTROLLER METHODS

// Get quick meals (recipes that can be prepared quickly)
const getQuickMeals = async (req, res) => {
  try {
    const maxTime = parseInt(req.query.max_time) || 30;
    const limit = parseInt(req.query.limit) || 10;
    const cuisine = req.query.cuisine || null;
    const dietaryRestriction = req.query.dietary_restriction || null;

    const meals = await recipeService.getQuickMeals(maxTime, limit, cuisine, dietaryRestriction);

    res.status(StatusCodes.OK).json({
      success: true,
      message: "Quick meals retrieved successfully",
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error("Error fetching quick meals:", error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve quick meals",
      error: error.message
    });
  }
};

// Get cuisine recommendations
const getCuisineRecommendations = async (req, res) => {
  try {
    const cuisineId = req.params.cuisine_id;
    const limit = parseInt(req.query.limit) || 10;

    const meals = await recipeService.getCuisineRecommendations(cuisineId, limit);

    res.status(StatusCodes.OK).json({
      success: true,
      message: `${cuisineId} cuisine recommendations retrieved successfully`,
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error(`Error fetching cuisine recommendations for ${req.params.cuisine_id}:`, error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve cuisine recommendations",
      error: error.message
    });
  }
};

// Get dietary recommendations
const getDietaryRecommendations = async (req, res) => {
  try {
    const dietaryRestriction = req.params.dietary_restriction;
    const limit = parseInt(req.query.limit) || 10;

    const meals = await recipeService.getDietaryRecommendations(dietaryRestriction, limit);

    res.status(StatusCodes.OK).json({
      success: true,
      message: `${dietaryRestriction} dietary recommendations retrieved successfully`,
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error(`Error fetching dietary recommendations for ${req.params.dietary_restriction}:`, error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve dietary recommendations",
      error: error.message
    });
  }
};

// Get similar meals
const getSimilarMeals = async (req, res) => {
  try {
    const mealId = req.params.id;
    const limit = parseInt(req.query.limit) || 5;

    const meals = await recipeService.getSimilarMeals(mealId, limit);

    res.status(StatusCodes.OK).json({
      success: true,
      message: "Similar meals retrieved successfully",
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error(`Error fetching similar meals for ${req.params.id}:`, error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve similar meals",
      error: error.message
    });
  }
};

// Get filtered recipes
const getFilteredRecipes = async (req, res) => {
  try {
    const options = {
      page: parseInt(req.query.page) || 1,
      limit: parseInt(req.query.limit) || 20,
      region: req.query.region,
      subRegion: req.query.sub_region,
      minCalories: req.query.min_calories ? parseInt(req.query.min_calories) : null,
      maxCalories: req.query.max_calories ? parseInt(req.query.max_calories) : null
    };

    const meals = await recipeService.getFilteredRecipes(options);

    res.status(StatusCodes.OK).json({
      success: true,
      message: "Filtered recipes retrieved successfully",
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error("Error fetching filtered recipes:", error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve filtered recipes",
      error: error.message
    });
  }
};

// Get recipes by calorie range
const getRecipesByCalories = async (req, res) => {
  try {
    const min = parseFloat(req.query.min) || 0;
    const max = parseFloat(req.query.max) || 1000;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;

    const meals = await recipeService.getRecipesByCalories(min, max, page, limit);

    res.status(StatusCodes.OK).json({
      success: true,
      message: "Recipes by calorie range retrieved successfully",
      count: meals.length,
      data: meals
    });
  } catch (error) {
    console.error("Error fetching recipes by calories:", error);
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to retrieve recipes by calorie range",
      error: error.message
    });
  }
};
/**
 * Advanced search for recipes with multiple criteria
 * @route GET /api/v1/meal/search/advanced
 * @access Public
 */
const advancedSearch = async (req, res) => {
  try {
    // Extract all search parameters from query and format them properly
    const criteria = {
      // Text search
      query: req.query.query || null,

      // Array parameters (convert comma-separated strings to arrays)
      cuisines: req.query.cuisines ? req.query.cuisines.split(',').map(c => c.trim()) : [],
      dietaryRestrictions: req.query.dietary ? req.query.dietary.split(',').map(d => d.trim()) : [],
      includeIngredients: req.query.include_ingredients ? req.query.include_ingredients.split(',').map(i => i.trim()) : [],
      excludeIngredients: req.query.exclude_ingredients ? req.query.exclude_ingredients.split(',').map(i => i.trim()) : [],

      // Numerical parameters (convert to numbers when present)
      minCalories: req.query.min_calories ? parseInt(req.query.min_calories) : null,
      maxCalories: req.query.max_calories ? parseInt(req.query.max_calories) : null,
      maxPrepTime: req.query.max_prep_time ? parseInt(req.query.max_prep_time) : null,
      maxCookTime: req.query.max_cook_time ? parseInt(req.query.max_cook_time) : null,
      maxTotalTime: req.query.max_total_time ? parseInt(req.query.max_total_time) : null,

      // Sorting and pagination
      sortBy: req.query.sort_by || 'relevance',
      sortOrder: req.query.sort_order || 'desc',
      page: parseInt(req.query.page || '1'),
      limit: parseInt(req.query.limit || '20')
    };

    console.log('Advanced search criteria:', criteria);

    // Perform the search
    const meals = await recipeService.advancedSearch(criteria);

    // Return the results
    res.status(StatusCodes.OK).json({
      success: true,
      message: "Advanced search completed successfully",
      count: meals.length,
      page: criteria.page,
      limit: criteria.limit,
      data: meals
    });
  } catch (error) {
    console.error("Error performing advanced search:", error);

    // Provide more detailed error information in the response
    res.status(StatusCodes.INTERNAL_SERVER_ERROR).json({
      success: false,
      message: "Failed to perform advanced search",
      error: error.message,
      details: error.response?.data?.detail || "No additional details available"
    });
  }
};
module.exports = {
  advancedSearch,
  getRecommendedMeals,
  getMealById,
  getTrendingMeals,
  recordMealInteraction,
  getQuickMeals,
  getCuisineRecommendations,
  getDietaryRecommendations,
  getSimilarMeals,
  getFilteredRecipes,
  getRecipesByCalories
};
////////////////////////////////////////////////////////////////////////////////

│   └── user.controller.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const prisma = require("../config/prismaClient");

// @desc Get the authenticated user
// @route GET /api/v1/users/me
// @access Private
const getSingleUser = async (req, res) => {
  const { id } = req.params;

  const user = await prisma.user.findUnique({ where: { id: id } });

  if (!user) throw new BadRequestError("User not found");

  res.status(StatusCodes.OK).json(user);
};

// @desc Get all users (Admin Only)
// @route GET /api/v1/users
// @access Admin
const getAllUsers = async (req, res) => {
  const users = await prisma.user.findMany();
  res.status(StatusCodes.OK).json(users);
};

// @desc Update the authenticated user
// @route PATCH /api/v1/users/me
// @access Private
const updateUser = async (req, res) => {
  res.status(StatusCodes.OK).json({ message: "User updated successfully" });
};

// @desc Delete the authenticated user
// @route DELETE /api/v1/users/me
// @access Private
const deleteUser = async (req, res) => {
  res.status(StatusCodes.OK).json({ message: "User deleted successfully" });
};

// @desc Delete a user by ID (Admin Only)
// @route DELETE /api/v1/users/:id
// @access Admin
const deleteUserById = async (req, res) => {
  res.status(StatusCodes.OK).json({ message: "User deleted successfully" });
};

module.exports = {
  getSingleUser,
  getAllUsers,
  updateUser,
  deleteUser,
  deleteUserById,
};

////////////////////////////////////////////////////////////////////////////////

├── errors
│   ├── BadRequestError.js

////////////////////////////////////////////////////////////////////////////////
const CustomAPIError = require("./customAPIError");
const { StatusCodes } = require("http-status-codes");

class BadrequestError extends CustomAPIError {
  constructor(message, data = null) {
    super(message);
    this.statusCode = StatusCodes.BAD_REQUEST;
    this.data = data; // Add custom data field
  }
}

module.exports = BadrequestError;

////////////////////////////////////////////////////////////////////////////////

│   ├── ConflictError.js

////////////////////////////////////////////////////////////////////////////////
const CustomAPIError = require("./customAPIError");
const { StatusCodes } = require("http-status-codes");

class ConflictError extends CustomAPIError {
  constructor(message) {
    super(message);
    this.statusCode = StatusCodes.CONFLICT; // 409
  }
}

module.exports = ConflictError;

////////////////////////////////////////////////////////////////////////////////

│   ├── TooManyRequestsError.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const CustomAPIError = require("./customAPIError");

class TooManyRequestsError extends CustomAPIError {
  constructor(message = "Too many requests. Please try again later.") {
    super(message);
    this.name = "TooManyRequestsError";
    this.statusCode = StatusCodes.TOO_MANY_REQUESTS;
  }
}

module.exports = TooManyRequestsError;

////////////////////////////////////////////////////////////////////////////////

│   ├── UnauthenticatedError.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const CustomAPIError = require("./customAPIError");

class UnauthenticatedError extends CustomAPIError {
  constructor(message) {
    super(message);
    this.statusCode = StatusCodes.UNAUTHORIZED;
  }
}

module.exports = UnauthenticatedError;

////////////////////////////////////////////////////////////////////////////////

│   ├── UnautherizedError.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const CustomAPIError = require("./customAPIError");

class UnauthorizedError extends CustomAPIError {
  constructor(message) {
    super(message);
    this.statusCode = StatusCodes.FORBIDDEN;
  }
}

module.exports = UnauthorizedError;

////////////////////////////////////////////////////////////////////////////////

│   ├── customAPIError.js

////////////////////////////////////////////////////////////////////////////////
class CustomAPIError extends Error {
  constructor(message, statusCode = 500, data = null) {
    super(message);
    this.statusCode = statusCode;
    this.data = data;
  }
}

module.exports = CustomAPIError;

////////////////////////////////////////////////////////////////////////////////

│   ├── index.js

////////////////////////////////////////////////////////////////////////////////
const CustomAPIError = require("./customAPIError");
const UnauthenticatedError = require("./UnauthenticatedError");
const NotFoundError = require("./not-found");
const BadRequestError = require("./BadRequestError");
const UnauthorizedError = require("./UnautherizedError");
const TooManyRequestsError = require("./TooManyRequestsError");
const ConflictError = require("./ConflictError");

module.exports = {
  CustomAPIError,
  UnauthenticatedError,
  NotFoundError,
  BadRequestError,
  UnauthorizedError,
  TooManyRequestsError,
  ConflictError
};

////////////////////////////////////////////////////////////////////////////////

│   └── not-found.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");
const CustomAPIError = require("./customAPIError");

class NotFoundError extends CustomAPIError {
  constructor(message) {
    super(message);
    this.statusCode = StatusCodes.NOT_FOUND;
  }
}

module.exports = NotFoundError;

////////////////////////////////////////////////////////////////////////////////

├── jest.config.js

////////////////////////////////////////////////////////////////////////////////
module.exports = {
  testEnvironment: "node",
  moduleDirectories: ["node_modules", "<rootDir>/"],
  roots: ["<rootDir>/tests"],
};

////////////////////////////////////////////////////////////////////////////////

├── jobs
│   └── cron.js

////////////////////////////////////////////////////////////////////////////////
const cron = require("node-cron");
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

// Schedule a cron job to delete expired OTPs every 15 minutes
cron.schedule("*/15 * * * *", async () => {
  console.log("Cleaning up expired OTPs...");

  try {
    const { count } = await prisma.verificationCode.deleteMany({
      where: { expiresAt: { lt: new Date() } },
    });

    console.log(`Deleted ${count} expired OTP(s)`);
  } catch (error) {
    console.error("Error deleting expired OTPs:", error);
  }
});

////////////////////////////////////////////////////////////////////////////////

├── middlewares
│   ├── authentication.js

////////////////////////////////////////////////////////////////////////////////
const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();
const { UnauthenticatedError, UnauthorizedError } = require("../errors");
const tokenUtils = require("../utils/tokenUtils");

const authenticateUser = async (req, res, next) => {
  // Check for access token in headers
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    throw new UnauthenticatedError("Authentication invalid");
  }

  const accessToken = authHeader.split(" ")[1];

  if (!accessToken) {
    throw new UnauthenticatedError("Authentication invalid");
  }

  try {
    // Verify access token
    const payload = tokenUtils.verify(accessToken);
    req.user = {
      userId: payload.userId,
      tokenType: "access",
    };
    next();
  } catch (error) {
    throw new UnauthenticatedError("Authentication invalid");
  }

  console.log("⭐ Authenticated user:", req.user);
};

const authorizeRoles = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      throw new UnauthorizedError("Unauthorized to access this route");
    }
    next();
  };
};

const validateTokenType = (type) => {
  return (req, res, next) => {
    if (req.user.tokenType !== type) {
      throw new UnauthorizedError(`Invalid token type for this operation`);
    }
    next();
  };
};

module.exports = {
  authenticateUser,
  authorizeRoles,
  validateTokenType,
};

////////////////////////////////////////////////////////////////////////////////

│   ├── errorHandler.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");

const errorHandlerMiddleware = (err, req, res, next) => {
  let customError = {
    statusCode: err.statusCode || StatusCodes.INTERNAL_SERVER_ERROR,
    msg: err.message || "Something went wrong, please try again later",
  };

  // Prisma Validation Error
  if (err.name === "PrismaClientValidationError") {
    customError.msg = "Invalid request data";
    customError.statusCode = StatusCodes.BAD_REQUEST;
  }

  // Prisma Known Request Error (e.g., Unique Constraint)
  if (err.name === "PrismaClientKnownRequestError") {
    if (err.code === "P2002") {
      customError.msg = `Duplicate value entered for ${Object.keys(
        err.meta.target
      )} field`;
      customError.statusCode = StatusCodes.BAD_REQUEST;
    }
  }

  // Joi Validation Errors (from request body validation)
  if (err.details) {
    customError.msg = "Validation Error";
    customError.statusCode = StatusCodes.BAD_REQUEST;
    customError.errors = err.details.map((detail) => detail.message);
  }

  // Mongoose Validation Errors
  if (err.name === "ValidationError") {
    customError.msg = Object.values(err.errors)
      .map((item) => item.message)
      .join(", ");
    customError.statusCode = StatusCodes.BAD_REQUEST;
  }

  // Duplicate Key Error (MongoDB)
  if (err.code && err.code === 11000) {
    customError.msg = `Duplicate value entered for ${Object.keys(
      err.keyValue
    )} field`;
    customError.statusCode = StatusCodes.BAD_REQUEST;
  }

  // Cast Error (Invalid ObjectId in MongoDB)
  if (err.name === "CastError") {
    customError.msg = `No item found with id: ${err.value}`;
    customError.statusCode = StatusCodes.NOT_FOUND;
  }

  // ✅ Include additional data from CustomAPIError (e.g., invalid categories)
  const response = {
    success: false,
    message: customError.msg,
    ...(err.data && { data: err.data }), // Include `err.data` only if it exists
  };

  // Include stack trace only in development
  if (process.env.NODE_ENV === "development") {
    response.stackTrace = err.stack;
  }

  return res.status(customError.statusCode).json(response);
};

module.exports = errorHandlerMiddleware;

////////////////////////////////////////////////////////////////////////////////

│   ├── notFound.js

////////////////////////////////////////////////////////////////////////////////
const notFound = (req, res) => {
    res.status(404).send(`Route does not exist`);
};

module.exports = notFound;
////////////////////////////////////////////////////////////////////////////////

│   ├── parseFormData.js

////////////////////////////////////////////////////////////////////////////////
// middlewares/parseFormData.js
const parseFormData = (req, res, next) => {
  try {
    // Convert `categories` from string to an array
    if (req.body.categories) {
      req.body.categories = JSON.parse(req.body.categories);
    }

    // Convert `recipeCreationPermission` to uppercase
    if (req.body.recipeCreationPermission) {
      req.body.recipeCreationPermission = req.body.recipeCreationPermission.toUpperCase();
    }

    next();
  } catch (error) {
    return res.status(400).json({
      success: false,
      error: "Invalid input format",
      message: "Ensure categories is a valid JSON array",
    });
  }
};

module.exports = parseFormData
////////////////////////////////////////////////////////////////////////////////

│   ├── uploadImage.middleware.js

////////////////////////////////////////////////////////////////////////////////
const multer = require("multer");
const path = require("path");
const fs = require("fs");
const cloudinary = require("../config/cloudinary"); // Import Cloudinary config

// Ensure uploads directory exists
const uploadDir = "uploads";
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir);
}

// Configure storage settings
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, "community-" + uniqueSuffix + path.extname(file.originalname));
  },
});

// File filter to allow only images
const fileFilter = (req, file, cb) => {
  const allowedFileTypes = /jpeg|jpg|png|gif/;
  const extname = allowedFileTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedFileTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    return cb(new Error("Only images (jpeg, jpg, png, gif) are allowed!"));
  }
};

// Initialize multer with storage and file filtering
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // Limit file size to 5MB
});

// Middleware to handle file uploads and Cloudinary upload
const uploadMiddleware = (req, res, next) => {
  console.log("⭐ Starting file upload");
  
  upload.single("image")(req, res, async (err) => {
    if (err instanceof multer.MulterError) {
      console.error("⭐ Multer error:", err);
      if (err.code === "LIMIT_FILE_SIZE") {
        return res.status(400).json({
          success: false,
          message: "File size too large. Maximum size is 5MB",
        });
      }
      return res.status(400).json({
        success: false,
        message: `Upload error: ${err.message}`,
      });
    } else if (err) {
      console.error("⭐ Upload error:", err);
      return res.status(400).json({
        success: false,
        message: err.message,
      });
    }

    // If no file was uploaded
    if (!req.file) {
      console.log("⭐ No file uploaded");
      req.body.image = null;
      return next();
    }

    console.log("⭐ File uploaded locally:", req.file.path);

    try {
      // Upload file to Cloudinary
      const result = await cloudinary.uploader.upload(req.file.path, {
        folder: "community_images",
      });

      // Delete the local file after successful upload
      fs.unlinkSync(req.file.path);
      console.log("⭐ Local file deleted:", req.file.path);

      // Store Cloudinary URL in req.body.image
      req.body.image = result.secure_url;
      console.log("⭐ Cloudinary URL:", req.body.image);

      next();
    } catch (cloudinaryError) {
      console.error("⭐ Cloudinary upload error:", cloudinaryError);
      return res.status(500).json({
        success: false,
        message: "Failed to upload image to Cloudinary",
      });
    }
  });
};

module.exports = uploadMiddleware;

////////////////////////////////////////////////////////////////////////////////

│   └── validate.js

////////////////////////////////////////////////////////////////////////////////
const { StatusCodes } = require("http-status-codes");

const validateRequest = (schema, property = "body") => (req, res, next) => {
  const { error } = schema.validate(req[property], { abortEarly: false });

  if (error) {
    const errorDetails = {};

    error.details.forEach((err) => {
      const field = err.context.key;
      errorDetails[field] = err.message; // Assign error message per field
    });

    return res.status(StatusCodes.BAD_REQUEST).json({
      success: false,
      error: "ValidationError",
      message: "Invalid input data",
      details: errorDetails, // Send structured errors
    });
  }

  next();
};

module.exports = validateRequest;

////////////////////////////////////////////////////////////////////////////////

├── models
│   └── userModel.js

////////////////////////////////////////////////////////////////////////////////
const { PrismaClient } = require("@prisma/client");
const bcrypt = require("bcrypt");
const tokenUtils = require("../utils/tokenUtils");
const passwordUtils = require("../utils/passwordUtils");

const prisma = require("../config/prismaClient");

// Register a new user
const registerUser = async (data) => {
  const { name, email, password } = data;

  // Hash password before saving
  const hashedPassword = await passwordUtils.hash(password);

  // Create user in DB
  const user = await prisma.user.create({
    data: { name, email, password: hashedPassword },
  });

  return user;
};

// Generate JWT
const generateAuthToken = (user) => {
  return tokenUtils.sign({
    userId: user.id,
    name: user.name,
  });
};

// Compare password
const comparePassword = async (candidatePassword, storedPassword) => {
  return passwordUtils.compare(candidatePassword, storedPassword);
};

module.exports = {
  registerUser,
  generateAuthToken,
  comparePassword,
};

////////////////////////////////////////////////////////////////////////////////

├── prisma
│   ├── migrations
│   │   ├── 20250213175739_init
│   │   ├── 20250220033240_update_user_model
│   │   ├── 20250220033912_add_username
│   │   ├── 20250220212723_added_otp_table
│   │   ├── 20250220213939_made_name_nullable
│   │   ├── 20250223231854_add_refresh_token_model
│   │   ├── 20250302215553_add_password_reset_token
│   │   ├── 20250304234401_add_is_active_to_refresh_token_model
│   │   ├── 20250308223957_added_on_delete_cascade_password_reset_token
│   │   ├── 20250316194224_added_community_model
│   │   ├── 20250321034855_added_community_model
│   │   ├── 20250321040656_added_community_model
│   │   ├── 20250321213820_remov_slug
│   │   ├── 20250322033153_on_delete
│   │   ├── 20250322033423_on_delete
│   │   ├── 20250326011603_communiy_model
│   │   ├── 20250412235246_init
│   │   └── migration_lock.toml

////////////////////////////////////////////////////////////////////////////////
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
////////////////////////////////////////////////////////////////////////////////

│   └── schema.prisma

////////////////////////////////////////////////////////////////////////////////
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String               @id @default(uuid())
  name               String?              @db.VarChar(50)
  username           String               @unique @db.VarChar(50)
  email              String               @unique @db.VarChar(255)
  password           String               @db.Text
  isVerified         Boolean              @default(false)
  verifiedAt         DateTime?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @default(now()) @updatedAt

  verificationCodes  VerificationCode[]
  refreshTokens      RefreshToken[]
  PasswordResetToken PasswordResetToken[]

  // Back-relations for explicit relations:
  communitiesOwned   Community[]          @relation("CommunityOwner")
  communityMemberships CommunityMember[]
  posts              Post[]
  comments           Comment[]
  votes              Vote[]
  reportsMade        ReportedContent[]    @relation("Reporter")
  reportsReceived    ReportedContent[]    @relation("ReportedUser")
  resolvedReports    ReportedContent[]    @relation("Resolver")
}

model VerificationCode {
  id        String    @id @default(uuid())
  code      String    @db.Text
  expiresAt DateTime
  createdAt DateTime  @default(now())
  isUsed    Boolean   @default(false)
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@unique([userId, code])
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  isActive  Boolean  @default(true)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())
  expiresAt DateTime

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum CommunityPrivacy {
  PUBLIC
  PRIVATE
  RESTRICTED
}

enum RecipeCreationPermission {
  ANY_MEMBER
  ADMIN_ONLY
}

model Community {
  id          String           @id @default(uuid())
  name        String           @unique @db.VarChar(100)
  description String?
  owner       User             @relation("CommunityOwner", fields: [ownerId], references: [id])
  ownerId     String
  image       String?
  privacy     CommunityPrivacy @default(PUBLIC)
  recipeCreationPermission RecipeCreationPermission @default(ANY_MEMBER)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @default(now()) @updatedAt

  members     CommunityMember[]
  posts       Post[]
  rules       CommunityRule[] 
  events      CommunityEvent[]
  invitations CommunityInvitation[]
  flairs      PostFlair[]
  categories  CommunityCategory[]
  
  @@index([ownerId])
}

model CommunityMember {
  community   Community  @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId String
  user        User       @relation(fields: [userId], references: [id])
  userId      String
  role        Role       @default(MEMBER)
  joinedAt    DateTime   @default(now())
  leftAt      DateTime?
  isPending   Boolean    @default(false)

  @@id([communityId, userId])  // Composite primary key
}


enum Role {
  MEMBER
  MODERATOR
  ADMIN
}

model Post {
  id           String         @id @default(uuid())
  title        String         @db.VarChar(200)
  content      String
  author       User           @relation(fields: [authorId], references: [id])
  authorId     String
  community    Community      @relation(fields: [communityId], references: [id])
  communityId  String
  comments     Comment[]
  votes        Vote[]
  flairs       PostFlair[]
  viewCount    Int            @default(0)
  isLocked     Boolean        @default(false)
  allowComments Boolean       @default(true)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @default(now()) @updatedAt

  // Back-relation for ReportedContent linked to a Post
  reports      ReportedContent[] @relation("PostReport")

  @@index([communityId])
  @@index([authorId])
}

model Comment {
  id          String     @id @default(uuid())
  content     String
  post        Post       @relation(fields: [postId], references: [id])
  postId      String
  author      User       @relation(fields: [authorId], references: [id])
  authorId    String
  parentId    String?    // For nested comments
  votes       Vote[]
  isDeleted   Boolean    @default(false)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @default(now()) @updatedAt

  // Back-relation for ReportedContent linked to a Comment
  reports     ReportedContent[] @relation("CommentReport")

  @@index([postId])
  @@index([authorId])
}

model Vote {
  id         String     @id @default(uuid())
  type       VoteType
  user       User       @relation(fields: [userId], references: [id])
  userId     String
  post       Post?      @relation(fields: [postId], references: [id])
  postId     String?
  comment    Comment?   @relation(fields: [commentId], references: [id])
  commentId  String?
  createdAt  DateTime   @default(now())
  
  @@unique([userId, postId, commentId])
}

enum VoteType {
  UPVOTE
  DOWNVOTE
}

model PostFlair {
  id          String     @id @default(uuid())
  name        String     @db.VarChar(30)
  color       String     @db.Char(7)
  community   Community  @relation(fields: [communityId], references: [id])
  communityId String
  posts       Post[]
}

model ReportedContent {
  id             String       @id @default(uuid())

  reporter       User         @relation("Reporter", fields: [reporterId], references: [id])
  reporterId     String

  post           Post?        @relation("PostReport", fields: [postId], references: [id])
  postId         String?

  comment        Comment?     @relation("CommentReport", fields: [commentId], references: [id])
  commentId      String?

  reportedUser   User?        @relation("ReportedUser", fields: [reportedUserId], references: [id])
  reportedUserId String?

  reason         String
  status         ReportStatus @default(PENDING)

  resolvedBy     User?        @relation("Resolver", fields: [resolvedById], references: [id])
  resolvedById   String?

  resolution     String?

  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @default(now()) @updatedAt
}

enum ReportStatus {
  PENDING
  RESOLVED
  DISMISSED
}

model CommunityInvitation {
  id          String     @id @default(uuid())
  community   Community  @relation(fields: [communityId], references: [id])
  communityId String
  email       String     @db.VarChar(255)
  token       String     @unique
  expiresAt   DateTime
  status      InvitationStatus @default(PENDING)
  createdAt   DateTime   @default(now())
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  EXPIRED
}

model CommunityRule {
  id          String     @id @default(uuid())
  community   Community  @relation(fields: [communityId], references: [id])
  communityId String
  title       String     @db.VarChar(100)
  description String
  order       Int
  createdAt   DateTime   @default(now())
}

model CommunityEvent {
  id          String     @id @default(uuid())
  community   Community  @relation(fields: [communityId], references: [id])
  communityId String
  title       String     @db.VarChar(100)
  description String
  startDate   DateTime
  endDate     DateTime?
  location    String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @default(now()) @updatedAt
}

model Category {
  id        String    @id @default(uuid())
  name      String    @db.VarChar(100)
  parent    Category? @relation("CategoryHierarchy", fields: [parentId], references: [id])
  parentId  String?
  children  Category[] @relation("CategoryHierarchy")

  // Link to communities
  communities CommunityCategory[]
}

model CommunityCategory {
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId String
  category    Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId  String

  @@id([communityId, categoryId]) // Composite primary key
}
////////////////////////////////////////////////////////////////////////////////

├── repositories
│   └── community.repository.js

////////////////////////////////////////////////////////////////////////////////
/**
 * @fileoverview Community repository for handling database queries
 * @module repositories/community
 */

const prisma = require("../config/prismaClient");

/**
 * Repository layer for community-related database operations
 */
class CommunityRepository {
  /**
   * Find a community by name
   * @param {string} name - Community name
   * @returns {Promise<Object|null>} Found community or null
   */
  async findByName(name) {
    return prisma.community.findFirst({
      where: { name },
    });
  }

  /**
   * Find categories by names
   * @param {string[]} categoryNames - Array of category names
   * @returns {Promise<Array>} Found categories
   */
  async findCategoriesByNames(categoryNames) {
    return prisma.category.findMany({
      where: { name: { in: categoryNames } },
      select: { id: true, name: true },
    });
  }

  /**
   * Create a new community with all relations
   * @param {Object} communityData - Community data with relations
   * @returns {Promise<Object>} Created community
   */
  async create(communityData) {
    return prisma.community.create({
      data: communityData,
      include: {
        categories: {
          include: {
            category: true,
          },
        },
        members: {
          select: {
            role: true,
            joinedAt: true,
            isPending: true,
            user: {
              select: {
                id: true,
                name: true,
                username: true,
              },
            },
          },
        },
        owner: {
          select: {
            id: true,
            name: true,
            username: true,
          },
        },
      },
    });
  }

  /**
   * Find a community by ID with all relations
   * @param {string} id - Community ID
   * @returns {Promise<Object|null>} Found community or null
   */
  async findById(id) {
    return prisma.community.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        description: true,
        image: true,
        privacy: true,
        recipeCreationPermission: true,
        createdAt: true,
        updatedAt: true,
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        members: {
          select: {
            role: true,
            joinedAt: true,
            isPending: true,
            user: {
              select: {
                id: true,
                name: true,
                username: true,
              },
            },
          },
        },
        owner: {
          select: {
            id: true,
            name: true,
            username: true,
          },
        },
      },
    });
  }

  /**
   * Find all communities with relations
   * @returns {Promise<Array>} List of communities
   */
  async findAll() {
    return prisma.community.findMany({
      select: {
        id: true,
        name: true,
        description: true,
        image: true,
        privacy: true,
        recipeCreationPermission: true,
        createdAt: true,
        updatedAt: true,
        categories: {
          select: {
            category: {
              select: {
                id: true,
                name: true,
              },
            },
          },
        },
        members: {
          select: {
            role: true,
            joinedAt: true,
            user: {
              select: {
                id: true,
                name: true,
                username: true,
              },
            },
          },
        },
        owner: {
          select: {
            id: true,
            name: true,
            username: true,
          },
        },
      },
    });
  }

  /**
   * Check if a user is a member of a community
   * @param {string} communityId - The ID of the community
   * @param {string} userId - The ID of the user
   */
  async isMember(communityId, userId) {
    const membership = await prisma.communityMember.findFirst({
      where: {
        communityId: communityId,
        userId: userId,
      },
    });
  }

  /**
   * Gets all the members of a specific community by ID
   * @param {string} communityId - The ID of the community
   * @returns {Promise<Array>} - An array of community members
   */
  async getAllMembers(communityId) {
    const members = await prisma.communityMember.findMany({
      where: { communityId },
    });
    return members;
  }

  /**
   * Add a user to community
   * @param {string} communityId - The ID of the community
   * @param {string} userId - The ID of the user
   * @param {string} role - The role of the user(Admin, Member)
   * @returns {Promise<object>}
   */
  async addMember(communityId, userId, role) {
    return prisma.communityMember.create({
      data: {
        communityId: communityId,
        userId: userId,
        role: role,
      },
    });
  }
}

module.exports = new CommunityRepository();

////////////////////////////////////////////////////////////////////////////////

├── routes
│   ├── auth.routes.js

////////////////////////////////////////////////////////////////////////////////
const express = require("express");

const {
  registerUser,
  loginUser,
  logoutUser,
  changePassword,
  verifyEmail,
  resendVerification,
  forgotPassword,
  refreshAccessToken,
  resetPassword,
  quickLoginUser,
} = require("../controllers/auth.controller");

// register
const validateRequest = require("../middlewares/validate");

// validators
const {
  registerSchema,
  otpSchema,
  loginSchema,
  resendVerificationSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
  refreshTokenSchema,
} = require("../validators/authValidator");
const { valid } = require("joi");

const router = express.Router();

// Public Routes
router.post("/login", validateRequest(loginSchema), loginUser);
router.post(
  "/quick-login",
  validateRequest(refreshTokenSchema),
  quickLoginUser
);
router.post("/register", validateRequest(registerSchema), registerUser);
router.post("/verify-email", validateRequest(otpSchema), verifyEmail);
router.post(
  "/resend-verification",
  validateRequest(resendVerificationSchema),
  resendVerification
);
router.post(
  "/forgot-password",
  validateRequest(forgotPasswordSchema),
  forgotPassword
);

router.post(
  "/reset-password",
  validateRequest(resetPasswordSchema),
  resetPassword
);

// Protected Routes
router.post("/logout", validateRequest(refreshTokenSchema), logoutUser);
router.patch("/change-password", changePassword);
router.get(
  "/refresh-token",
  validateRequest(refreshTokenSchema),
  refreshAccessToken
);

module.exports = router;

////////////////////////////////////////////////////////////////////////////////

│   ├── community.routes.js

////////////////////////////////////////////////////////////////////////////////
const express = require("express");
const {
  createCommunity,
  getSingleCommunity,
  getAllCommunities,
  joinCommunity,
  getAllMembers,
  leaveCommunity,
} = require("../controllers/community.controller");
const { authenticateUser } = require("../middlewares/authentication");
const {
  createCommunitySchema,
  getAllMembersSchema,
  leaveCommunitySchema,
} = require("../validators/communityValidator");
const validateRequest = require("../middlewares/validate");
const parseFormData = require("../middlewares/parseFormData");
const uploadMiddleware = require("../middlewares/uploadImage.middleware");

const router = express.Router();

router.post(
  "/",
  authenticateUser,
  uploadMiddleware, // Handles file upload and validation
  parseFormData,
  validateRequest(createCommunitySchema),
  createCommunity
);

router.get("/:id", authenticateUser, getSingleCommunity);

router.get("/", authenticateUser, getAllCommunities);

router.post("/:id/join", authenticateUser, joinCommunity);

router.get(
  "/:id/members",
  authenticateUser,
  validateRequest(getAllMembersSchema, "params"),
  getAllMembers
);

router.delete(
  "/:id/leave",
  authenticateUser,
  validateRequest(leaveCommunitySchema, "params"),
  leaveCommunity
);

module.exports = router;

////////////////////////////////////////////////////////////////////////////////

│   ├── meal.routes.js

////////////////////////////////////////////////////////////////////////////////
const express = require("express");
const { authenticateUser } = require("../middlewares/authentication");

const { 
  getRecommendedMeals, 
  getMealById, 
  getTrendingMeals,
  recordMealInteraction,
  getQuickMeals,
  getCuisineRecommendations,
  getDietaryRecommendations,
  getSimilarMeals,
  getFilteredRecipes,
  getRecipesByCalories,
  advancedSearch  
} = require("../controllers/meal.controller");

const router = express.Router();

// Public routes
router.get("/search/advanced", advancedSearch);
router.get("/recommended", getRecommendedMeals);
router.get("/trending", getTrendingMeals);
router.get("/quick", getQuickMeals);
router.get("/cuisine/:cuisine_id", getCuisineRecommendations);
router.get("/dietary/:dietary_restriction", getDietaryRecommendations);
router.get("/similar/:id", getSimilarMeals);
router.get("/filter", getFilteredRecipes);
router.get("/filter/calories", getRecipesByCalories);
router.get("/:id", getMealById);

// Protected routes (require authentication)
router.post("/interaction", authenticateUser, recordMealInteraction);

module.exports = router;


////////////////////////////////////////////////////////////////////////////////

│   ├── system.routes.js

////////////////////////////////////////////////////////////////////////////////
const express = require("express");
const router = express.Router();
const config = require("../config/pythonService");
const axios = require("axios");

// System health check endpoint
router.get("/health", async (req, res) => {
  try {
    const systemInfo = {
      status: "ok",
      timestamp: new Date().toISOString(),
      environment: process.env.NODE_ENV || "development",
      nodejs: {
        version: process.version,
        uptime: process.uptime(),
        memoryUsage: process.memoryUsage(),
      },
      config: {
        pythonService: {
          baseUrl: config.baseUrl,
          apiVersion: config.apiVersion,
          timeout: config.timeout,
          defaultUserId: config.defaultUserId
        }
      }
    };

    // Check Python service connectivity
    try {
      const pythonServiceUrl = `${config.baseUrl}/api/${config.apiVersion}/health`;
      console.log(`Checking Python service at: ${pythonServiceUrl}`);
      
      const response = await axios.get(pythonServiceUrl, { timeout: 3000 });
      systemInfo.pythonService = {
        status: "connected",
        response: response.data
      };
    } catch (error) {
      systemInfo.pythonService = {
        status: "error",
        error: error.message,
        code: error.code,
        details: error.isAxiosError 
          ? {
              config: error.config ? {
                url: error.config.url,
                method: error.config.method,
                timeout: error.config.timeout
              } : 'No config available'
            }
          : 'Not an Axios error'
      };
    }

    res.status(200).json(systemInfo);
  } catch (error) {
    res.status(500).json({
      status: "error",
      message: error.message,
      stack: process.env.NODE_ENV === "development" ? error.stack : undefined
    });
  }
});

module.exports = router;
////////////////////////////////////////////////////////////////////////////////

│   ├── upload.routes.js

////////////////////////////////////////////////////////////////////////////////
// const express = require("express");
// const multer = require("multer");
// const path = require("path");

// const router = express.Router(); // Initialize router

// // Configure storage settings
// const storage = multer.diskStorage({
//   destination: function (req, file, cb) {
//     cb(null, "uploads/"); // Folder where images will be stored
//   },
//   filename: function (req, file, cb) {
//     cb(
//       null,
//       file.fieldname + "-" + Date.now() + path.extname(file.originalname)
//     );
//   },
// });

// // File filter to allow only images
// const fileFilter = (req, file, cb) => {
//   const allowedFileTypes = /jpeg|jpg|png|gif/;
//   const extname = allowedFileTypes.test(
//     path.extname(file.originalname).toLowerCase()
//   );
//   const mimetype = allowedFileTypes.test(file.mimetype);

//   if (extname && mimetype) {
//     return cb(null, true);
//   } else {
//     return cb(new Error("Only images are allowed!"));
//   }
// };

// // Initialize multer with storage and file filtering
// const upload = multer({
//   storage: storage,
//   fileFilter: fileFilter,
//   limits: { fileSize: 5 * 1024 * 1024 }, // Limit file size to 5MB
// });

// // API Route to Handle Image Upload
// router.post("/", upload.single("image"), (req, res) => {
//   if (!req.file) {
//     return res.status(400).json({ message: "No file uploaded!" });
//   }
//   res.json({ message: "File uploaded successfully!", file: req.file });
// });

// module.exports = router;

const express = require("express");
const multer = require("multer");
const path = require("path");

// Configure storage settings
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/"); // Folder where images will be stored
  },
  filename: function (req, file, cb) {
    cb(
      null,
      file.fieldname + "-" + Date.now() + path.extname(file.originalname)
    );
  },
});

// File filter to allow only images
const fileFilter = (req, file, cb) => {
  const allowedFileTypes = /jpeg|jpg|png|gif/;
  const extname = allowedFileTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedFileTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    return cb(new Error("Only images are allowed!"));
  }
};

// Initialize multer with storage and file filtering
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // Limit file size to 5MB
});

// Controller function to handle file upload
const uploadImage = (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: "No file uploaded!" });
  }
  res.json({ message: "File uploaded successfully!", file: req.file });
};

const router = express.Router();

// API Route to Handle Image Upload
router.post("/", upload.single("image"), uploadImage);

module.exports = router;

////////////////////////////////////////////////////////////////////////////////

│   └── user.routes.js

////////////////////////////////////////////////////////////////////////////////
const express = require("express");

const {
  getSingleUser,
  getAllUsers,
  updateUser,
  deleteUser,
} = require("../controllers/user.controller");

const router = express.Router();

//  User Management Routes
router.route("/me").get(getSingleUser).patch(updateUser).delete(deleteUser);

// Admin Routes
router.get("/", getAllUsers);
router.get("/:id", getSingleUser);
router.delete("/:id", deleteUser);

module.exports = router;

////////////////////////////////////////////////////////////////////////////////

├── services
│   ├── community.service.js

////////////////////////////////////////////////////////////////////////////////
/**
 * @fileoverview Community controller for handling HTTP requests
 * @module controllers/community
 */

const CustomAPIError = require("../errors");
const communityRepository = require("../repositories/community.repository");

/**
 * Service layer for community-related business logic
 */
class CommunityService {
  /**
   * Create a new community
   * @param {Object} data - Community data
   * @param {string} userId - User ID of the creator
   * @returns {Promise<Object>} Created community
   */
  async createCommunity(data, userId) {
    const { name, description, image, recipeCreationPermission, privacy } =
      data;

    // Check if community with same name already exists
    const existingCommunity = await communityRepository.findByName(name);
    if (existingCommunity) {
      throw new CustomAPIError.ConflictError(
        "A community with this name already exists"
      );
    }

    // Parse categories from request body, ensuring it's an array
    let parsedCategories = [];
    if (data.categories) {
      try {
        // If it's a string (from form data), parse it
        if (typeof data.categories === "string") {
          // Check if it looks like a JSON array string
          if (data.categories.trim().startsWith("[")) {
            parsedCategories = JSON.parse(data.categories);
          } else {
            // If it's a comma-separated string or single value
            parsedCategories = data.categories.split(",").map((c) => c.trim());
          }
        } else if (Array.isArray(data.categories)) {
          // If it's already an array, use it directly
          parsedCategories = data.categories;
        }
      } catch (error) {
        console.error("Error parsing categories:", error);
        throw new CustomAPIError.BadRequestError(
          "Categories must be a valid JSON array or comma-separated values"
        );
      }
    }

    // Base community data
    const communityData = {
      name,
      description,
      image,
      privacy: privacy || "PUBLIC",
      recipeCreationPermission: recipeCreationPermission || "ANY_MEMBER",
      ownerId: userId,
      // Create owner as ADMIN member
      members: {
        create: {
          userId,
          role: "ADMIN",
        },
      },
    };

    // Process categories if any
    if (parsedCategories.length > 0) {
      // Fetch categories by name
      const existingCategories =
        await communityRepository.findCategoriesByNames(parsedCategories);

      // Check for invalid categories
      const foundCategoryNames = existingCategories.map((cat) => cat.name);
      const invalidCategories = parsedCategories.filter(
        (name) => !foundCategoryNames.includes(name)
      );

      if (invalidCategories.length > 0) {
        throw new CustomAPIError.BadRequestError(
          `Categories not found: ${invalidCategories.join(", ")}`
        );
      }

      // Add categories to community data
      communityData.categories = {
        create: existingCategories.map((category) => ({
          category: {
            connect: { id: category.id },
          },
        })),
      };
    }

    // Create the community with all related data
    const newCommunity = await communityRepository.create(communityData);

    // Format the community data for response
    return this.formatCommunityResponse(newCommunity);
  }

  /**
   * Get a community by ID
   * @param {string} id - Community ID
   * @returns {Promise<Object>} Community data
   */
  async getCommunityById(id) {
    const community = await communityRepository.findById(id);

    if (!community) {
      throw new CustomAPIError.NotFoundError(
        `No community found with id: ${id}`
      );
    }

    return this.formatCommunityResponse(community);
  }

  /**
   * Get all communities
   * @returns {Promise<Array>} List of communities
   */
  async getAllCommunities() {
    const communities = await communityRepository.findAll();
    return communities.map((community) =>
      this.formatCommunityResponse(community)
    );
  }

  /**
   * Join a community
   * @param {string} communityId - Community ID
   * @param {string} userId - User ID
   * @returns {Promise<Object>} Updated community
   */
  async joinCommunity(communityId, userId) {
    /*
    - Check if community exists
    - Check if user is already a member
    - Check if community is private and user is not a member
    - Add user to community
    - Return updated community
    */
    const community = await communityRepository.findById(communityId);
    if (!community) {
      throw new CustomAPIError.NotFoundError(
        `Community with id ${communityId} not found`
      );
    }

    const isMember = await communityRepository.isMember(communityId, userId);
    if (isMember) {
      throw new CustomAPIError.ConflictError(
        "User is already a member of this community."
      );
    }

    const addedMember = await communityRepository.addMember(
      communityId,
      userId,
      "MEMBER"
    );

    return addedMember;
  }
  /**
   * Leaves a community
   * @param {string} communityId - Community ID
   * @param {string} userId - User ID
   * @returns {Promise<Object>} Updated community
   */
  async leaveCommunity(communityId, userId) {
    /**
     * check for communiy Id and userId first
     * check if user is already a member or not
     * ckeck if the user is the only admin
     *  if there are other users make make the one who joined after him an admin
     *  If there are no other members, delete the community.
     * If they are not the only one admin, just remove him.
     */
  }
  /**
   * Gets all the members of a community
   * @param {string} communityId - Community ID
   */
  async getAllMembers(id) {
    return await communityRepository.getAllMembers(id);
  }

  /**
   * Format community data for response
   * @param {Object} community - Raw community data
   * @returns {Object} Formatted community data
   */
  formatCommunityResponse(community) {
    return {
      ...community,
      categories: community.categories.map((cc) => cc.category),
    };
  }
}

module.exports = new CommunityService();

////////////////////////////////////////////////////////////////////////////////

│   ├── community.temp.js

////////////////////////////////////////////////////////////////////////////////
/**
 * @fileoverview Community controller for handling HTTP requests
 * @module controllers/community
 */

const { StatusCodes } = require("http-status-codes");
const communityService = require("../services/community.service");
const { clearCache } = require("../middlewares/cache");

/**
 * Creates a new community
 * @route POST /api/v1/community
 * @access Private
 */
const createCommunity = async (req, res) => {
  const { userId } = req.user;

  // Use the service to create the community
  const community = await communityService.createCommunity(req.body, userId);

  // Clear relevant caches when creating a new community
  clearCache(['/api/v1/community']);

  res.status(StatusCodes.CREATED).json({
    success: true,
    message: "Community created successfully",
    community,
  });
};

/**
 * Gets a single community by ID
 * @route GET /api/v1/community/:id
 * @access Private
 */
const getSingleCommunity = async (req, res) => {
  const { id } = req.params;

  // Use the service to get the community
  const community = await communityService.getCommunityById(id);

  res.status(StatusCodes.OK).json({
    success: true,
    community,
  });
};

/**
 * Gets all communities with pagination, sorting and filtering
 * @route GET /api/v1/community
 * @access Private
 */
const getAllCommunities = async (req, res) => {
  // Extract pagination, sorting and filtering parameters
  const { page, limit, sort, order, name, privacy, categories } = req.query;
  
  // Prepare filter object
  const filter = {};
  if (name) filter.name = name;
  if (privacy) filter.privacy = privacy;
  if (categories) {
    filter.categories = Array.isArray(categories) 
      ? categories 
      : categories.split(',').map(c => c.trim());
  }

  // Use the service to get all communities
  const { communities, total } = await communityService.getAllCommunities({
    page: parseInt(page, 10) || 1,
    limit: parseInt(limit, 10) || 10,
    sort: sort || 'createdAt',
    order: order || 'desc',
    filter
  });

  res.status(StatusCodes.OK).json({
    success: true,
    count: communities.length,
    total,
    currentPage: parseInt(page, 10) || 1,
    totalPages: Math.ceil(total / (parseInt(limit, 10) || 10)),
    communities,
  });
};

/**
 * Joins a user (as a member) to a community
 * @route POST /api/v1/community/:id/join
 * @acess Private
 */
const joinCommunity = async (req, res) => {
  const { userId } = req.user;
  const { id: communityId } = req.params;

  const membership = await communityService.joinCommunity(communityId, userId);

  // Clear relevant caches
  clearCache([
    `/api/v1/community/${communityId}`,
    `/api/v1/community/${communityId}/members`,
    `/api/v1/community/me/joined`
  ]);

  res.status(StatusCodes.CREATED).json({
    success: true,
    message: "Successfully joined the community",
    membership,
  });
};

/**
 * Gets all members of a community with pagination
 * @route GET /api/v1/communiy/:id/members
 * @access Private
 */
const getAllMembers = async (req, res) => {
  const { id: communityId } = req.params;
  const { page, limit, role } = req.query;

  const { members, total } = await communityService.getAllMembers(communityId, {
    page: parseInt(page, 10) || 1,
    limit: parseInt(limit, 10) || 10,
    role
  });

  res.status(StatusCodes.OK).json({
    success: true,
    count: members.length,
    total,
    currentPage: parseInt(page, 10) || 1,
    totalPages: Math.ceil(total / (parseInt(limit, 10) || 10)),
    members,
  });
};

module.exports = {
  createCommunity,
  getSingleCommunity,
  getAllCommunities,
  joinCommunity,
  getAllMembers,
};
////////////////////////////////////////////////////////////////////////////////

│   └── recipeService.js

////////////////////////////////////////////////////////////////////////////////
const axios = require('axios');
const config = require('../config/pythonService');
const recipeTransformer = require('../transformers/recipeTransformer');

class RecipeService {
  constructor() {
    // Validate configuration
    if (!config.baseUrl) {
      console.error('ERROR: PYTHON_SERVICE_URL is not defined in environment variables');
      console.error('Fallback to default URL: http://127.0.0.1:9999');
    }

    if (!config.apiVersion) {
      console.error('ERROR: PYTHON_API_VERSION is not defined in environment variables');
      console.error('Fallback to default version: v1');
    }

    // Log the configuration for debugging
    console.log(`RecipeService initializing with:`, {
      baseUrl: config.baseUrl,
      apiVersion: config.apiVersion,
      timeout: config.timeout,
      defaultUserId: config.defaultUserId
    });

    // Create axios client with validated configuration
    this.client = axios.create({
      baseURL: `${config.baseUrl}/api/${config.apiVersion}`,
      timeout: config.timeout || 5000
    });

    // Add request interceptor for debugging
    this.client.interceptors.request.use(request => {
      console.log(`Making request to: ${request.baseURL}${request.url}`);
      return request;
    });
  }

  async getRecommendedMeals(userId = config.defaultUserId, limit = 10) {
    try {
      console.log(`Fetching recommended meals for user: ${userId}, limit: ${limit}`);
      const response = await this.client.get(`/recommend/user/${userId}`, {
        params: { limit, recommendation_type: 'hybrid' }
      });

      return this._transformItems(response.data.items);
    } catch (error) {
      this._handleError('Failed to fetch recommended meals:', error);
      throw error;
    }
  }

  async getTrendingMeals(limit = 10, timeWindow = 'week') {
    try {
      console.log(`Fetching trending meals, limit: ${limit}, time window: ${timeWindow}`);
      const response = await this.client.get('/trending', {
        params: { limit, time_window: timeWindow }
      });

      return this._transformItems(response.data.items);
    } catch (error) {
      this._handleError('Failed to fetch trending meals:', error);
      throw error;
    }
  }

  async getSimilarMeals(recipeId, limit = 5) {
    try {
      console.log(`Fetching similar meals for recipe: ${recipeId}, limit: ${limit}`);
      const response = await this.client.get(`/recommend/similar/${recipeId}`, {
        params: { limit }
      });

      return this._transformItems(response.data.items);
    } catch (error) {
      this._handleError(`Failed to fetch similar meals for recipe ${recipeId}:`, error);
      throw error;
    }
  }

  async getMealDetails(recipeId) {
    try {
      console.log(`Fetching meal details for recipe: ${recipeId}`);
      const response = await this.client.get(`/recipes/${recipeId}`);
      return recipeTransformer.transformToMeal(response.data);
    } catch (error) {
      this._handleError(`Failed to fetch meal details for recipe ${recipeId}:`, error);
      throw error;
    }
  }

  async recordInteraction(userId, mealId, interactionType, rating = null) {
    try {
      console.log(`Recording ${interactionType} interaction for user: ${userId}, meal: ${mealId}`);
      await this.client.post('/interactions', {
        user_id: userId,
        meal_id: mealId,
        interaction_type: interactionType,
        rating
      });
      return true;
    } catch (error) {
      this._handleError(`Failed to record interaction for user ${userId} on meal ${mealId}:`, error);
      throw error;
    }
  }

  async getQuickMeals(maxTime = 30, limit = 10, cuisine = null, dietaryRestriction = null) {
    try {
      console.log(`Fetching quick meals, max time: ${maxTime}, limit: ${limit}`);
      const response = await this.client.get('/recommend/quick', {
        params: {
          max_time: maxTime,
          limit,
          cuisine,
          dietary_restriction: dietaryRestriction
        }
      });

      return this._transformItems(response.data.items);
    } catch (error) {
      this._handleError('Failed to fetch quick meals:', error);
      throw error;
    }
  }

  async getCuisineRecommendations(cuisineId, limit = 10) {
    try {
      console.log(`Fetching cuisine recommendations for ${cuisineId}, limit: ${limit}`);
      const response = await this.client.get(`/recommend/cuisine/${cuisineId}`, {
        params: { limit }
      });

      return this._transformItems(response.data.items);
    } catch (error) {
      this._handleError(`Failed to fetch cuisine recommendations for ${cuisineId}:`, error);
      throw error;
    }
  }

  async getDietaryRecommendations(dietaryRestriction, limit = 10) {
    try {
      console.log(`Fetching dietary recommendations for ${dietaryRestriction}, limit: ${limit}`);
      const response = await this.client.get(`/recommend/dietary/${dietaryRestriction}`, {
        params: { limit }
      });

      return this._transformItems(response.data.items);
    } catch (error) {
      this._handleError(`Failed to fetch dietary recommendations for ${dietaryRestriction}:`, error);
      throw error;
    }
  }

  async getFilteredRecipes(options = {}) {
    try {
      const { page = 1, limit = 20, region, subRegion, minCalories, maxCalories } = options;
      console.log(`Fetching filtered recipes with options:`, options);

      const response = await this.client.get('/recipes', {
        params: {
          page,
          limit,
          region,
          sub_region: subRegion,
          min_calories: minCalories,
          max_calories: maxCalories
        }
      });

      return response.data.map(recipe => recipeTransformer.transformToMeal(recipe));
    } catch (error) {
      this._handleError('Failed to fetch filtered recipes:', error);
      throw error;
    }
  }

  async getRecipesByCalories(min = 0, max = 1000, page = 1, limit = 20) {
    try {
      console.log(`Fetching recipes by calories, min: ${min}, max: ${max}, page: ${page}, limit: ${limit}`);
      const response = await this.client.get('/recipes/filter/calories', {
        params: { min, max, page, limit }
      });

      return response.data.map(recipe => recipeTransformer.transformToMeal(recipe));
    } catch (error) {
      this._handleError('Failed to fetch recipes by calories:', error);
      throw error;
    }
  }

  // Update the advancedSearch method in services/recipeService.js

  /**
   * Perform an advanced search with multiple filtering criteria
   * @param {Object} criteria - Search criteria
   * @returns {Promise<Array>} - Array of meals matching the criteria
   */
  async advancedSearch(criteria = {}) {
    try {
      console.log(`Performing advanced search with criteria:`, criteria);

      // Format parameters to match Python service's expected format
      const params = {
        page: criteria.page || 1,
        limit: criteria.limit || 20,
        sort_by: criteria.sortBy || 'relevance',
        sort_order: criteria.sortOrder || 'desc'
      };

      // Add text search if provided
      if (criteria.query) {
        params.query = criteria.query;
      }

      // Add cuisine/region filters (comma-separated)
      if (criteria.cuisines && criteria.cuisines.length > 0) {
        params.cuisines = Array.isArray(criteria.cuisines)
          ? criteria.cuisines.join(',')
          : criteria.cuisines;
      }

      // Add dietary restriction filters (comma-separated)
      if (criteria.dietaryRestrictions && criteria.dietaryRestrictions.length > 0) {
        params.dietary = Array.isArray(criteria.dietaryRestrictions)
          ? criteria.dietaryRestrictions.join(',')
          : criteria.dietaryRestrictions;
      }

      // Add ingredient filters
      if (criteria.includeIngredients && criteria.includeIngredients.length > 0) {
        params.include_ingredients = Array.isArray(criteria.includeIngredients)
          ? criteria.includeIngredients.join(',')
          : criteria.includeIngredients;
      }

      if (criteria.excludeIngredients && criteria.excludeIngredients.length > 0) {
        params.exclude_ingredients = Array.isArray(criteria.excludeIngredients)
          ? criteria.excludeIngredients.join(',')
          : criteria.excludeIngredients;
      }

      // Add numerical range filters
      if (criteria.minCalories !== null && criteria.minCalories !== undefined) {
        params.min_calories = criteria.minCalories;
      }

      if (criteria.maxCalories !== null && criteria.maxCalories !== undefined) {
        params.max_calories = criteria.maxCalories;
      }

      if (criteria.maxPrepTime !== null && criteria.maxPrepTime !== undefined) {
        params.max_prep_time = criteria.maxPrepTime;
      }

      if (criteria.maxCookTime !== null && criteria.maxCookTime !== undefined) {
        params.max_cook_time = criteria.maxCookTime;
      }

      if (criteria.maxTotalTime !== null && criteria.maxTotalTime !== undefined) {
        params.max_total_time = criteria.maxTotalTime;
      }

      // Log the final request params for debugging
      console.log('Sending request to Python service with params:', JSON.stringify(params));

      try {
        // Make the API request to the Python service at the correct endpoint
        const response = await this.client.get('/recipes/search', { params });

        // Add error handling to see the actual response
        console.log('Response status:', response.status);
        console.log('Response data structure:', Object.keys(response.data));

        // Transform the results
        if (response.data && response.data.results) {
          return response.data.results.map(recipe => recipeTransformer.transformToMeal(recipe));
        } else {
          console.warn('Unexpected response structure:', response.data);
          return [];
        }
      } catch (axiosError) {
        // Enhanced error logging for debugging
        if (axiosError.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          console.error(`API Error ${axiosError.response.status}:`, axiosError.response.data);

          // Log the detailed validation errors if available
          if (axiosError.response.data && axiosError.response.data.detail) {
            console.error('Validation errors:', JSON.stringify(axiosError.response.data.detail));
          }
        } else if (axiosError.request) {
          // The request was made but no response was received
          console.error('No response received:', axiosError.request);
        } else {
          // Something happened in setting up the request that triggered an Error
          console.error('Error setting up request:', axiosError.message);
        }

        // Re-throw the error after logging
        throw axiosError;
      }
    } catch (error) {
      this._handleError('Failed to perform advanced search:', error);
      throw error;
    }
  }


  /**
   * Advanced search for recipes with multiple criteria
   * @route GET /api/v1/meal/search/advanced
   * @access Public
   */
  // Update the advancedSearch method in services/recipeService.js

  /**
   * Perform an advanced search with multiple filtering criteria
   * @param {Object} criteria - Search criteria
   * @returns {Promise<Array>} - Array of meals matching the criteria
   */
  async advancedSearch(criteria = {}) {
    try {
      console.log(`Performing advanced search with criteria:`, criteria);

      // Format parameters to match Python service's expected format
      const params = {
        page: criteria.page || 1,
        limit: criteria.limit || 20,
        sort_by: criteria.sortBy || 'relevance',
        sort_order: criteria.sortOrder || 'desc'
      };

      // Add text search if provided
      if (criteria.query) {
        params.query = criteria.query;
      }

      // Add cuisine/region filters (comma-separated)
      if (criteria.cuisines && criteria.cuisines.length > 0) {
        params.cuisines = Array.isArray(criteria.cuisines)
          ? criteria.cuisines.join(',')
          : criteria.cuisines;
      }

      // Add dietary restriction filters (comma-separated)
      if (criteria.dietaryRestrictions && criteria.dietaryRestrictions.length > 0) {
        params.dietary = Array.isArray(criteria.dietaryRestrictions)
          ? criteria.dietaryRestrictions.join(',')
          : criteria.dietaryRestrictions;
      }

      // Add ingredient filters
      if (criteria.includeIngredients && criteria.includeIngredients.length > 0) {
        params.include_ingredients = Array.isArray(criteria.includeIngredients)
          ? criteria.includeIngredients.join(',')
          : criteria.includeIngredients;
      }

      if (criteria.excludeIngredients && criteria.excludeIngredients.length > 0) {
        params.exclude_ingredients = Array.isArray(criteria.excludeIngredients)
          ? criteria.excludeIngredients.join(',')
          : criteria.excludeIngredients;
      }

      // Add numerical range filters
      if (criteria.minCalories !== null && criteria.minCalories !== undefined) {
        params.min_calories = criteria.minCalories;
      }

      if (criteria.maxCalories !== null && criteria.maxCalories !== undefined) {
        params.max_calories = criteria.maxCalories;
      }

      if (criteria.maxPrepTime !== null && criteria.maxPrepTime !== undefined) {
        params.max_prep_time = criteria.maxPrepTime;
      }

      if (criteria.maxCookTime !== null && criteria.maxCookTime !== undefined) {
        params.max_cook_time = criteria.maxCookTime;
      }

      if (criteria.maxTotalTime !== null && criteria.maxTotalTime !== undefined) {
        params.max_total_time = criteria.maxTotalTime;
      }

      // Log the final request params for debugging
      console.log('Sending request to Python service with params:', JSON.stringify(params));

      try {
        // Make the API request to the Python service at the correct endpoint
        const response = await this.client.get('/recipes/search', { params });

        // Add error handling to see the actual response
        console.log('Response status:', response.status);
        console.log('Response data structure:', Object.keys(response.data));

        // Transform the results
        if (response.data && response.data.results) {
          return response.data.results.map(recipe => recipeTransformer.transformToMeal(recipe));
        } else {
          console.warn('Unexpected response structure:', response.data);
          return [];
        }
      } catch (axiosError) {
        // Enhanced error logging for debugging
        if (axiosError.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          console.error(`API Error ${axiosError.response.status}:`, axiosError.response.data);

          // Log the detailed validation errors if available
          if (axiosError.response.data && axiosError.response.data.detail) {
            console.error('Validation errors:', JSON.stringify(axiosError.response.data.detail));
          }
        } else if (axiosError.request) {
          // The request was made but no response was received
          console.error('No response received:', axiosError.request);
        } else {
          // Something happened in setting up the request that triggered an Error
          console.error('Error setting up request:', axiosError.message);
        }

        // Re-throw the error after logging
        throw axiosError;
      }
    } catch (error) {
      this._handleError('Failed to perform advanced search:', error);
      throw error;
    }
  }


  /**
   * Perform an advanced search with multiple filtering criteria
   * @param {Object} criteria - Search criteria
   * @returns {Promise<Array>} - Array of meals matching the criteria
   */
  async advancedSearch(criteria = {}) {
    try {
      console.log(`Performing advanced search with criteria:`, criteria);

      // Format parameters to match Python service's expected format
      const params = {
        page: criteria.page || 1,
        limit: criteria.limit || 20,
        sort_by: criteria.sortBy || 'relevance',
        sort_order: criteria.sortOrder || 'desc'
      };

      // Add text search if provided
      if (criteria.query) {
        params.query = criteria.query;
      }

      // Add cuisine/region filters (comma-separated)
      if (criteria.cuisines && criteria.cuisines.length > 0) {
        params.cuisines = Array.isArray(criteria.cuisines)
          ? criteria.cuisines.join(',')
          : criteria.cuisines;
      }

      // Add dietary restriction filters (comma-separated)
      if (criteria.dietaryRestrictions && criteria.dietaryRestrictions.length > 0) {
        params.dietary = Array.isArray(criteria.dietaryRestrictions)
          ? criteria.dietaryRestrictions.join(',')
          : criteria.dietaryRestrictions;
      }

      // Add ingredient filters
      if (criteria.includeIngredients && criteria.includeIngredients.length > 0) {
        params.include_ingredients = Array.isArray(criteria.includeIngredients)
          ? criteria.includeIngredients.join(',')
          : criteria.includeIngredients;
      }

      if (criteria.excludeIngredients && criteria.excludeIngredients.length > 0) {
        params.exclude_ingredients = Array.isArray(criteria.excludeIngredients)
          ? criteria.excludeIngredients.join(',')
          : criteria.excludeIngredients;
      }

      // Add numerical range filters
      if (criteria.minCalories !== null && criteria.minCalories !== undefined) {
        params.min_calories = criteria.minCalories;
      }

      if (criteria.maxCalories !== null && criteria.maxCalories !== undefined) {
        params.max_calories = criteria.maxCalories;
      }

      if (criteria.maxPrepTime !== null && criteria.maxPrepTime !== undefined) {
        params.max_prep_time = criteria.maxPrepTime;
      }

      if (criteria.maxCookTime !== null && criteria.maxCookTime !== undefined) {
        params.max_cook_time = criteria.maxCookTime;
      }

      if (criteria.maxTotalTime !== null && criteria.maxTotalTime !== undefined) {
        params.max_total_time = criteria.maxTotalTime;
      }

      // Log the final request params for debugging
      console.log('Sending request to Python service with params:', JSON.stringify(params));

      try {
        // Make the API request to the Python service at the correct endpoint
        const response = await this.client.get('/recipes/search', { params });

        // Add error handling to see the actual response
        console.log('Response status:', response.status);
        console.log('Response data structure:', Object.keys(response.data));

        // Transform the results
        if (response.data && response.data.results) {
          return response.data.results.map(recipe => recipeTransformer.transformToMeal(recipe));
        } else {
          console.warn('Unexpected response structure:', response.data);
          return [];
        }
      } catch (axiosError) {
        // Enhanced error logging for debugging
        if (axiosError.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          console.error(`API Error ${axiosError.response.status}:`, axiosError.response.data);

          // Log the detailed validation errors if available
          if (axiosError.response.data && axiosError.response.data.detail) {
            console.error('Validation errors:', JSON.stringify(axiosError.response.data.detail));
          }
        } else if (axiosError.request) {
          // The request was made but no response was received
          console.error('No response received:', axiosError.request);
        } else {
          // Something happened in setting up the request that triggered an Error
          console.error('Error setting up request:', axiosError.message);
        }

        // Re-throw the error after logging
        throw axiosError;
      }
    } catch (error) {
      this._handleError('Failed to perform advanced search:', error);
      throw error;
    }
  }


  // Helper method to transform items with better error handling
  async _transformItems(items) {
    try {
      if (!items || !Array.isArray(items)) {
        console.warn('No items to transform or items is not an array');
        return [];
      }

      const transformedItems = [];
      for (const item of items) {
        try {
          const mealDetails = await this.getMealDetails(item.id);
          transformedItems.push(mealDetails);
        } catch (error) {
          console.error(`Error transforming item ${item.id}:`, error);
          // Continue with other items
        }
      }

      return transformedItems;
    } catch (error) {
      console.error('Error in _transformItems:', error);
      return [];
    }
  }

  // Helper method for consistent error handling
  _handleError(message, error) {
    console.error(message, error);

    // Handle specific axios errors
    if (error.isAxiosError) {
      if (error.code === 'ECONNREFUSED') {
        console.error(`Connection refused: Please ensure the Python service is running at ${config.baseUrl}`);
      } else if (error.code === 'ERR_INVALID_URL') {
        console.error(`Invalid URL: Please check your PYTHON_SERVICE_URL and PYTHON_API_VERSION in .env file`);
        console.error(`Current configuration: baseUrl=${config.baseUrl}, apiVersion=${config.apiVersion}`);
      } else if (error.response) {
        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        console.error(`API Error ${error.response.status}: ${error.response.data?.detail || 'Unknown error'}`);
      } else if (error.request) {
        // The request was made but no response was received
        console.error('No response received from the server');
      }
    }
  }
}

module.exports = new RecipeService();
////////////////////////////////////////////////////////////////////////////////

├── test-upload.js

////////////////////////////////////////////////////////////////////////////////
const express = require('express');
const multer = require('multer');
const app = express();

// Set up storage
const storage = multer.memoryStorage();
const upload = multer({ storage }).any();

app.post('/test-upload', (req, res) => {
  console.log('Received request');
  console.log('Content-Type:', req.get('Content-Type'));
  
  upload(req, res, function(err) {
    if (err) {
      console.error('Upload error:', err);
      return res.status(400).json({ error: err.message });
    }
    
    console.log('Files:', req.files);
    console.log('Body:', req.body);
    
    if (!req.files || req.files.length === 0) {
      return res.status(200).json({ 
        message: 'No files uploaded',
        body: req.body,
        contentType: req.get('Content-Type')
      });
    }
    
    const fileInfo = req.files.map(file => ({
      fieldname: file.fieldname,
      originalname: file.originalname,
      mimetype: file.mimetype,
      size: file.size
    }));
    
    res.json({ 
      message: 'Upload successful',
      files: fileInfo,
      body: req.body
    });
  });
});

const PORT = 3500;
app.listen(PORT, () => {
  console.log(`Test server running at http://localhost:${PORT}`);
  console.log('Send a POST request to http://localhost:${PORT}/test-upload to test file uploads');
}); 
////////////////////////////////////////////////////////////////////////////////

├── tests
│   ├── auth
│   │   └── resendVerification.test.js

////////////////////////////////////////////////////////////////////////////////
const request = require("supertest");
const app = require("../../app.js"); // Adjust path if needed
const prisma = require("../../config/prismaClient.js");
const { BadRequestError } = require("../../errors/badRequestError.js");
const { generateOTP, hashOTP } = require("../../utils/otpUtlis.js");
const { sendVerificationEmail } = require("../../utils/emailUtlis.js");

// Mock dependencies
jest.mock("../../config/prismaClient", () => ({
  user: { findUnique: jest.fn() },
  verificationCode: { findFirst: jest.fn() },
  $transaction: jest.fn(),
}));

jest.mock("../../utils/otpUtlis.js", () => ({
  generateOTP: jest.fn(() => "123456"),
  hashOTP: jest.fn(() => "hashedOTP"),
}));

jest.mock("../../utils/emailUtlis.js", () => ({
  sendVerificationEmail: jest.fn(() => Promise.resolve()),
}));

describe("POST /auth/resend-verification", () => {
  afterEach(() => {
    jest.clearAllMocks();
  });

  it("should return 400 if user is not found", async () => {
    prisma.user.findUnique.mockResolvedValue(null);

    const res = await request(app)
      .post("/auth/resend-verification")
      .send({ email: "nonexistent@example.com" });

    expect(res.status).toBe(400);
    expect(res.body.message).toBe("User not found");
  });

  it("should return 400 if user is already verified", async () => {
    prisma.user.findUnique.mockResolvedValue({ id: "123", isVerified: true });

    const res = await request(app)
      .post("/auth/resend-verification")
      .send({ email: "verified@example.com" });

    expect(res.status).toBe(400);
    expect(res.body.message).toBe(
      "User is already verified, Please go to login page"
    );
  });

  it("should enforce rate limiting (1-minute cooldown)", async () => {
    prisma.user.findUnique.mockResolvedValue({ id: "123", isVerified: false });
    prisma.verificationCode.findFirst.mockResolvedValue({
      createdAt: new Date(Date.now() - 30 * 1000), // OTP created 30 sec ago
    });

    const res = await request(app)
      .post("/auth/resend-verification")
      .send({ email: "user@example.com" });

    expect(res.status).toBe(400);
    expect(res.body.message).toBe("Please wait before requesting another OTP.");
  });

  it("should generate and send a new OTP if conditions are met", async () => {
    prisma.user.findUnique.mockResolvedValue({ id: "123", isVerified: false });
    prisma.verificationCode.findFirst.mockResolvedValue({
      createdAt: new Date(Date.now() - 2 * 60 * 1000), // OTP created 2 mins ago
    });
    prisma.$transaction.mockResolvedValue();

    const res = await request(app)
      .post("/auth/resend-verification")
      .send({ email: "user@example.com" });

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.message).toBe(
      "A new verification code has been sent to your email."
    );
    expect(generateOTP).toHaveBeenCalled();
    expect(hashOTP).toHaveBeenCalledWith("123456");
    expect(sendVerificationEmail).toHaveBeenCalledWith(
      "user@example.com",
      "123456"
    );
  });
});

////////////////////////////////////////////////////////////////////////////////

│   └── authValidation.test.js

////////////////////////////////////////////////////////////////////////////////
const request = require("supertest");
const app = require("../app"); // Import your Express app

describe("User Registration Validation", () => {
  const endpoint = "/api/v1/users/register"; // Your registration route

  test("Should fail when required fields are missing", async () => {
    const response = await request(app).post(endpoint).send({});

    expect(response.status).toBe(400);
    expect(response.body).toHaveProperty("errors");
    expect(response.body.errors).toContain('"email" is required');
    expect(response.body.errors).toContain('"password" is required');
  });

  test("Should fail if email format is invalid", async () => {
    const response = await request(app)
      .post(endpoint)
      .send({ username: "amr", email: "invalid-email", password: "123456" });

    expect(response.status).toBe(400);
    expect(response.body.errors).toContain('"email" must be a valid email');
  });

  test("Should fail if password is too short", async () => {
    const response = await request(app)
      .post(endpoint)
      .send({ username: "amr", email: "test@mail.com", password: "123" });

    expect(response.status).toBe(400);
    expect(response.body.errors).toContain(
      '"password" length must be at least 6 characters long'
    );
  });

  test("Should pass with valid input", async () => {
    const response = await request(app)
      .post(endpoint)
      .send({ username: "amr", email: "test@mail.com", password: "secure123" });

    expect(response.status).toBe(201);
    expect(response.body.success).toBe(true);
    expect(response.body).toHaveProperty("user");
  });
});

////////////////////////////////////////////////////////////////////////////////

├── transformers
│   └── recipeTransformer.js

////////////////////////////////////////////////////////////////////////////////
class RecipeTransformer {
    transformToMeal(recipe) {
      // Map Python service recipe format to required meal object structure
      return {
        meal_id: recipe.recipe_id.toString(),
        name: recipe.recipe_title,
        description: recipe.description || `A delicious ${recipe.region || ''} dish.`,
        image_url: recipe.image_url || `https://mealflow.ddns.net/images/meals/${recipe.recipe_id}.jpg`,
        tags: this._generateTags(recipe),
        ingredients: this._formatIngredients(recipe.ingredients || []),
        instructions: this._formatInstructions(recipe.instructions),
        cookware: this._extractCookware(recipe.instructions),
        preparation_time: recipe.prep_time || 15,
        cooking_time: recipe.cook_time || 20,
        servings: recipe.servings || 2,
        calories_per_serving: recipe.calories || 350,
        rating: this._calculateRating(recipe),
        reviews_count: Math.floor(Math.random() * 200) + 10, // Placeholder
        created_by: this._getCreator(recipe),
        is_favorited: false,
        is_saved: false,
        notes: [],
        interactions: {
          views: Math.floor(Math.random() * 1000) + 100,
          likes: Math.floor(Math.random() * 400) + 50,
          dislikes: Math.floor(Math.random() * 20),
          shares: Math.floor(Math.random() * 50) + 5
        },
        created_at: recipe.created_at || new Date().toISOString(),
        updated_at: recipe.updated_at || new Date().toISOString()
      };
    }
  
    _generateTags(recipe) {
      const tags = [];
      if (recipe.region) tags.push(recipe.region.toLowerCase());
      if (recipe.sub_region) tags.push(recipe.sub_region.toLowerCase());
      
      // Add dietary tags if available
      if (recipe.diet_attributes) {
        if (recipe.diet_attributes.vegan) tags.push('vegan');
        if (recipe.diet_attributes.vegetarian) tags.push('vegetarian');
      }
      
      // Add time-based tags
      if (recipe.total_time && recipe.total_time <= 30) tags.push('quick');
      
      return tags;
    }
  
    _formatIngredients(ingredients) {
      if (!ingredients.length) return [];
      
      return ingredients.map(ingredient => ({
        name: ingredient.ingredient_name,
        quantity: ingredient.quantity || 1,
        unit: ingredient.unit || 'pcs'
      }));
    }
  
    _formatInstructions(instructions) {
      if (!instructions) return ["No instructions available."];
      
      if (typeof instructions === 'string') {
        return instructions.split(/\.\s+|[\r\n]+/).filter(step => step.trim().length > 0);
      }
      
      return instructions;
    }
  
    _extractCookware(instructions) {
      const cookwareKeywords = ['pan', 'pot', 'bowl', 'knife', 'oven', 'spoon', 'cutting board', 'blender'];
      const cookware = new Set();
      
      if (typeof instructions === 'string') {
        cookwareKeywords.forEach(item => {
          if (instructions.toLowerCase().includes(item)) {
            cookware.add(item);
          }
        });
      }
      
      return Array.from(cookware);
    }
  
    _calculateRating(recipe) {
      return recipe.rating || (Math.random() * 2 + 3).toFixed(1); // Random rating between 3.0-5.0
    }
  
    _getCreator(recipe) {
      return {
        user_id: recipe.owner_id || "user_system",
        username: recipe.owner_name || "MealFlow",
        profile_picture: "https://mealflow.ddns.net/images/users/default.jpg"
      };
    }
  }
  
  module.exports = new RecipeTransformer();
////////////////////////////////////////////////////////////////////////////////

├── uploads
├── utils
│   ├── addCategories.js

////////////////////////////////////////////////////////////////////////////////
const { PrismaClient } = require("@prisma/client");

const prisma = new PrismaClient();

const categoriesData = [
  {
    name: "Cuisine Types",
    children: [
      "Italian Cuisine",
      "French Cuisine",
      "Mexican Cuisine",
      "Middle Eastern Cuisine",
      "Asian Cuisine",
      "American Cuisine",
      "Mediterranean Cuisine",
      "Indian Cuisine",
      "African Cuisine"
    ]
  },
  {
    name: "Dietary Preferences",
    children: [
      "Vegan & Plant-Based",
      "Vegetarian",
      "Keto & Low-Carb",
      "Paleo",
      "Gluten-Free",
      "Dairy-Free",
      "High-Protein",
      "Halal & Kosher"
    ]
  },
  {
    name: "Meal Types",
    children: [
      "Breakfast & Brunch",
      "Lunch & Quick Meals",
      "Dinner & Main Courses",
      "Snacks & Appetizers",
      "Desserts & Sweets"
    ]
  },
  {
    name: "Cooking Styles & Techniques",
    children: [
      "Home Cooking",
      "Baking & Pastry",
      "Grilling & BBQ",
      "Slow Cooking & Crockpot",
      "Air Fryer Recipes",
      "One-Pot & Instant Pot Meals",
      "Fermentation & Pickling"
    ]
  },
  {
    name: "Special Occasions & Seasonal Meals",
    children: [
      "Holiday & Festive Meals",
      "Ramadan & Iftar",
      "Summer Refreshing Meals",
      "Winter Comfort Foods",
      "Birthday & Celebration Cakes"
    ]
  },
  {
    name: "Health & Wellness",
    children: [
      "Weight Loss Recipes",
      "Muscle Gain & Fitness Meals",
      "Diabetic-Friendly Meals",
      "Heart-Healthy Recipes"
    ]
  },
  {
    name: "Budget & Time-Friendly Meals",
    children: [
      "5-Ingredient Recipes",
      "30-Minute Meals",
      "Cheap & Budget-Friendly Meals",
      "Meal Prepping & Batch Cooking"
    ]
  },
  {
    name: "Cultural & Regional Foods",
    children: [
      "Street Food",
      "Traditional & Ancestral Recipes",
      "Fusion Recipes"
    ]
  },
  {
    name: "Drinks & Beverages",
    children: [
      "Coffee & Tea Lovers",
      "Smoothies & Juices",
      "Cocktails & Mocktails",
      "Homemade Brews & Fermented Drinks",
      "Detox & Wellness Drinks"
    ]
  },
  {
    name: "Kids & Family Meals",
    children: [
      "Kid-Friendly Recipes",
      "School Lunch Ideas",
      "Family Dinners",
      "Fun & Creative Snacks",
      "Baby Food & Toddler Meals"
    ]
  },
  {
    name: "Sustainability & Zero Waste",
    children: [
      "Zero-Waste Cooking",
      "Seasonal & Local Produce",
      "Nose-to-Tail Cooking",
      "Root-to-Stem Recipes",
      "Sustainable Seafood"
    ]
  },
  {
    name: "Global Street Food",
    children: [
      "Asian Street Food",
      "Latin American Street Food",
      "European Street Food",
      "African Street Food",
      "Middle Eastern Street Food"
    ]
  },
  {
    name: "Food Allergies & Intolerances",
    children: [
      "Nut-Free Recipes",
      "Egg-Free Recipes",
      "Soy-Free Recipes",
      "Shellfish-Free Recipes",
      "Low-FODMAP Recipes"
    ]
  },
  {
    name: "Cooking for One or Two",
    children: [
      "Single-Serving Recipes",
      "Date Night Meals",
      "Small-Batch Baking",
      "Minimalist Cooking"
    ]
  },
  {
    name: "Food Science & Experimentation",
    children: [
      "Molecular Gastronomy",
      "Sous Vide Cooking",
      "Food Pairing & Flavor Science",
      "DIY Kitchen Experiments"
    ]
  },
  {
    name: "Food Challenges & Trends",
    children: [
      "Viral Food Trends",
      "Spicy Food Challenges",
      "Retro & Nostalgic Recipes",
      "Food Art & Aesthetics",
      "Extreme Food Challenges"
    ]
  },
  {
    name: "Food History & Culture",
    children: [
      "Ancient Recipes",
      "Historical Dishes",
      "Indigenous Cuisine",
      "Culinary Traditions",
      "Food Anthropology"
    ]
  },
  {
    name: "Food Photography & Styling",
    children: [
      "Food Styling Tips",
      "Flat Lay Photography",
      "Recipe Video Creation",
      "Food Blogging & Content Creation"
    ]
  },
  {
    name: "Food Pairing & Wine",
    children: [
      "Wine & Cheese Pairings",
      "Beer & Food Pairings",
      "Non-Alcoholic Pairings",
      "Dessert & Drink Combos"
    ]
  },
  {
    name: "Food Hacks & Tips",
    children: [
      "Kitchen Hacks",
      "Ingredient Substitutions",
      "Time-Saving Tips",
      "Leftover Makeovers",
      "Meal Planning Strategies"
    ]
  },
  {
    name: "Food Travel & Exploration",
    children: [
      "Foodie Travel Guides",
      "Regional Food Adventures",
      "Food Tours & Experiences",
      "International Grocery Hauls"
    ]
  },
  {
    name: "Food for Mental Health",
    children: [
      "Mood-Boosting Recipes",
      "Stress-Relief Foods",
      "Brain-Boosting Meals",
      "Comfort Foods for Tough Days"
    ]
  },
  {
    name: "Food for Athletes",
    children: [
      "Pre-Workout Meals",
      "Post-Workout Recovery",
      "Endurance Fueling",
      "Hydration & Electrolytes"
    ]
  },
  {
    name: "Food for Pets",
    children: [
      "Homemade Dog Treats",
      "Cat-Friendly Recipes",
      "Healthy Pet Meals",
      "DIY Pet Food"
    ]
  },
  {
    name: "Food for Special Diets",
    children: [
      "Low-Sodium Recipes",
      "Low-Sugar Recipes",
      "Anti-Inflammatory Meals",
      "Autoimmune Protocol (AIP)"
    ]
  }
];

async function seedCategories() {
  try {
    console.log('Starting category seeding...');

    // Clear existing data (optional)
    await prisma.communityCategory.deleteMany();
    await prisma.category.deleteMany();

    // Create parent categories and their children
    for (const parentCategory of categoriesData) {
      // Create parent category
      const parent = await prisma.category.create({
        data: {
          name: parentCategory.name,
          parentId: null,
        },
      });

      // Prepare children data
      const childrenData = parentCategory.children.map(childName => ({
        name: childName,
        parentId: parent.id,
      }));

      // Batch create children
      await prisma.category.createMany({
        data: childrenData,
      });

      console.log(`Created ${parentCategory.name} with ${childrenData.length} subcategories`);
    }

    console.log('Successfully seeded all categories!');
  } catch (error) {
    console.error('Error seeding categories:', error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

seedCategories();
////////////////////////////////////////////////////////////////////////////////

│   ├── emailUtlis.js

////////////////////////////////////////////////////////////////////////////////
const nodemailer = require("nodemailer");
require("dotenv").config();

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST, // smtp-relay.brevo.com
  port: Number(process.env.SMTP_PORT), // 587
  secure: false, // Must be false for port 587 (STARTTLS)
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
  // tls: {
  //   rejectUnauthorized: false, // Bypass self-signed certificate issues
  // },
});

const sendVerificationEmail = async (email, otp) => {
  const mailOptions = {
    from: '"MealFlow Support" <bojack25333@gmail.com>',
    to: email,
    subject: "Verify Your Email - MealFlow",
    html: `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Email Verification</title>
        <style>
          body { font-family: sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4; }
          .container { max-width: 600px; margin: 0 auto; background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
          h2 { color: #333; }
          p { color: #555; }
          .otp { background-color: #e0f7fa; padding: 10px 20px; border-radius: 5px; font-size: 1.2em; font-weight: bold; color: #1565c0; text-align: center; margin: 20px 0; }
          .expiry { font-size: 0.9em; color: #777; }
          .footer { margin-top: 30px; text-align: center; color: #999; }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>Email Verification</h2>
          <p>Dear User,</p>
          <p>Thank you for registering. Please use the following One-Time Password (OTP) to verify your email address:</p>
          <div class="otp">${otp}</div>
          <p class="expiry">This OTP will expire in 15 minutes.</p>
          <p>If you did not request this verification, please ignore this email.</p>
          <div class="footer">
            <p>This is an automatically generated email. Please do not reply to this message.</p>
          </div>
        </div>
      </body>
      </html>
    `,
  };

  await transporter.sendMail(mailOptions);
};

// Function to send password reset email
const sendPasswordResetEmail = async (email, resetLinkWeb, resetLinkApp) => {
  const mailOptions = {
    from: '"MealFlow Support" <bojack25333@gmail.com>',
    to: email,
    subject: "Reset Your Password - MealFlow",
    html: `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Password Reset</title>
        <style>
          body { font-family: sans-serif; line-height: 1.6; margin: 0; padding: 20px; background-color: #f4f4f4; }
          .container { max-width: 600px; margin: 0 auto; background-color: #ffffff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); text-align: center; }
          h2 { color: #333; }
          p { color: #555; }
          .btn {
            display: inline-block;
            background-color: #007bff;
            color: white;
            padding: 12px 20px;
            border-radius: 5px;
            text-decoration: none;
            font-size: 1.2em;
            margin-top: 20px;
          }
          .footer { margin-top: 30px; text-align: center; color: #999; font-size: 0.9em; }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>Password Reset</h2>
          <p>We received a request to reset your password. Click the button below to proceed.</p>
          <a href="${resetLinkApp}" class="btn">Reset Password</a>
          <p>If the button does not work, <a href="${resetLinkWeb}">click here</a>.</p>
          <p>If you did not request a password reset, please ignore this email.</p>
          <div class="footer">
            <p>This is an automatically generated email. Please do not reply.</p>
          </div>
        </div>
      </body>
      </html>
    `,
  };

  await transporter.sendMail(mailOptions);
};

module.exports = { sendVerificationEmail, sendPasswordResetEmail };

////////////////////////////////////////////////////////////////////////////////

│   ├── otpUtlis.js

////////////////////////////////////////////////////////////////////////////////
const crypto = require("crypto");
const bcrypt = require("bcrypt");
const BadrequestError = require("../errors/BadRequestError");
const prisma = require("../config/prismaClient");

const generateOTP = () => {
  return crypto.randomInt(100000, 999999).toString();
};

const hashOTP = async (otp) => {
  return await bcrypt.hash(otp, 10);
};

const verifyHashedOTP = async (otp, hashedOTP) => {
  return await bcrypt.compare(otp, hashedOTP);
};

const deleteOldOTPs = async (email) => {
  const user = await prisma.user.findUnique({
    where: { email: email.toLowerCase() },
  });
  if (!user) throw new BadrequestError("User not found");

  await prisma.verificationCode.deleteMany({ where: { userId: user.id } });

  return { success: true, message: "Old OTPs deleted successfully" };
};

module.exports = {
  generateOTP,
  hashOTP,
  verifyHashedOTP,
  deleteOldOTPs,
};

////////////////////////////////////////////////////////////////////////////////

│   ├── passwordUtils.js

////////////////////////////////////////////////////////////////////////////////
const bcrypt = require("bcrypt");

const passwordUtils = {
    hash: async (password) => {
        const SALT_ROUNDS = await bcrypt.genSalt(
            Number(process.env.COST_FACTOR)
        );
        return bcrypt.hash(password, SALT_ROUNDS);
    },
    compare: async (password, hash) => {
        return bcrypt.compare(password, hash);
    },
};

module.exports = passwordUtils;

////////////////////////////////////////////////////////////////////////////////

│   ├── tokenUtils.js

////////////////////////////////////////////////////////////////////////////////
const jwt = require("jsonwebtoken");

class TokenUtils {
  constructor(
    secret,
    accessTokenLifetime,
    refreshTokenLifetime,
    passwordResetTokenLifetime
  ) {
    if (!secret) {
      throw new Error("JWT_SECRET is required but not set");
    }
    this.secret = secret;
    this.accessTokenLifetime = accessTokenLifetime; // Default to 15 minutes
    this.refreshTokenLifetime = refreshTokenLifetime || "1y"; // Default to 1 year
    this.passwordResetTokenLifetime = passwordResetTokenLifetime || "1h"; // Default to 1 hour
  }

  // Generate access token
  signAccessToken(payload) {
    return jwt.sign(payload, this.secret, {
      expiresIn: this.accessTokenLifetime,
      algorithm: "HS256",
    });
  }

  // Generate refresh token
  signRefreshToken(payload) {
    return jwt.sign(payload, this.secret, {
      expiresIn: this.refreshTokenLifetime,
      algorithm: "HS256",
    });
  }

  // Generate password reset token
  signPasswordResetToken(payload) {
    return jwt.sign(payload, this.secret, {
      expiresIn: this.passwordResetTokenLifetime,
      algorithm: "HS256",
    });
  }

  // Verify token
  verify(token) {
    try {
      return jwt.verify(token, this.secret);
    } catch (error) {
      console.error("JWT verification failed:", error.message);
      return null; // Return null instead of throwing an error
    }
  }
}

// Singleton instance
const tokenUtils = new TokenUtils(
  process.env.JWT_SECRET,
  process.env.JWT_ACCESS_TOKEN_LIFETIME,
  process.env.JWT_REFRESH_TOKEN_LIFETIME,
  process.env.JWT_PASSWORD_RESET_TOKEN_LIFETIME
);

module.exports = tokenUtils;

////////////////////////////////////////////////////////////////////////////////

│   ├── uploadImage.js

////////////////////////////////////////////////////////////////////////////////
const multer = require("multer");
const path = require("path");

// Configure storage settings
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/"); // Folder where images will be stored
  },
  filename: function (req, file, cb) {
    cb(
      null,
      file.fieldname + "-" + Date.now() + path.extname(file.originalname)
    );
  },
});

// File filter to allow only images
const fileFilter = (req, file, cb) => {
  const allowedFileTypes = /jpeg|jpg|png|gif/;
  const extname = allowedFileTypes.test(
    path.extname(file.originalname).toLowerCase()
  );
  const mimetype = allowedFileTypes.test(file.mimetype);

  if (extname && mimetype) {
    return cb(null, true);
  } else {
    return cb(new Error("Only images are allowed!"));
  }
};

// Initialize multer with storage and file filtering
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // Limit file size to 5MB
});

// Controller function to handle file upload
const uploadImage = (req, res) => {
  if (!req.file) {
    return res.status(400).json({ message: "No file uploaded!" });
  }
  res.json({ message: "File uploaded successfully!", file: req.file });
};

module.exports = { upload, uploadImage };

////////////////////////////////////////////////////////////////////////////////

│   └── uploads.js

////////////////////////////////////////////////////////////////////////////////
// utils/uploads.js
const multer = require("multer");
const path = require("path");

// Configure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, "uploads/"); // Store files in 'uploads' folder
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(
      null,
      file.fieldname + "-" + uniqueSuffix + path.extname(file.originalname)
    );
  },
});

// File filter (Optional: restrict file types)
const fileFilter = (req, file, cb) => {
  if (file.mimetype.startsWith("image/")) {
    cb(null, true);
  } else {
    cb(new Error("Only image files are allowed"), false);
  }
};

// Initialize Multer
const upload = multer({ storage, fileFilter });

module.exports = upload;

////////////////////////////////////////////////////////////////////////////////

└── validators
    ├── authValidator.js

////////////////////////////////////////////////////////////////////////////////
const Joi = require("joi");

const emailSchema = Joi.string()
  .trim()
  .lowercase()
  .pattern(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)
  .required()
  .messages({
    "string.pattern.base": "Please provide a valid email address.",
    "string.empty": "Email is required.",
  });

const passwordSchema = Joi.string()
  .trim()
  .min(8)
  .max(64)
  .pattern(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*])/)
  .required()
  .messages({
    "string.min": "Password must be at least 8 characters long.",
    "string.max": "Password cannot be longer than 64 characters.",
    "string.pattern.base":
      "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character (!@#$%^&*).",
    "string.empty": "Password is required.",
  });

const usernameSchema = Joi.string()
  .trim()
  .lowercase()
  .pattern(/^[a-zA-Z][a-zA-Z0-9_]{2,29}$/)
  .required()
  .messages({
    "string.pattern.base":
      "Username must start with a letter and can only contain letters, numbers, and underscores.",
    "string.empty": "Username is required.",
  });

const registerSchema = Joi.object({
  username: usernameSchema,
  email: emailSchema,
  password: passwordSchema,
});

const loginSchema = Joi.object({
  email: emailSchema,
  password: Joi.string().trim().required().messages({
    "string.empty": "Password is required.",
  }),
});

const otpSchema = Joi.object({
  email: emailSchema,
  otp: Joi.string()
    .length(6)
    .pattern(/^\d{6}$/)
    .required()
    .messages({
      "string.empty": "OTP is required",
      "string.pattern.base": "Invalid OTP",
    }),
});

const resendVerificationSchema = Joi.object({
  email: emailSchema,
});

const forgotPasswordSchema = Joi.object({
  email: emailSchema,
});

const resetPasswordSchema = Joi.object({
  password: passwordSchema,
  token: Joi.string().required().messages({
    "string.empty": "Refresh token is required.",
  }),
});

const refreshTokenSchema = Joi.object({
  refreshToken: Joi.string().required().messages({
    "string.empty": "Refresh token is required.",
  }),
});

module.exports = {
  registerSchema,
  loginSchema,
  otpSchema,
  resendVerificationSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
  refreshTokenSchema,
};

////////////////////////////////////////////////////////////////////////////////

    └── communityValidator.js

////////////////////////////////////////////////////////////////////////////////
const Joi = require("joi");

const recipeCreationPermissionEnum = ["ANY_MEMBER", "ADMINS_ONLY"];
const privacyEnum = ["PUBLIC", "PRIVATE", "RESTRICTED"];

const createCommunitySchema = Joi.object({
  name: Joi.string().min(3).max(50).required(),
  description: Joi.string().max(500).optional(),
  image: Joi.string().allow(null, "").optional(), // Allow null or empty string for optional images
  recipeCreationPermission: Joi.string()
    .valid(...recipeCreationPermissionEnum)
    .default("ANY_MEMBER"),
  privacy: Joi.string()
    .valid(...privacyEnum)
    .default("PUBLIC"),

  // Allow categories to be an array or a string (which will be parsed)
  categories: Joi.alternatives()
    .try(Joi.array().items(Joi.string()), Joi.string())
    .optional(),
}).unknown(true); // Allow unknown fields to support file upload fields

const getAllMembersSchema = Joi.object({
  id: Joi.string().required(),
});

const leaveCommunitySchema = Joi.object({
  id: Joi.string().required(),
});

module.exports = {
  createCommunitySchema,
  getAllMembersSchema,
  leaveCommunitySchema,
};

////////////////////////////////////////////////////////////////////////////////

