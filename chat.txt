Directory Tree: ./
================================================================================

├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

├── api
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////
"""
Recommendation Service API Package.
"""
# This file enables the directory to be imported as a package
////////////////////////////////////////////////////////////////////////////////

│   ├── endpoints.py

////////////////////////////////////////////////////////////////////////////////
"""
Meal Recommendation Service API endpoints.
All API routes are defined here in a modular, organized manner.
"""
from fastapi import APIRouter, Depends, Query, HTTPException, status, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import time

from config import CONTENT_TYPES, DEFAULT_RECOMMENDATION_LIMIT, ALLOWED_TRENDING_WINDOWS
from data.database import get_db
from services.hybrid import HybridRecommender
from services.item_based import ItemBasedRecommender
from services.collaborative import CollaborativeRecommender
from services.content_based import ContentBasedRecommender
from services.popularity import PopularityRecommender

# Request & Response Models
class InteractionCreate(BaseModel):
    """Request model for creating a meal interaction record."""
    user_id: str
    meal_id: str
    content_type: str
    interaction_type: str

class RecommendationItem(BaseModel):
    """Model for a recommendation item in responses."""
    id: str
    content_type: str
    title: str
    score: Optional[float] = None
    
class RecommendationResponse(BaseModel):
    """Standard response model for recommendation endpoints."""
    items: List[RecommendationItem]
    count: int
    execution_time_ms: float

# API Routers
router = APIRouter()

# Utility functions
def validate_content_type(content_type: str, allow_all: bool = False) -> str:
    """Validate the content type parameter."""
    valid_types = CONTENT_TYPES.copy()
    if allow_all:
        valid_types.append('all')
        
    if content_type not in valid_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Content type must be one of: {', '.join(valid_types)}"
        )
    
    return content_type

# Request timing middleware
@router.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    
    # If it's a JSON response, we add the execution time to the response
    if isinstance(response, JSONResponse):
        content = response.body.decode()
        import json
        try:
            data = json.loads(content)
            if isinstance(data, dict):
                data["execution_time_ms"] = round(process_time * 1000, 2)
                response.body = json.dumps(data).encode()
        except:
            pass
    
    return response

# Endpoints
@router.get("/", tags=["status"])
def read_root():
    """Root endpoint for API status check."""
    return {"status": "Meal recommendation service is running"}

@router.get("/recommend/user/{user_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_user_recommendations(
    user_id: str,
    content_type: Optional[str] = Query(None, description="Filter by content type (meal, recipe)"),
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of recommendations"),
    recommendation_type: str = Query("hybrid", description="Recommendation algorithm to use (hybrid, item-based, user-based)"),
    cuisine: Optional[str] = Query(None, description="Filter by cuisine type"),
    dietary_restriction: Optional[str] = Query(None, description="Filter by dietary restriction"),
    db = Depends(get_db)
):
    """
    Get personalized meal recommendations for a user.
    
    Uses a hybrid approach with multiple recommendation strategies:
    1. Collaborative filtering based on similar users
    2. Content-based recommendations using recent interactions
    3. Popularity-based recommendations as fallback
    
    Parameters:
    - user_id: The ID of the user
    - content_type: Optional filter by content type ('meal', 'recipe')
    - limit: Maximum number of recommendations to return
    - recommendation_type: Algorithm to use (hybrid, item-based, user-based)
    - cuisine: Optional filter by cuisine type
    - dietary_restriction: Optional filter by dietary restriction
    
    Returns:
    - List of recommended meals
    """
    start_time = time.time()
    
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    # Choose the recommendation strategy based on the type parameter
    if recommendation_type == "hybrid":
        recommender = HybridRecommender()
    elif recommendation_type == "item-based":
        recommender = ItemBasedRecommender()
    elif recommendation_type == "user-based":
        recommender = CollaborativeRecommender()
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid recommendation type. Must be 'hybrid', 'item-based', or 'user-based'."
        )
    
    # Get recommendations
    recommended_items = recommender.get_recommendations(
        user_id=user_id,
        content_type=content_type,
        limit=limit,
        cuisine=cuisine,
        dietary_restriction=dietary_restriction
    )
    
    # Format response
    items = []
    for item in recommended_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item["content_type"],
            title=item.get("title", ""),
            score=item.get("score")
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/recommend/similar/{content_type}/{meal_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_similar_meals(
    content_type: str,
    meal_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of similar meals"),
    similarity_method: str = Query("content", description="Method to determine similarity (content, interaction, ingredient)"),
    db = Depends(get_db)
):
    """
    Get meals similar to the specified item.
    
    Supports three similarity methods:
    - content: Uses vector embeddings to find similar meals based on textual features
    - interaction: Uses co-occurrence patterns to find meals that users interact with together
    - ingredient: Uses common ingredients to find similar meals
    
    Parameters:
    - content_type: Type of content ('meal' or 'recipe')
    - meal_id: ID of the meal
    - limit: Maximum number of similar meals to return
    - similarity_method: Method to determine similarity (content, interaction, ingredient)
    
    Returns:
    - List of similar meals with similarity scores
    """
    start_time = time.time()
    
    # Validate content type
    content_type = validate_content_type(content_type)
    
    # Choose similarity method
    if similarity_method == "content":
        # Content-based similarity using vector embeddings
        recommender = ContentBasedRecommender()
    elif similarity_method == "interaction":
        # Item-based collaborative filtering using interaction patterns
        recommender = ItemBasedRecommender()
    elif similarity_method == "ingredient":
        # Ingredient-based similarity
        recommender = ContentBasedRecommender()
        similar_items = recommender.get_similar_by_ingredients(
            meal_id=meal_id,
            content_type=content_type,
            limit=limit
        )
        
        # Format the items and return
        items = []
        for item in similar_items:
            items.append(RecommendationItem(
                id=item["id"],
                content_type=item.get("content_type", content_type),
                title=item.get("title", ""),
                score=item.get("similarity") or item.get("score")
            ))
        
        execution_time = (time.time() - start_time) * 1000
        
        return {
            "items": items,
            "count": len(items),
            "execution_time_ms": round(execution_time, 2)
        }
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid similarity method. Must be 'content', 'interaction', or 'ingredient'."
        )
    
    # Get similar meals
    similar_items = recommender.get_recommendations(
        meal_id=meal_id,
        content_type=content_type,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in similar_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item["content_type"],
            title=item.get("title", ""),
            score=item.get("similarity") or item.get("score")
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/trending/{content_type}", response_model=RecommendationResponse, tags=["recommendations"])
def get_trending_meals(
    content_type: str,
    time_window: str = Query("day", description="Time window for trending meals"),
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db = Depends(get_db)
):
    """
    Get trending meals based on recent interactions.
    
    Parameters:
    - content_type: Type of content ('meal', 'recipe', or 'all')
    - time_window: Time window to consider ('day', 'week', 'month')
    - limit: Maximum number of meals to return
    
    Returns:
    - List of trending meals with popularity scores
    """
    start_time = time.time()
    
    # Validate content type (allowing 'all' as a valid option)
    content_type = validate_content_type(content_type, allow_all=True)
    
    # Validate time window
    if time_window not in ALLOWED_TRENDING_WINDOWS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Time window must be one of: {', '.join(ALLOWED_TRENDING_WINDOWS)}"
        )
    
    # Get trending meals
    recommender = PopularityRecommender()
    trending_items = recommender.get_recommendations(
        content_type=content_type,
        time_window=time_window,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in trending_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item["content_type"],
            title=item.get("title", ""),
            score=item.get("popularity")
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/recommend/cuisine/{cuisine_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_cuisine_recommendations(
    cuisine_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db = Depends(get_db)
):
    """
    Get meal recommendations based on cuisine.
    
    Parameters:
    - cuisine_id: ID of the cuisine
    - limit: Maximum number of meals to return
    
    Returns:
    - List of meals in the specified cuisine
    """
    start_time = time.time()
    
    recommender = PopularityRecommender()
    cuisine_items = recommender.get_cuisine_recommendations(
        cuisine_id=cuisine_id,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in cuisine_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item.get("content_type", "meal"),
            title=item.get("title", ""),
            score=None
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/recommend/dietary/{dietary_restriction_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_dietary_recommendations(
    dietary_restriction_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db = Depends(get_db)
):
    """
    Get meal recommendations based on dietary restrictions.
    
    Parameters:
    - dietary_restriction_id: ID of the dietary restriction
    - limit: Maximum number of meals to return
    
    Returns:
    - List of meals that match the dietary restriction
    """
    start_time = time.time()
    
    recommender = PopularityRecommender()
    dietary_items = recommender.get_dietary_recommendations(
        dietary_restriction_id=dietary_restriction_id,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in dietary_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item.get("content_type", "meal"),
            title=item.get("title", ""),
            score=None
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.post("/interactions", tags=["interactions"])
def record_interaction(interaction: InteractionCreate, db = Depends(get_db)):
    """
    Record a user interaction with a meal.
    
    Parameters:
    - user_id: ID of the user
    - meal_id: ID of the meal
    - content_type: Type of content ('meal' or 'recipe')
    - interaction_type: Type of interaction ('view', 'like', 'save', 'cook')
    
    Returns:
    - Status confirmation
    """
    start_time = time.time()
    
    # Validate content type
    try:
        validate_content_type(interaction.content_type)
    except HTTPException as e:
        raise e
    
    from data.repositories import InteractionRepository
    
    # Record the interaction
    repository = InteractionRepository()
    success = repository.record_interaction(
        user_id=interaction.user_id,
        meal_id=interaction.meal_id,
        content_type=interaction.content_type,
        interaction_type=interaction.interaction_type
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to record interaction"
        )
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "status": "recorded",
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/user/{user_id}/history", tags=["interactions"])
def get_user_meal_history(
    user_id: str,
    content_type: Optional[str] = None,
    limit: int = 10,
    db = Depends(get_db)
):
    """
    Get a user's meal interaction history.
    
    Parameters:
    - user_id: ID of the user
    - content_type: Optional filter by content type ('meal' or 'recipe')
    - limit: Maximum number of history items to return
    
    Returns:
    - List of user's recent meal interactions
    """
    start_time = time.time()
    
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    from data.repositories import InteractionRepository
    
    repository = InteractionRepository()
    history = repository.get_user_recent_interactions(
        user_id=user_id,
        content_type=content_type,
        limit=limit
    )
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "history": history,
        "count": len(history),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/user/{user_id}/dietary-preferences", tags=["user"])
def get_user_dietary_preferences(
    user_id: str,
    db = Depends(get_db)
):
    """
    Get a user's dietary preferences.
    
    Parameters:
    - user_id: ID of the user
    
    Returns:
    - List of user's dietary preferences
    """
    start_time = time.time()
    
    from data.repositories import InteractionRepository
    
    repository = InteractionRepository()
    preferences = repository.get_user_dietary_preferences(user_id)
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "dietary_preferences": preferences,
        "count": len(preferences),
        "execution_time_ms": round(execution_time, 2)
    }

@router.post("/user/{user_id}/dietary-preferences", tags=["user"])
def set_user_dietary_preference(
    user_id: str,
    dietary_restriction_id: int,
    db = Depends(get_db)
):
    """
    Add a dietary preference for a user.
    
    Parameters:
    - user_id: ID of the user
    - dietary_restriction_id: ID of the dietary restriction
    
    Returns:
    - Status confirmation
    """
    start_time = time.time()
    
    from data.repositories import InteractionRepository
    
    repository = InteractionRepository()
    success = repository.add_user_dietary_preference(
        user_id=user_id,
        dietary_restriction_id=dietary_restriction_id
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to add dietary preference"
        )
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "status": "added",
        "execution_time_ms": round(execution_time, 2)
    }
////////////////////////////////////////////////////////////////////////////////

│   └── middleware.py

////////////////////////////////////////////////////////////////////////////////
"""
Meal Recommendation Service main application.
This is the entry point for the service.
"""
import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.openapi.docs import get_swagger_ui_html
from contextlib import asynccontextmanager

from api.endpoints import router as api_router
from utils.scheduler import start_scheduler
from config import API_HOST, API_PORT, RELOAD
from setup import create_recommendation_tables
from embeddings.generator import EmbeddingGenerator

# Startup and shutdown events
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Initialize database and run embedding generation
    create_recommendation_tables()
    
    # Run initial embedding generation
    generator = EmbeddingGenerator()
    generator.generate_all_embeddings()
    
    # Start the scheduler
    scheduler_thread = start_scheduler()
    
    yield
    
    # Shutdown: Nothing to clean up as scheduler runs in daemon thread

# Create FastAPI app
app = FastAPI(
    title="Meal Recommendation Service",
    description="API for personalized meal recommendations",
    version="1.0.0",
    lifespan=lifespan
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins in development
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include API router
app.include_router(api_router)

# Custom Swagger UI
@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - API Documentation",
        swagger_js_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui-bundle.js",
        swagger_css_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui.css",
    )

if __name__ == "__main__":
    uvicorn.run(
        "main:app", 
        host=API_HOST, 
        port=API_PORT,
        reload=RELOAD
    )
////////////////////////////////////////////////////////////////////////////////

├── chat.txt

////////////////////////////////////////////////////////////////////////////////
Directory Tree: ./
================================================================================

├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

├── api
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////
"""
Recommendation Service API Package.
"""
# This file enables the directory to be imported as a package
////////////////////////////////////////////////////////////////////////////////

│   ├── endpoints.py

////////////////////////////////////////////////////////////////////////////////
"""
Meal Recommendation Service API endpoints.
All API routes are defined here in a modular, organized manner.
"""
from fastapi import APIRouter, Depends, Query, HTTPException, status, Request
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import time

from config import CONTENT_TYPES, DEFAULT_RECOMMENDATION_LIMIT, ALLOWED_TRENDING_WINDOWS
from data.database import get_db
from services.hybrid import HybridRecommender
from services.item_based import ItemBasedRecommender
from services.collaborative import CollaborativeRecommender
from services.content_based import ContentBasedRecommender
from services.popularity import PopularityRecommender

# Request & Response Models
class InteractionCreate(BaseModel):
    """Request model for creating a meal interaction record."""
    user_id: str
    meal_id: str
    content_type: str
    interaction_type: str

class RecommendationItem(BaseModel):
    """Model for a recommendation item in responses."""
    id: str
    content_type: str
    title: str
    score: Optional[float] = None
    
class RecommendationResponse(BaseModel):
    """Standard response model for recommendation endpoints."""
    items: List[RecommendationItem]
    count: int
    execution_time_ms: float

# API Routers
router = APIRouter()

# Utility functions
def validate_content_type(content_type: str, allow_all: bool = False) -> str:
    """Validate the content type parameter."""
    valid_types = CONTENT_TYPES.copy()
    if allow_all:
        valid_types.append('all')
        
    if content_type not in valid_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Content type must be one of: {', '.join(valid_types)}"
        )
    
    return content_type

# Request timing middleware
@router.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    
    # If it's a JSON response, we add the execution time to the response
    if isinstance(response, JSONResponse):
        content = response.body.decode()
        import json
        try:
            data = json.loads(content)
            if isinstance(data, dict):
                data["execution_time_ms"] = round(process_time * 1000, 2)
                response.body = json.dumps(data).encode()
        except:
            pass
    
    return response

# Endpoints
@router.get("/", tags=["status"])
def read_root():
    """Root endpoint for API status check."""
    return {"status": "Meal recommendation service is running"}

@router.get("/recommend/user/{user_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_user_recommendations(
    user_id: str,
    content_type: Optional[str] = Query(None, description="Filter by content type (meal, recipe)"),
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of recommendations"),
    recommendation_type: str = Query("hybrid", description="Recommendation algorithm to use (hybrid, item-based, user-based)"),
    cuisine: Optional[str] = Query(None, description="Filter by cuisine type"),
    dietary_restriction: Optional[str] = Query(None, description="Filter by dietary restriction"),
    db = Depends(get_db)
):
    """
    Get personalized meal recommendations for a user.
    
    Uses a hybrid approach with multiple recommendation strategies:
    1. Collaborative filtering based on similar users
    2. Content-based recommendations using recent interactions
    3. Popularity-based recommendations as fallback
    
    Parameters:
    - user_id: The ID of the user
    - content_type: Optional filter by content type ('meal', 'recipe')
    - limit: Maximum number of recommendations to return
    - recommendation_type: Algorithm to use (hybrid, item-based, user-based)
    - cuisine: Optional filter by cuisine type
    - dietary_restriction: Optional filter by dietary restriction
    
    Returns:
    - List of recommended meals
    """
    start_time = time.time()
    
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    # Choose the recommendation strategy based on the type parameter
    if recommendation_type == "hybrid":
        recommender = HybridRecommender()
    elif recommendation_type == "item-based":
        recommender = ItemBasedRecommender()
    elif recommendation_type == "user-based":
        recommender = CollaborativeRecommender()
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid recommendation type. Must be 'hybrid', 'item-based', or 'user-based'."
        )
    
    # Get recommendations
    recommended_items = recommender.get_recommendations(
        user_id=user_id,
        content_type=content_type,
        limit=limit,
        cuisine=cuisine,
        dietary_restriction=dietary_restriction
    )
    
    # Format response
    items = []
    for item in recommended_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item["content_type"],
            title=item.get("title", ""),
            score=item.get("score")
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/recommend/similar/{content_type}/{meal_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_similar_meals(
    content_type: str,
    meal_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of similar meals"),
    similarity_method: str = Query("content", description="Method to determine similarity (content, interaction, ingredient)"),
    db = Depends(get_db)
):
    """
    Get meals similar to the specified item.
    
    Supports three similarity methods:
    - content: Uses vector embeddings to find similar meals based on textual features
    - interaction: Uses co-occurrence patterns to find meals that users interact with together
    - ingredient: Uses common ingredients to find similar meals
    
    Parameters:
    - content_type: Type of content ('meal' or 'recipe')
    - meal_id: ID of the meal
    - limit: Maximum number of similar meals to return
    - similarity_method: Method to determine similarity (content, interaction, ingredient)
    
    Returns:
    - List of similar meals with similarity scores
    """
    start_time = time.time()
    
    # Validate content type
    content_type = validate_content_type(content_type)
    
    # Choose similarity method
    if similarity_method == "content":
        # Content-based similarity using vector embeddings
        recommender = ContentBasedRecommender()
    elif similarity_method == "interaction":
        # Item-based collaborative filtering using interaction patterns
        recommender = ItemBasedRecommender()
    elif similarity_method == "ingredient":
        # Ingredient-based similarity
        recommender = ContentBasedRecommender()
        similar_items = recommender.get_similar_by_ingredients(
            meal_id=meal_id,
            content_type=content_type,
            limit=limit
        )
        
        # Format the items and return
        items = []
        for item in similar_items:
            items.append(RecommendationItem(
                id=item["id"],
                content_type=item.get("content_type", content_type),
                title=item.get("title", ""),
                score=item.get("similarity") or item.get("score")
            ))
        
        execution_time = (time.time() - start_time) * 1000
        
        return {
            "items": items,
            "count": len(items),
            "execution_time_ms": round(execution_time, 2)
        }
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid similarity method. Must be 'content', 'interaction', or 'ingredient'."
        )
    
    # Get similar meals
    similar_items = recommender.get_recommendations(
        meal_id=meal_id,
        content_type=content_type,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in similar_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item["content_type"],
            title=item.get("title", ""),
            score=item.get("similarity") or item.get("score")
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/trending/{content_type}", response_model=RecommendationResponse, tags=["recommendations"])
def get_trending_meals(
    content_type: str,
    time_window: str = Query("day", description="Time window for trending meals"),
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db = Depends(get_db)
):
    """
    Get trending meals based on recent interactions.
    
    Parameters:
    - content_type: Type of content ('meal', 'recipe', or 'all')
    - time_window: Time window to consider ('day', 'week', 'month')
    - limit: Maximum number of meals to return
    
    Returns:
    - List of trending meals with popularity scores
    """
    start_time = time.time()
    
    # Validate content type (allowing 'all' as a valid option)
    content_type = validate_content_type(content_type, allow_all=True)
    
    # Validate time window
    if time_window not in ALLOWED_TRENDING_WINDOWS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Time window must be one of: {', '.join(ALLOWED_TRENDING_WINDOWS)}"
        )
    
    # Get trending meals
    recommender = PopularityRecommender()
    trending_items = recommender.get_recommendations(
        content_type=content_type,
        time_window=time_window,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in trending_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item["content_type"],
            title=item.get("title", ""),
            score=item.get("popularity")
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/recommend/cuisine/{cuisine_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_cuisine_recommendations(
    cuisine_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db = Depends(get_db)
):
    """
    Get meal recommendations based on cuisine.
    
    Parameters:
    - cuisine_id: ID of the cuisine
    - limit: Maximum number of meals to return
    
    Returns:
    - List of meals in the specified cuisine
    """
    start_time = time.time()
    
    recommender = PopularityRecommender()
    cuisine_items = recommender.get_cuisine_recommendations(
        cuisine_id=cuisine_id,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in cuisine_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item.get("content_type", "meal"),
            title=item.get("title", ""),
            score=None
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/recommend/dietary/{dietary_restriction_id}", response_model=RecommendationResponse, tags=["recommendations"])
def get_dietary_recommendations(
    dietary_restriction_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db = Depends(get_db)
):
    """
    Get meal recommendations based on dietary restrictions.
    
    Parameters:
    - dietary_restriction_id: ID of the dietary restriction
    - limit: Maximum number of meals to return
    
    Returns:
    - List of meals that match the dietary restriction
    """
    start_time = time.time()
    
    recommender = PopularityRecommender()
    dietary_items = recommender.get_dietary_recommendations(
        dietary_restriction_id=dietary_restriction_id,
        limit=limit
    )
    
    # Format the items
    items = []
    for item in dietary_items:
        items.append(RecommendationItem(
            id=item["id"],
            content_type=item.get("content_type", "meal"),
            title=item.get("title", ""),
            score=None
        ))
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "items": items,
        "count": len(items),
        "execution_time_ms": round(execution_time, 2)
    }

@router.post("/interactions", tags=["interactions"])
def record_interaction(interaction: InteractionCreate, db = Depends(get_db)):
    """
    Record a user interaction with a meal.
    
    Parameters:
    - user_id: ID of the user
    - meal_id: ID of the meal
    - content_type: Type of content ('meal' or 'recipe')
    - interaction_type: Type of interaction ('view', 'like', 'save', 'cook')
    
    Returns:
    - Status confirmation
    """
    start_time = time.time()
    
    # Validate content type
    try:
        validate_content_type(interaction.content_type)
    except HTTPException as e:
        raise e
    
    from data.repositories import InteractionRepository
    
    # Record the interaction
    repository = InteractionRepository()
    success = repository.record_interaction(
        user_id=interaction.user_id,
        meal_id=interaction.meal_id,
        content_type=interaction.content_type,
        interaction_type=interaction.interaction_type
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to record interaction"
        )
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "status": "recorded",
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/user/{user_id}/history", tags=["interactions"])
def get_user_meal_history(
    user_id: str,
    content_type: Optional[str] = None,
    limit: int = 10,
    db = Depends(get_db)
):
    """
    Get a user's meal interaction history.
    
    Parameters:
    - user_id: ID of the user
    - content_type: Optional filter by content type ('meal' or 'recipe')
    - limit: Maximum number of history items to return
    
    Returns:
    - List of user's recent meal interactions
    """
    start_time = time.time()
    
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    from data.repositories import InteractionRepository
    
    repository = InteractionRepository()
    history = repository.get_user_recent_interactions(
        user_id=user_id,
        content_type=content_type,
        limit=limit
    )
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "history": history,
        "count": len(history),
        "execution_time_ms": round(execution_time, 2)
    }

@router.get("/user/{user_id}/dietary-preferences", tags=["user"])
def get_user_dietary_preferences(
    user_id: str,
    db = Depends(get_db)
):
    """
    Get a user's dietary preferences.
    
    Parameters:
    - user_id: ID of the user
    
    Returns:
    - List of user's dietary preferences
    """
    start_time = time.time()
    
    from data.repositories import InteractionRepository
    
    repository = InteractionRepository()
    preferences = repository.get_user_dietary_preferences(user_id)
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "dietary_preferences": preferences,
        "count": len(preferences),
        "execution_time_ms": round(execution_time, 2)
    }

@router.post("/user/{user_id}/dietary-preferences", tags=["user"])
def set_user_dietary_preference(
    user_id: str,
    dietary_restriction_id: int,
    db = Depends(get_db)
):
    """
    Add a dietary preference for a user.
    
    Parameters:
    - user_id: ID of the user
    - dietary_restriction_id: ID of the dietary restriction
    
    Returns:
    - Status confirmation
    """
    start_time = time.time()
    
    from data.repositories import InteractionRepository
    
    repository = InteractionRepository()
    success = repository.add_user_dietary_preference(
        user_id=user_id,
        dietary_restriction_id=dietary_restriction_id
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to add dietary preference"
        )
    
    execution_time = (time.time() - start_time) * 1000
    
    return {
        "status": "added",
        "execution_time_ms": round(execution_time, 2)
    }
////////////////////////////////////////////////////////////////////////////////

├── client
│   └── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

├── collection.json

////////////////////////////////////////////////////////////////////////////////
{
    "info": {
      "name": "Meal Recommendation API",
      "description": "Collection of API endpoints for the Meal Recommendation Service",
      "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
      "_exporter_id": "12345678"
    },
    "item": [
      {
        "name": "Status",
        "request": {
          "method": "GET",
          "header": [],
          "url": {
            "raw": "{{baseUrl}}/",
            "host": ["{{baseUrl}}"],
            "path": [""]
          },
          "description": "Check if the API is running"
        },
        "response": []
      },
      {
        "name": "User Recommendations",
        "item": [
          {
            "name": "Get User Recommendations",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/recommend/user/{{userId}}?limit=10&recommendation_type=hybrid&content_type=meal",
                "host": ["{{baseUrl}}"],
                "path": ["recommend", "user", "{{userId}}"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of recommendations to return"
                  },
                  {
                    "key": "recommendation_type",
                    "value": "hybrid",
                    "description": "Recommendation algorithm (hybrid, user-based, item-based)"
                  },
                  {
                    "key": "content_type",
                    "value": "meal",
                    "description": "Content type (meal, recipe)"
                  },
                  {
                    "key": "cuisine",
                    "value": "",
                    "description": "Filter by cuisine ID",
                    "disabled": true
                  },
                  {
                    "key": "dietary_restriction",
                    "value": "",
                    "description": "Filter by dietary restriction ID",
                    "disabled": true
                  }
                ]
              },
              "description": "Get personalized meal recommendations for a user"
            },
            "response": []
          },
          {
            "name": "Get User History",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/user/{{userId}}/history?limit=10&content_type=meal",
                "host": ["{{baseUrl}}"],
                "path": ["user", "{{userId}}", "history"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of history items to return"
                  },
                  {
                    "key": "content_type",
                    "value": "meal",
                    "description": "Content type (meal, recipe)",
                    "disabled": false
                  }
                ]
              },
              "description": "Get a user's meal interaction history"
            },
            "response": []
          },
          {
            "name": "Get User Dietary Preferences",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/user/{{userId}}/dietary-preferences",
                "host": ["{{baseUrl}}"],
                "path": ["user", "{{userId}}", "dietary-preferences"]
              },
              "description": "Get a user's dietary preferences"
            },
            "response": []
          }
        ],
        "description": "Endpoints for user-specific recommendations and preferences"
      },
      {
        "name": "Similar Meals",
        "item": [
          {
            "name": "Get Similar Meals (Content-Based)",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/recommend/similar/meal/{{mealId}}?limit=10&similarity_method=content",
                "host": ["{{baseUrl}}"],
                "path": ["recommend", "similar", "meal", "{{mealId}}"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of similar meals to return"
                  },
                  {
                    "key": "similarity_method",
                    "value": "content",
                    "description": "Method to determine similarity (content, interaction, ingredient)"
                  }
                ]
              },
              "description": "Get similar meals using content-based similarity (vector embeddings)"
            },
            "response": []
          },
          {
            "name": "Get Similar Meals (Interaction-Based)",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/recommend/similar/meal/{{mealId}}?limit=10&similarity_method=interaction",
                "host": ["{{baseUrl}}"],
                "path": ["recommend", "similar", "meal", "{{mealId}}"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of similar meals to return"
                  },
                  {
                    "key": "similarity_method",
                    "value": "interaction",
                    "description": "Method to determine similarity (content, interaction, ingredient)"
                  }
                ]
              },
              "description": "Get similar meals using interaction-based similarity (co-occurrence patterns)"
            },
            "response": []
          },
          {
            "name": "Get Similar Meals (Ingredient-Based)",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/recommend/similar/meal/{{mealId}}?limit=10&similarity_method=ingredient",
                "host": ["{{baseUrl}}"],
                "path": ["recommend", "similar", "meal", "{{mealId}}"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of similar meals to return"
                  },
                  {
                    "key": "similarity_method",
                    "value": "ingredient",
                    "description": "Method to determine similarity (content, interaction, ingredient)"
                  }
                ]
              },
              "description": "Get similar meals using ingredient-based similarity (common ingredients)"
            },
            "response": []
          }
        ],
        "description": "Endpoints for finding meals similar to a specific meal"
      },
      {
        "name": "Trending Meals",
        "item": [
          {
            "name": "Get Trending Meals (Day)",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/trending/meal?limit=10&time_window=day",
                "host": ["{{baseUrl}}"],
                "path": ["trending", "meal"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of trending meals to return"
                  },
                  {
                    "key": "time_window",
                    "value": "day",
                    "description": "Time window (day, week, month)"
                  }
                ]
              },
              "description": "Get trending meals based on interactions in the last 24 hours"
            },
            "response": []
          },
          {
            "name": "Get Trending Meals (Week)",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/trending/meal?limit=10&time_window=week",
                "host": ["{{baseUrl}}"],
                "path": ["trending", "meal"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of trending meals to return"
                  },
                  {
                    "key": "time_window",
                    "value": "week",
                    "description": "Time window (day, week, month)"
                  }
                ]
              },
              "description": "Get trending meals based on interactions in the last 7 days"
            },
            "response": []
          },
          {
            "name": "Get Trending Recipes",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/trending/recipe?limit=10&time_window=week",
                "host": ["{{baseUrl}}"],
                "path": ["trending", "recipe"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of trending recipes to return"
                  },
                  {
                    "key": "time_window",
                    "value": "week",
                    "description": "Time window (day, week, month)"
                  }
                ]
              },
              "description": "Get trending recipes based on interactions in the specified time window"
            },
            "response": []
          },
          {
            "name": "Get All Trending Content",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/trending/all?limit=10&time_window=week",
                "host": ["{{baseUrl}}"],
                "path": ["trending", "all"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of trending items to return"
                  },
                  {
                    "key": "time_window",
                    "value": "week",
                    "description": "Time window (day, week, month)"
                  }
                ]
              },
              "description": "Get trending content (meals and recipes) based on interactions"
            },
            "response": []
          }
        ],
        "description": "Endpoints for getting trending meals based on recent interactions"
      },
      {
        "name": "Category-Based Recommendations",
        "item": [
          {
            "name": "Get Meals by Cuisine",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/recommend/cuisine/{{cuisineId}}?limit=10",
                "host": ["{{baseUrl}}"],
                "path": ["recommend", "cuisine", "{{cuisineId}}"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of meals to return"
                  }
                ]
              },
              "description": "Get meal recommendations based on cuisine"
            },
            "response": []
          },
          {
            "name": "Get Meals by Dietary Restriction",
            "request": {
              "method": "GET",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/recommend/dietary/{{dietaryRestrictionId}}?limit=10",
                "host": ["{{baseUrl}}"],
                "path": ["recommend", "dietary", "{{dietaryRestrictionId}}"],
                "query": [
                  {
                    "key": "limit",
                    "value": "10",
                    "description": "Maximum number of meals to return"
                  }
                ]
              },
              "description": "Get meal recommendations based on dietary restrictions"
            },
            "response": []
          }
        ],
        "description": "Endpoints for category-based recommendations (cuisine, dietary preferences)"
      },
      {
        "name": "Interactions",
        "item": [
          {
            "name": "Record Interaction",
            "request": {
              "method": "POST",
              "header": [
                {
                  "key": "Content-Type",
                  "value": "application/json"
                }
              ],
              "body": {
                "mode": "raw",
                "raw": "{\n    \"user_id\": \"{{userId}}\",\n    \"meal_id\": \"{{mealId}}\",\n    \"content_type\": \"meal\",\n    \"interaction_type\": \"view\"\n}"
              },
              "url": {
                "raw": "{{baseUrl}}/interactions",
                "host": ["{{baseUrl}}"],
                "path": ["interactions"]
              },
              "description": "Record a user interaction with a meal"
            },
            "response": []
          },
          {
            "name": "Add Dietary Preference",
            "request": {
              "method": "POST",
              "header": [],
              "url": {
                "raw": "{{baseUrl}}/user/{{userId}}/dietary-preferences?dietary_restriction_id=1",
                "host": ["{{baseUrl}}"],
                "path": ["user", "{{userId}}", "dietary-preferences"],
                "query": [
                  {
                    "key": "dietary_restriction_id",
                    "value": "1",
                    "description": "ID of the dietary restriction"
                  }
                ]
              },
              "description": "Add a dietary preference for a user"
            },
            "response": []
          }
        ],
        "description": "Endpoints for recording user interactions and preferences"
      }
    ],
    "event": [
      {
        "listen": "prerequest",
        "script": {
          "type": "text/javascript",
          "exec": [""]
        }
      },
      {
        "listen": "test",
        "script": {
          "type": "text/javascript",
          "exec": [""]
        }
      }
    ],
    "variable": [
      {
        "key": "baseUrl",
        "value": "http://localhost:8000",
        "type": "string",
        "description": "Base URL for the meal recommendation API"
      },
      {
        "key": "userId",
        "value": "user-123",
        "type": "string",
        "description": "Sample user ID for testing"
      },
      {
        "key": "mealId",
        "value": "meal-456",
        "type": "string",
        "description": "Sample meal ID for testing"
      },
      {
        "key": "cuisineId",
        "value": "1",
        "type": "string",
        "description": "Sample cuisine ID for testing (1=Italian)"
      },
      {
        "key": "dietaryRestrictionId",
        "value": "1",
        "type": "string",
        "description": "Sample dietary restriction ID for testing (1=Vegetarian)"
      }
    ]
  }
////////////////////////////////////////////////////////////////////////////////

├── config
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   └── settings.py

////////////////////////////////////////////////////////////////////////////////
"""
Configuration settings for the meal recommendation service.
Centralizes all configuration parameters in a single file.
"""
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Database settings
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://postgres:postgres@localhost:5432/postgres")

# API settings
API_HOST = os.getenv("API_HOST", "0.0.0.0")
API_PORT = int(os.getenv("API_PORT", "8000"))
RELOAD = os.getenv("RELOAD", "True").lower() == "true"

# Embedding model settings
EMBEDDING_MODEL = os.getenv("EMBEDDING_MODEL", "all-MiniLM-L6-v2")
EMBEDDING_DIMENSION = int(os.getenv("EMBEDDING_DIMENSION", "384"))  # Dimension depends on model

# Recommendation settings
DEFAULT_RECOMMENDATION_LIMIT = int(os.getenv("DEFAULT_RECOMMENDATION_LIMIT", "10"))
CONTENT_TYPES = ["meal", "recipe"]
ALLOWED_TRENDING_WINDOWS = ["day", "week", "month"]
INTERACTION_TYPES = ["view", "like", "save", "cook", "comment"]

# Scheduler settings
EMBEDDING_GENERATION_INTERVAL = int(os.getenv("EMBEDDING_GENERATION_INTERVAL", "60"))  # minutes
SCHEDULER_SLEEP_INTERVAL = int(os.getenv("SCHEDULER_SLEEP_INTERVAL", "60"))  # seconds

# Client settings
RECOMMENDATION_API_URL = os.getenv("RECOMMENDATION_API_URL", "http://localhost:8000")

# Cache settings
ENABLE_CACHE = os.getenv("ENABLE_CACHE", "False").lower() == "true"
CACHE_EXPIRATION = int(os.getenv("CACHE_EXPIRATION", "300"))  # seconds

# Meal-specific settings
CUISINE_TYPES = [
    "italian", "mexican", "chinese", "indian", "american",
    "french", "japanese", "mediterranean", "thai", "other"
]

DIETARY_RESTRICTIONS = [
    "vegetarian", "vegan", "gluten-free", "dairy-free", 
    "keto", "paleo", "low-carb", "low-fat"
]

# Similarity thresholds
MIN_SIMILARITY_SCORE = float(os.getenv("MIN_SIMILARITY_SCORE", "0.6"))
MIN_COMMON_ITEMS = int(os.getenv("MIN_COMMON_ITEMS", "2"))

# Logging configuration
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
LOG_FORMAT = os.getenv(
    "LOG_FORMAT", 
    "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)

# Setup logging
import logging
logging.basicConfig(level=getattr(logging, LOG_LEVEL), format=LOG_FORMAT)
////////////////////////////////////////////////////////////////////////////////

├── data
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   ├── db.py

////////////////////////////////////////////////////////////////////////////////
"""
Database connection module.
Provides database connection pool and transaction management.
"""
from sqlalchemy import create_engine, text
from contextlib import contextmanager
from typing import Generator

from config.settings import DATABASE_URL

# Create database engine with connection pooling
engine = create_engine(DATABASE_URL, pool_size=10, max_overflow=20)

@contextmanager
def get_connection():
    """Get a database connection from the pool."""
    connection = engine.connect()
    try:
        yield connection
    finally:
        connection.close()

@contextmanager
def get_transaction():
    """Get a database connection with transaction."""
    connection = engine.connect()
    transaction = connection.begin()
    try:
        yield connection
        transaction.commit()
    except Exception:
        transaction.rollback()
        raise
    finally:
        connection.close()

def execute_query(query, params=None, is_transaction=False):
    """Execute a database query with parameters."""
    manager = get_transaction if is_transaction else get_connection
    
    with manager() as conn:
        result = conn.execute(text(query), params or {})
        return result

def test_connection():
    """Test the database connection."""
    try:
        with get_connection() as conn:
            result = conn.execute(text("SELECT 1"))
            print("Database connection successful!")
            return True
    except Exception as e:
        print(f"Database connection failed: {e}")
        return False
////////////////////////////////////////////////////////////////////////////////

│   └── repo.py

////////////////////////////////////////////////////////////////////////////////
"""
Repositories for data access.
All repositories are consolidated in this module for easier maintenance.
"""
from typing import List, Dict, Any, Optional, Tuple
import logging
from datetime import datetime

from data.database import execute_query
import data.queries as queries
from config import CONTENT_TYPES, MIN_COMMON_ITEMS

logger = logging.getLogger(__name__)

class ContentEmbeddingRepository:
    """Repository for content embeddings."""
    
    def save_embedding(self, meal_id: str, content_type: str, embedding: List[float]) -> bool:
        """
        Save or update a content embedding.
        
        Args:
            meal_id: The ID of the content
            content_type: The type of content ('meal', 'recipe')
            embedding: The vector embedding
            
        Returns:
            bool: Success status
        """
        try:
            execute_query(
                queries.SAVE_EMBEDDING,
                {
                    "meal_id": meal_id,
                    "content_type": content_type,
                    "embedding": embedding
                },
                is_transaction=True
            )
            return True
        except Exception as e:
            logger.error(f"Error saving embedding: {e}")
            return False
    
    def get_embedding(self, meal_id: str, content_type: str) -> Optional[List[float]]:
        """
        Get the embedding for specific content.
        
        Args:
            meal_id: The ID of the content
            content_type: The type of content
            
        Returns:
            The embedding vector or None if not found
        """
        result = execute_query(
            queries.GET_EMBEDDING,
            {"meal_id": meal_id, "content_type": content_type}
        )
        
        row = result.fetchone()
        return row[0] if row else None
    
    def find_similar_content(
        self, 
        embedding: List[float], 
        content_type: Optional[str] = None, 
        exclude_ids: List[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Find content with similar embeddings.
        
        Args:
            embedding: The source embedding to compare against
            content_type: Optional filter for content type
            exclude_ids: List of content IDs to exclude
            limit: Maximum number of results
            
        Returns:
            List of similar content items with similarity scores
        """
        params = {"embedding": embedding, "limit": limit}
        
        # Build query parts
        type_filter = ""
        if content_type:
            type_filter = "AND ce.content_type = :content_type"
            params["content_type"] = content_type
        
        exclude_clause = ""
        if exclude_ids and len(exclude_ids) > 0:
            placeholder_list = ','.join([f':exclude_{i}' for i in range(len(exclude_ids))])
            exclude_clause = f"AND ce.meal_id NOT IN ({placeholder_list})"
            for i, id_val in enumerate(exclude_ids):
                params[f"exclude_{i}"] = id_val
        
        # Execute query
        formatted_query = queries.FIND_SIMILAR_CONTENT_BASE.format(
            type_filter=type_filter,
            exclude_clause=exclude_clause
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        items = []
        for row in result:
            items.append({
                "id": row[0],
                "content_type": row[1],
                "title": row[2],
                "similarity": row[3]
            })
        
        return items
    
    def get_content_without_embeddings(self, content_type: str, limit: int = 500) -> List[Tuple[str, str, str]]:
        """
        Get content items that don't have embeddings yet.
        
        Args:
            content_type: The type of content
            limit: Maximum number of items to retrieve
            
        Returns:
            List of tuples (id, title, content) for items without embeddings
        """
        if content_type == 'meal':
            result = execute_query(
                queries.GET_MEALS_WITHOUT_EMBEDDINGS,
                {"limit": limit}
            )
        elif content_type == 'recipe':
            result = execute_query(
                queries.GET_RECIPES_WITHOUT_EMBEDDINGS,
                {"limit": limit}
            )
        else:
            return []
        
        return [(row[0], row[1] or '', row[2] or '') for row in result.fetchall()]
    
    def get_meal_ingredients(self, meal_id: str) -> List[Dict[str, Any]]:
        """
        Get ingredients for a meal.
        
        Args:
            meal_id: The ID of the meal
            
        Returns:
            List of ingredients
        """
        result = execute_query(
            queries.GET_MEAL_INGREDIENTS,
            {"meal_id": meal_id}
        )
        
        ingredients = []
        for row in result:
            ingredients.append({
                "id": row[0],
                "name": row[1],
                "amount": row[2]
            })
        
        return ingredients
    
    def get_recipe_ingredients(self, recipe_id: str) -> List[Dict[str, Any]]:
        """
        Get ingredients for a recipe.
        
        Args:
            recipe_id: The ID of the recipe
            
        Returns:
            List of ingredients
        """
        result = execute_query(
            queries.GET_RECIPE_INGREDIENTS,
            {"recipe_id": recipe_id}
        )
        
        ingredients = []
        for row in result:
            ingredients.append({
                "id": row[0],
                "name": row[1],
                "amount": row[2]
            })
        
        return ingredients
    
    def get_similar_by_ingredients(
        self,
        meal_id: str,
        content_type: str,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get meals similar by ingredients.
        
        Args:
            meal_id: The ID of the meal
            content_type: The type of content
            limit: Maximum number of results
            
        Returns:
            List of similar meals
        """
        if content_type != 'meal':
            return []
        
        result = execute_query(
            queries.GET_SIMILAR_MEALS_BY_INGREDIENTS,
            {"meal_id": meal_id, "limit": limit}
        )
        
        items = []
        for row in result:
            items.append({
                "id": row[0],
                "content_type": "meal",
                "title": row[1],
                "similarity": row[2] / 10.0  # Normalize to 0-1 range
            })
        
        return items

class InteractionRepository:
    """Repository for user interactions."""
    
    def record_interaction(
        self, 
        user_id: str, 
        meal_id: str, 
        content_type: str, 
        interaction_type: str
    ) -> bool:
        """
        Record a user interaction with content.
        
        Args:
            user_id: The ID of the user
            meal_id: The ID of the content
            content_type: The type of content ('meal', 'recipe')
            interaction_type: The type of interaction ('view', 'like', 'save', 'cook')
            
        Returns:
            bool: Success status
        """
        try:
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
                
            execute_query(
                queries.RECORD_INTERACTION,
                {
                    "user_id": user_id,
                    "meal_id": meal_id,
                    "content_type": content_type,
                    "interaction_type": interaction_type
                },
                is_transaction=True
            )
            return True
        except Exception as e:
            logger.error(f"Error recording interaction: {e}")
            return False
    
    def get_user_recent_interactions(
        self, 
        user_id: str, 
        content_type: Optional[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get recent interactions for a user.
        
        Args:
            user_id: The ID of the user
            content_type: Optional filter for content type
            limit: Maximum number of interactions to retrieve
            
        Returns:
            List of recent interactions
        """
        params = {"user_id": user_id, "limit": limit}
        
        type_filter = ""
        if content_type:
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
            type_filter = "AND content_type = :content_type"
            params["content_type"] = content_type
            
        # Format the query with the type filter
        formatted_query = queries.GET_USER_RECENT_INTERACTIONS_BASE.format(
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        interactions = []
        for row in result:
            interactions.append({
                "meal_id": row[0],
                "content_type": row[1],
                "interaction_type": row[2],
                "created_at": row[3]
            })
        
        return interactions
    
    def get_trending_content(
        self, 
        content_type: str = 'all', 
        time_window: str = 'day',
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get trending content based on recent interactions.
        
        Args:
            content_type: The type of content ('meal', 'recipe', 'all')
            time_window: Time window ('day', 'week', 'month')
            limit: Maximum number of items
            
        Returns:
            List of trending content items with popularity scores
        """
        # Determine time interval
        time_clause = "NOW() - INTERVAL '1 day'"
        if time_window == "week":
            time_clause = "NOW() - INTERVAL '7 days'"
        elif time_window == "month":
            time_clause = "NOW() - INTERVAL '30 days'"
        
        type_filter = ""
        params = {"limit": limit}
        
        if content_type != 'all':
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
            type_filter = "AND ri.content_type = :content_type"
            params["content_type"] = content_type
        
        # Format the query with the time clause and type filter
        formatted_query = queries.GET_TRENDING_MEALS_BASE.format(
            time_clause=time_clause,
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        trending_items = []
        for row in result:
            trending_items.append({
                "id": row[0],
                "content_type": row[1],
                "title": row[2],
                "popularity": row[3]
            })
        
        return trending_items
    
    def find_similar_users(
        self, 
        user_id: str, 
        min_common_items: int = MIN_COMMON_ITEMS, 
        limit: int = 10
    ) -> List[str]:
        """
        Find users with similar interaction patterns.
        
        Args:
            user_id: The ID of the user
            min_common_items: Minimum number of common items to consider users similar
            limit: Maximum number of similar users to retrieve
            
        Returns:
            List of similar user IDs
        """
        result = execute_query(
            queries.FIND_SIMILAR_USERS,
            {
                "user_id": user_id, 
                "min_common_items": min_common_items,
                "limit": limit
            }
        )
        
        return [row[0] for row in result]
    
    def get_content_from_similar_users(
        self, 
        similar_users: List[str],
        user_id: str,
        content_type: Optional[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get content items that similar users interacted with.
        
        Args:
            similar_users: List of similar user IDs
            user_id: The ID of the current user (to exclude content they've already interacted with)
            content_type: Optional filter for content type
            limit: Maximum number of content items to retrieve
            
        Returns:
            List of content items with interaction counts
        """
        if not similar_users:
            return []
        
        # Create parameter placeholders for similar users
        user_placeholders = ','.join([f':user_{i}' for i in range(len(similar_users))])
        params = {"user_id": user_id, "limit": limit}
        
        # Add similar user IDs to parameters
        for i, similar_user in enumerate(similar_users):
            params[f"user_{i}"] = similar_user
        
        # Add content type filter if specified
        type_filter = ""
        if content_type:
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
            type_filter = "AND ri.content_type = :content_type"
            params["content_type"] = content_type
        
        # Format the query with the user placeholders and type filter
        formatted_query = queries.GET_MEALS_FROM_SIMILAR_USERS_BASE.format(
            user_placeholders=user_placeholders,
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        content_items = []
        for row in result:
            content_items.append({
                "id": row[0],
                "content_type": row[1],
                "interaction_count": row[2],
                "title": row[3]
            })
        
        return content_items
    
    def get_cuisine_recommendations(
        self, 
        cuisine_id: str, 
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get meals in a specific cuisine.
        
        Args:
            cuisine_id: The ID of the cuisine
            limit: Maximum number of meals to retrieve
            
        Returns:
            List of meals in the cuisine
        """
        result = execute_query(
            queries.GET_CUISINE_MEALS,
            {"cuisine_id": cuisine_id, "limit": limit}
        )
        
        meals = []
        for row in result:
            meals.append({
                "id": row[0],
                "content_type": "meal",
                "title": row[1]
            })
        
        return meals
    
    def get_dietary_recommendations(
        self, 
        dietary_restriction_id: str, 
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get meals that match a dietary restriction.
        
        Args:
            dietary_restriction_id: The ID of the dietary restriction
            limit: Maximum number of meals to retrieve
            
        Returns:
            List of meals matching the dietary restriction
        """
        result = execute_query(
            queries.GET_DIETARY_PREFERENCE_MEALS,
            {"dietary_restriction_id": dietary_restriction_id, "limit": limit}
        )
        
        meals = []
        for row in result:
            meals.append({
                "id": row[0],
                "content_type": "meal",
                "title": row[1]
            })
        
        return meals
    
    def get_user_dietary_preferences(
        self, 
        user_id: str
    ) -> List[Dict[str, Any]]:
        """
        Get a user's dietary preferences.
        
        Args:
            user_id: The ID of the user
            
        Returns:
            List of dietary preferences
        """
        result = execute_query(
            queries.GET_USER_DIETARY_PREFERENCES,
            {"user_id": user_id}
        )
        
        preferences = []
        for row in result:
            preferences.append({
                "id": row[0],
                "name": row[1]
            })
        
        return preferences
    
    def add_user_dietary_preference(
        self, 
        user_id: str, 
        dietary_restriction_id: int
    ) -> bool:
        """
        Add a dietary preference for a user.
        
        Args:
            user_id: The ID of the user
            dietary_restriction_id: The ID of the dietary restriction
            
        Returns:
            Success status
        """
        try:
            execute_query(
                """
                INSERT INTO "UserDietaryPreference" (user_id, dietary_restriction_id)
                VALUES (:user_id, :dietary_restriction_id)
                ON CONFLICT (user_id, dietary_restriction_id) DO NOTHING
                """,
                {
                    "user_id": user_id,
                    "dietary_restriction_id": dietary_restriction_id
                },
                is_transaction=True
            )
            return True
        except Exception as e:
            logger.error(f"Error adding dietary preference: {e}")
            return False
////////////////////////////////////////////////////////////////////////////////

├── db.py

////////////////////////////////////////////////////////////////////////////////
"""
Database connection module.
Provides database connection pool and transaction management.
"""
from sqlalchemy import create_engine, text
from contextlib import contextmanager
from typing import Generator
import logging

from config import DATABASE_URL

logger = logging.getLogger(__name__)

# Create database engine with connection pooling
engine = create_engine(
    DATABASE_URL, 
    pool_size=10, 
    max_overflow=20,
    pool_pre_ping=True,  # Check connection validity before using
    pool_recycle=300,    # Recycle connections after 5 minutes
)

@contextmanager
def get_db():
    """Get a database connection from the pool."""
    connection = engine.connect()
    try:
        yield connection
    finally:
        connection.close()

@contextmanager
def get_transaction():
    """Get a database connection with transaction."""
    connection = engine.connect()
    transaction = connection.begin()
    try:
        yield connection
        transaction.commit()
    except Exception as e:
        transaction.rollback()
        logger.error(f"Transaction failed: {e}")
        raise
    finally:
        connection.close()

def execute_query(query, params=None, is_transaction=False):
    """
    Execute a database query with parameters.
    
    Args:
        query: SQL query text
        params: Query parameters
        is_transaction: Whether to execute within a transaction
        
    Returns:
        Query result
    """
    manager = get_transaction if is_transaction else get_db
    
    with manager() as conn:
        result = conn.execute(text(query), params or {})
        return result

def test_connection():
    """
    Test the database connection.
    
    Returns:
        Boolean indicating connection success
    """
    try:
        with get_db() as conn:
            result = conn.execute(text("SELECT 1"))
            logger.info("Database connection successful!")
            return True
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return False
////////////////////////////////////////////////////////////////////////////////

├── embeddings
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   └── embedding_generator.py

////////////////////////////////////////////////////////////////////////////////
"""
Embedding generator service.
Generates and stores vector embeddings for meals and recipes.
"""
from sentence_transformers import SentenceTransformer
from typing import List, Dict, Any, Optional
import time
import logging

from config import EMBEDDING_MODEL
from data.repositories import ContentEmbeddingRepository

logger = logging.getLogger(__name__)

class EmbeddingGenerator:
    """Service for generating and managing meal embeddings."""
    
    def __init__(self, model_name: str = EMBEDDING_MODEL):
        """
        Initialize the embedding generator.
        
        Args:
            model_name: The name of the sentence transformer model to use
        """
        self.model = SentenceTransformer(model_name)
        self.repository = ContentEmbeddingRepository()
    
    def generate_meal_embeddings(self, batch_size: int = 500) -> int:
        """
        Generate embeddings for meals that don't have them yet.
        
        Args:
            batch_size: Maximum number of meals to process at once
            
        Returns:
            Number of meals processed
        """
        meals = self.repository.get_content_without_embeddings('meal', batch_size)
        logger.info(f"Processing {len(meals)} meals for embedding generation")
        
        count = 0
        for meal_id, title, description in meals:
            # Get ingredients for this meal
            ingredients = self.repository.get_meal_ingredients(meal_id)
            ingredients_text = ", ".join([ing['name'] for ing in ingredients])
            
            # Generate text for embedding - include title, description, and ingredients
            text_for_embedding = f"{title} {description} Ingredients: {ingredients_text}"
            
            # Generate embedding
            embedding = self.model.encode(text_for_embedding)
            
            # Store embedding
            if self.repository.save_embedding(meal_id, 'meal', embedding.tolist()):
                count += 1
            
        logger.info(f"Generated embeddings for {count} meals")
        return count
    
    def generate_recipe_embeddings(self, batch_size: int = 500) -> int:
        """
        Generate embeddings for recipes that don't have them yet.
        
        Args:
            batch_size: Maximum number of recipes to process at once
            
        Returns:
            Number of recipes processed
        """
        recipes = self.repository.get_content_without_embeddings('recipe', batch_size)
        logger.info(f"Processing {len(recipes)} recipes for embedding generation")
        
        count = 0
        for recipe_id, name, instructions in recipes:
            # Get ingredients for this recipe
            ingredients = self.repository.get_recipe_ingredients(recipe_id)
            ingredients_text = ", ".join([ing['name'] for ing in ingredients])
            
            # Generate text for embedding - include name, instructions, and ingredients
            text_for_embedding = f"{name} {instructions} Ingredients: {ingredients_text}"
            
            # Generate embedding
            embedding = self.model.encode(text_for_embedding)
            
            # Store embedding
            if self.repository.save_embedding(recipe_id, 'recipe', embedding.tolist()):
                count += 1
            
        logger.info(f"Generated embeddings for {count} recipes")
        return count
    
    def generate_embedding_for_text(self, text: str) -> List[float]:
        """
        Generate an embedding for arbitrary text.
        
        Args:
            text: The text to encode
            
        Returns:
            The embedding vector
        """
        embedding = self.model.encode(text)
        return embedding.tolist()
    
    def generate_embedding_for_meal(self, meal_id: str, title: str, description: str, ingredients: List[str]) -> bool:
        """
        Generate and store an embedding for a specific meal.
        
        Args:
            meal_id: The ID of the meal
            title: The meal title
            description: The meal description
            ingredients: List of ingredient names
            
        Returns:
            Success status
        """
        ingredients_text = ", ".join(ingredients)
        text_for_embedding = f"{title} {description} Ingredients: {ingredients_text}"
        
        embedding = self.model.encode(text_for_embedding)
        return self.repository.save_embedding(meal_id, 'meal', embedding.tolist())
    
    def generate_all_embeddings(self) -> Dict[str, int]:
        """
        Generate embeddings for all content types.
        
        Returns:
            Dictionary with counts of processed items by type
        """
        meal_count = self.generate_meal_embeddings()
        recipe_count = self.generate_recipe_embeddings()
        
        return {
            "meals": meal_count,
            "recipes": recipe_count
        }


# For command-line execution
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    generator = EmbeddingGenerator()
    result = generator.generate_all_embeddings()
    print(f"Generated embeddings: {result}")
////////////////////////////////////////////////////////////////////////////////

├── init_dataset
│   └── kaggle.py

////////////////////////////////////////////////////////////////////////////////
import kagglehub

# Download latest version
path = kagglehub.dataset_download("kriishukla/recipe-db")

print("Path to dataset files:", path)
////////////////////////////////////////////////////////////////////////////////

├── main.py

////////////////////////////////////////////////////////////////////////////////
"""
Meal Recommendation Service main application.
This is the entry point for the service.
"""
import uvicorn
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.openapi.docs import get_swagger_ui_html
from contextlib import asynccontextmanager

from api.endpoints import router as api_router
from utils.scheduler import start_scheduler
from config import API_HOST, API_PORT, RELOAD
from setup import create_recommendation_tables
from embeddings.generator import EmbeddingGenerator

# Startup and shutdown events
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Initialize database and run embedding generation
    create_recommendation_tables()
    
    # Run initial embedding generation
    generator = EmbeddingGenerator()
    generator.generate_all_embeddings()
    
    # Start the scheduler
    scheduler_thread = start_scheduler()
    
    yield
    
    # Shutdown: Nothing to clean up as scheduler runs in daemon thread

# Create FastAPI app
app = FastAPI(
    title="Meal Recommendation Service",
    description="API for personalized meal recommendations",
    version="1.0.0",
    lifespan=lifespan
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow all origins in development
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include API router
app.include_router(api_router)

# Custom Swagger UI
@app.get("/docs", include_in_schema=False)
async def custom_swagger_ui_html():
    return get_swagger_ui_html(
        openapi_url=app.openapi_url,
        title=app.title + " - API Documentation",
        swagger_js_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui-bundle.js",
        swagger_css_url="https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui.css",
    )

if __name__ == "__main__":
    uvicorn.run(
        "main:app", 
        host=API_HOST, 
        port=API_PORT,
        reload=RELOAD
    )
////////////////////////////////////////////////////////////////////////////////

├── readme.md

////////////////////////////////////////////////////////////////////////////////
# Meal Recommendation Service

A streamlined, comprehensive meal recommendation service built with FastAPI and PostgreSQL with pgvector for efficient similarity searches. This service provides personalized meal recommendations using multiple recommendation strategies.

## Features

### Multiple Recommendation Strategies

- **Hybrid Recommender**: Combines multiple strategies with fallbacks for robust recommendations
- **User-Based Collaborative Filtering**: Finds users with similar tastes and recommends what they liked
- **Item-Based Collaborative Filtering**: Recommends items similar to those the user has interacted with
- **Content-Based Recommendations**: Uses vector embeddings to find similar content
- **Ingredient-Based Recommendations**: Suggests meals with similar ingredients
- **Popularity-Based Recommendations**: Recommends trending content as a fallback

### Flexible API

- Choose which recommendation strategy to use via API parameters
- Filter by meal type or recipe
- Filter by cuisine or dietary restrictions
- Adjust time windows for trending content
- Get meal recommendations based on time of day

### Efficient Architecture

- Simplified folder structure for better maintainability
- Consolidated modules (no deep nesting of folders)
- Optimized database queries
- Background processing for embedding generation
- Consistent error handling and response formats

## System Architecture

The service is built with FastAPI and uses PostgreSQL with pgvector extension for vector similarity search. It stores embeddings and interaction data in separate tables without modifying your existing database schema.

## Setup Instructions

### Prerequisites

- Python 3.8+
- PostgreSQL with pgvector extension
- Node.js (for client integration, optional)

### Installation

1. Clone this repository:

```bash
git clone https://github.com/yourusername/meal-recommendation-service.git
cd meal-recommendation-service
```

2. Create a virtual environment (recommended):

```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install required Python packages:

```bash
pip install fastapi uvicorn sqlalchemy psycopg2-binary sentence-transformers pandas scikit-learn numpy python-dotenv schedule
```

4. Make the startup script executable:

```bash
chmod +x start.sh
```

5. Create a `.env` file with your database connection string:

```
DATABASE_URL=postgresql://username:password@localhost:5432/yourdb
```

### Starting the Service

Use the provided startup script:

```bash
./start.sh
```

This will:
- Check for and install required packages
- Create necessary database tables if they don't exist
- Generate initial embeddings for content
- Start the background scheduler
- Start the FastAPI server

## API Documentation

Once the service is running, you can access the API documentation at:

```
http://localhost:8000/docs
```

### Key Endpoints

#### User Recommendations

```
GET /recommend/user/{user_id}?content_type=meal&limit=10&recommendation_type=hybrid
```

Get personalized meal recommendations for a user with options to use hybrid, user-based, or item-based algorithms.

#### Similar Meals

```
GET /recommend/similar/{content_type}/{meal_id}?limit=10&similarity_method=content
```

Get meals similar to the specified item. Choose between content-based similarity (using embeddings), interaction-based similarity (based on co-occurrence patterns), or ingredient-based similarity.

#### Trending Meals

```
GET /trending/{content_type}?time_window=day&limit=10
```

Get trending meals based on recent interactions.

#### Cuisine Recommendations

```
GET /recommend/cuisine/{cuisine_id}?limit=10
```

Get meals in the specified cuisine.

#### Dietary Restriction Recommendations

```
GET /recommend/dietary/{dietary_restriction_id}?limit=10
```

Get meals that conform to specific dietary restrictions.

#### Record Interactions

```
POST /interactions

{
  "user_id": "123",
  "meal_id": "456",
  "content_type": "meal",
  "interaction_type": "view"
}
```

Record user interactions with meals.

## Postman Collection

A Postman collection is included in the repository for testing the API. To use it:

1. Import `meal-recommendations.postman_collection.json` into Postman
2. Set the `baseUrl` environment variable to your API server (default: http://localhost:8000)
3. Use the test data IDs or replace them with your own data

## Customization

### Configuration Settings

Edit `config.py` to customize:

- Database connection parameters
- API settings
- Embedding model and dimension
- Default recommendation limits
- Scheduler intervals

### Recommendation Algorithms

You can customize the recommendation algorithms by:

1. Adjusting parameters in the API requests
2. Modifying the implementation in the respective strategy files
3. Creating new recommender classes that implement the BaseRecommender interface

### Embedding Model

You can change the embedding model in `config.py`:

```python
# Default model (lightweight)
EMBEDDING_MODEL = "all-MiniLM-L6-v2"

# For better multilingual support
# EMBEDDING_MODEL = "paraphrase-multilingual-MiniLM
////////////////////////////////////////////////////////////////////////////////

├── services
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   ├── base_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Base recommender interface.
Defines the common interface for all recommendation strategies.
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional

class BaseRecommender(ABC):
    """Base interface for all recommendation strategies."""
    
    @abstractmethod
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = 10,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get recommendations based on the strategy implementation.
        
        Args:
            user_id: Optional user ID for personalized recommendations
            meal_id: Optional meal ID for similar meal recommendations
            content_type: Optional content type filter ('meal', 'recipe')
            limit: Maximum number of recommendations to return
            kwargs: Additional strategy-specific parameters
            
        Returns:
            List of recommended items
        """
        pass
////////////////////////////////////////////////////////////////////////////////

│   ├── collaborative_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Collaborative filtering recommender implementation.
Recommends items based on similar users' interactions.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories import InteractionRepository
from config import DEFAULT_RECOMMENDATION_LIMIT, MIN_COMMON_ITEMS

logger = logging.getLogger(__name__)

class CollaborativeRecommender(BaseRecommender):
    """
    Collaborative filtering recommendation strategy.
    Finds users with similar interaction patterns and recommends items they've interacted with.
    This is a user-based collaborative filtering approach.
    """
    
    def __init__(self):
        """Initialize the collaborative recommender."""
        self.repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        min_common_items: int = MIN_COMMON_ITEMS,
        max_similar_users: int = 10,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get collaborative filtering recommendations.
        
        Args:
            user_id: The ID of the user
            meal_id: Not used for collaborative recommendations
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            min_common_items: Minimum number of items in common to consider users similar
            max_similar_users: Maximum number of similar users to consider
            kwargs: Additional filters (cuisine, dietary_restriction)
            
        Returns:
            List of recommended items based on similar users
        """
        if not user_id:
            logger.warning("User ID required for collaborative recommendations")
            return []
        
        # Find users with similar interaction patterns
        similar_users = self.repository.find_similar_users(
            user_id, 
            min_common_items=min_common_items,
            limit=max_similar_users
        )
        
        if not similar_users:
            logger.info(f"No similar users found for user {user_id}")
            return []
        
        # Get content that similar users have interacted with
        recommended_items = self.repository.get_content_from_similar_users(
            similar_users,
            user_id,
            content_type=content_type,
            limit=limit
        )
        
        # Apply additional filters if specified
        filtered_items = recommended_items
        
        # Filter by cuisine if specified
        cuisine = kwargs.get('cuisine')
        if cuisine and filtered_items:
            # This would require additional logic to filter by cuisine
            # For simplicity, we're just logging it for now
            logger.info(f"Filtering by cuisine: {cuisine}")
        
        # Filter by dietary restriction if specified
        dietary_restriction = kwargs.get('dietary_restriction')
        if dietary_restriction and filtered_items:
            # This would require additional logic to filter by dietary restriction
            # For simplicity, we're just logging it for now
            logger.info(f"Filtering by dietary restriction: {dietary_restriction}")
        
        # Transform the interaction count to a score between 0 and 1
        if filtered_items:
            max_count = max(item.get('interaction_count', 0) for item in filtered_items)
            if max_count > 0:
                for item in filtered_items:
                    item['score'] = item.get('interaction_count', 0) / max_count
        
        return filtered_items
////////////////////////////////////////////////////////////////////////////////

│   ├── content_based_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Content-based recommender implementation.
Uses vector embeddings to find similar content.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories import ContentEmbeddingRepository
from config import DEFAULT_RECOMMENDATION_LIMIT, CONTENT_TYPES, MIN_SIMILARITY_SCORE

logger = logging.getLogger(__name__)

class ContentBasedRecommender(BaseRecommender):
    """
    Content-based recommendation strategy.
    Uses vector embeddings to find similar content based on content features.
    """
    
    def __init__(self):
        """Initialize the content-based recommender."""
        self.repository = ContentEmbeddingRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        min_similarity: float = MIN_SIMILARITY_SCORE,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get content-based recommendations.
        
        Args:
            user_id: Not used for content-based recommendations
            meal_id: The ID of the source meal
            content_type: The type of content ('meal', 'recipe')
            limit: Maximum number of recommendations
            min_similarity: Minimum similarity score threshold
            kwargs: Additional filters (not used for content-based)
            
        Returns:
            List of similar content items
        """
        if not meal_id or not content_type:
            logger.warning("Meal ID and content type required for content-based recommendations")
            return []
        
        if content_type not in CONTENT_TYPES:
            logger.warning(f"Invalid content type: {content_type}")
            return []
        
        # Get the embedding for the source content
        embedding = self.repository.get_embedding(meal_id, content_type)
        if not embedding:
            logger.warning(f"No embedding found for {content_type} with ID {meal_id}")
            return []
        
        # Find similar content
        exclude_ids = [meal_id]  # Exclude the source content
        similar_items = self.repository.find_similar_content(
            embedding, 
            content_type=content_type,
            exclude_ids=exclude_ids,
            limit=limit
        )
        
        # Filter by minimum similarity threshold
        filtered_items = [item for item in similar_items if item.get('similarity', 0) >= min_similarity]
        
        # Rename similarity to score for consistent interface
        for item in filtered_items:
            item['score'] = item.pop('similarity', 0)
        
        return filtered_items
    
    def get_similar_by_ingredients(
        self,
        meal_id: str,
        content_type: str,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT
    ) -> List[Dict[str, Any]]:
        """
        Get meals similar by ingredients.
        
        Args:
            meal_id: The ID of the meal
            content_type: The type of content
            limit: Maximum number of results
            
        Returns:
            List of similar meals
        """
        similar_items = self.repository.get_similar_by_ingredients(
            meal_id=meal_id,
            content_type=content_type,
            limit=limit
        )
        
        # Rename similarity to score for consistent interface
        for item in similar_items:
            item['score'] = item.pop('similarity', 0)
        
        return similar_items
////////////////////////////////////////////////////////////////////////////////

│   ├── hybrid_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Hybrid recommender implementation.
Combines multiple recommendation strategies to provide robust recommendations.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from services.collaborative import CollaborativeRecommender
from services.content_based import ContentBasedRecommender
from services.popularity import PopularityRecommender
from data.repositories import InteractionRepository
from config import DEFAULT_RECOMMENDATION_LIMIT

logger = logging.getLogger(__name__)

class HybridRecommender(BaseRecommender):
    """
    Hybrid recommendation strategy.
    Combines multiple recommendation strategies with fallbacks:
    1. Collaborative filtering (user-based)
    2. Content-based recommendations
    3. Popularity-based recommendations
    """
    
    def __init__(self):
        """Initialize the hybrid recommender with various strategies."""
        self.collaborative_recommender = CollaborativeRecommender()
        self.content_based_recommender = ContentBasedRecommender()
        self.popularity_recommender = PopularityRecommender()
        self.interaction_repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get hybrid recommendations using multiple strategies with fallbacks.
        
        Args:
            user_id: The ID of the user for personalized recommendations
            meal_id: Optional content ID for similar content recommendations
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            kwargs: Additional parameters like cuisine and dietary_restriction
            
        Returns:
            List of recommended items
        """
        recommended_items = []
        
        # Step 1: Try collaborative filtering first (if we have a user_id)
        if user_id:
            collaborative_items = self.collaborative_recommender.get_recommendations(
                user_id=user_id,
                content_type=content_type,
                limit=limit,
                **kwargs
            )
            
            recommended_items.extend(collaborative_items)
            logger.info(f"Collaborative filtering returned {len(collaborative_items)} items")
        
        # Step 2: If we don't have enough recommendations yet, try content-based
        if len(recommended_items) < limit and user_id:
            # Get user's most recent interaction for content-based recommendations
            recent_interactions = self.interaction_repository.get_user_recent_interactions(
                user_id=user_id,
                content_type=content_type,
                limit=1
            )
            
            if recent_interactions:
                recent = recent_interactions[0]
                meal_id = recent['meal_id']
                content_type_for_content = recent['content_type']
                
                # Get additional recommendations based on this content
                # Exclude already recommended items
                existing_ids = [item.get("id") for item in recommended_items]
                
                remaining = limit - len(recommended_items)
                content_based_items = self.content_based_recommender.get_recommendations(
                    meal_id=meal_id,
                    content_type=content_type_for_content,
                    limit=remaining,
                    **kwargs
                )
                
                # Filter out duplicates
                content_based_items = [
                    item for item in content_based_items 
                    if item.get("id") not in existing_ids
                ]
                
                recommended_items.extend(content_based_items)
                logger.info(f"Content-based filtering added {len(content_based_items)} items")
        
        # Step 3: If still not enough, use popularity-based recommendations
        if len(recommended_items) < limit:
            # Exclude already recommended items
            existing_ids = [item.get("id") for item in recommended_items]
            
            remaining = limit - len(recommended_items)
            popularity_items = self.popularity_recommender.get_recommendations(
                content_type=content_type,
                limit=remaining,
                exclude_ids=existing_ids,
                **kwargs
            )
            
            recommended_items.extend(popularity_items)
            logger.info(f"Popularity-based filtering added {len(popularity_items)} items")
        
        # Return the combined recommendations (limited to the requested number)
        return recommended_items[:limit]
////////////////////////////////////////////////////////////////////////////////

│   ├── item_based_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Item-based collaborative filtering recommender implementation.
Recommends items based on co-occurrence patterns with items the user has interacted with.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories import InteractionRepository
from config import DEFAULT_RECOMMENDATION_LIMIT
from data.queries import FIND_SIMILAR_ITEMS
from data.database import execute_query

logger = logging.getLogger(__name__)

class ItemBasedRecommender(BaseRecommender):
    """
    Item-based collaborative filtering recommendation strategy.
    Finds items similar to those the user has already interacted with,
    based on how frequently items co-occur in user interactions.
    """
    
    def __init__(self):
        """Initialize the item-based recommender."""
        self.repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get item-based collaborative filtering recommendations.
        
        Args:
            user_id: The ID of the user
            meal_id: Optional specific meal ID to find similar items for
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            kwargs: Additional filters (cuisine, dietary_restriction)
            
        Returns:
            List of recommended items based on item similarity
        """
        if not user_id and not meal_id:
            logger.warning("Either user_id or meal_id required for item-based recommendations")
            return []
        
        # If meal_id is provided, use it directly to find similar items
        if meal_id:
            return self._get_similar_items(meal_id, content_type, limit)
        
        # Otherwise, use the user's recent interactions to find similar items
        return self._get_user_item_based_recommendations(user_id, content_type, limit, **kwargs)
    
    def _get_similar_items(
        self,
        meal_id: str,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT
    ) -> List[Dict[str, Any]]:
        """
        Find items similar to a specific meal item based on co-occurrence patterns.
        
        Args:
            meal_id: The ID of the meal to find similar items for
            content_type: Optional content type filter
            limit: Maximum number of similar items to return
            
        Returns:
            List of similar items
        """
        # Execute SQL to find items that frequently co-occur with the given meal_id
        params = {
            "meal_id": meal_id,
            "limit": limit
        }
        
        type_filter = ""
        if content_type:
            type_filter = "AND ri2.content_type = :content_type"
            params["content_type"] = content_type
        
        # Format the query with the type filter
        formatted_query = FIND_SIMILAR_ITEMS.format(
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        similar_items = []
        for row in result:
            similar_items.append({
                "id": row[0],
                "content_type": row[1],
                "title": row[2],
                "co_occurrence_count": row[3],
                "score": row[3] / 10.0  # Normalize to 0-1 range (approximate)
            })
        
        return similar_items
    
    def _get_user_item_based_recommendations(
        self,
        user_id: str,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get item-based recommendations for a user by finding items similar
        to those they've already interacted with.
        
        Args:
            user_id: The ID of the user
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            kwargs: Additional filters (cuisine, dietary_restriction)
            
        Returns:
            List of recommended items
        """
        # Get user's recent interactions
        recent_interactions = self.repository.get_user_recent_interactions(
            user_id=user_id,
            content_type=content_type,
            limit=5  # Use top 5 recent interactions
        )
        
        if not recent_interactions:
            logger.info(f"No recent interactions found for user {user_id}")
            return []
        
        all_recommendations = []
        user_items = [interaction["meal_id"] for interaction in recent_interactions]
        
        # For each item the user has interacted with, find similar items
        for interaction in recent_interactions:
            meal_id = interaction["meal_id"]
            similar_items = self._get_similar_items(
                meal_id=meal_id,
                content_type=content_type,
                limit=limit
            )
            
            # Filter out items the user has already interacted with
            filtered_items = [item for item in similar_items if item["id"] not in user_items]
            all_recommendations.extend(filtered_items)
        
        # Remove duplicates by creating a dictionary keyed by item ID
        unique_items = {}
        for item in all_recommendations:
            item_id = item["id"]
            if item_id not in unique_items or item.get("score", 0) > unique_items[item_id].get("score", 0):
                unique_items[item_id] = item
        
        # Sort by score and limit results
        sorted_items = sorted(
            unique_items.values(), 
            key=lambda x: x.get("score", 0), 
            reverse=True
        )
        
        # Apply additional filters if specified
        filtered_items = sorted_items
        
        # Filter by cuisine if specified
        cuisine = kwargs.get('cuisine')
        if cuisine and filtered_items:
            # This would require additional logic to filter by cuisine
            logger.info(f"Filtering by cuisine: {cuisine}")
        
        # Filter by dietary restriction if specified
        dietary_restriction = kwargs.get('dietary_restriction')
        if dietary_restriction and filtered_items:
            # This would require additional logic to filter by dietary restriction
            logger.info(f"Filtering by dietary restriction: {dietary_restriction}")
        
        return filtered_items[:limit]
////////////////////////////////////////////////////////////////////////////////

│   └── popularity_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Popularity-based recommender implementation.
Recommends trending or popular content based on interaction counts.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories import InteractionRepository
from config import DEFAULT_RECOMMENDATION_LIMIT, ALLOWED_TRENDING_WINDOWS

logger = logging.getLogger(__name__)

class PopularityRecommender(BaseRecommender):
    """
    Popularity-based recommendation strategy.
    Recommends trending or popular content based on interaction counts.
    This is a non-personalized strategy that can be used as a fallback.
    """
    
    def __init__(self):
        """Initialize the popularity recommender."""
        self.repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        time_window: str = "day",
        exclude_ids: List[str] = None,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get popularity-based recommendations.
        
        Args:
            user_id: Optional user ID (used for filtering recommendations)
            meal_id: Not used for popularity recommendations
            content_type: Optional content type filter ('meal', 'recipe', 'all')
            limit: Maximum number of recommendations
            time_window: Time window for trending content ('day', 'week', 'month')
            exclude_ids: Optional list of content IDs to exclude
            kwargs: Additional filters (cuisine, dietary_restriction)
            
        Returns:
            List of popular content items
        """
        if time_window not in ALLOWED_TRENDING_WINDOWS:
            logger.warning(f"Invalid time window: {time_window}. Using 'day' instead.")
            time_window = "day"
        
        content_type_filter = content_type if content_type else 'all'
        
        # Get trending content
        popular_items = self.repository.get_trending_content(
            content_type=content_type_filter,
            time_window=time_window,
            limit=limit * 2  # Request more items to account for filtering
        )
        
        # Filter out excluded IDs if specified
        if exclude_ids:
            popular_items = [item for item in popular_items if item["id"] not in exclude_ids]
        
        # Apply additional filters if specified
        filtered_items = popular_items
        
        # Filter by cuisine if specified
        cuisine = kwargs.get('cuisine')
        if cuisine and filtered_items:
            # This would require additional logic to filter by cuisine
            logger.info(f"Filtering by cuisine: {cuisine}")
        
        # Filter by dietary restriction if specified
        dietary_restriction = kwargs.get('dietary_restriction')
        if dietary_restriction and filtered_items:
            # This would require additional logic to filter by dietary restriction
            logger.info(f"Filtering by dietary restriction: {dietary_restriction}")
        
        # Normalize popularity scores to 0-1 range
        if filtered_items:
            max_popularity = max(item.get('popularity', 0) for item in filtered_items)
            if max_popularity > 0:
                for item in filtered_items:
                    item['score'] = item.get('popularity', 0) / max_popularity
        
        return filtered_items[:limit]
    
    def get_cuisine_recommendations(
        self,
        cuisine_id: str,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT
    ) -> List[Dict[str, Any]]:
        """
        Get recommendations for a specific cuisine.
        
        Args:
            cuisine_id: The ID of the cuisine
            limit: Maximum number of recommendations
            
        Returns:
            List of meals in the cuisine
        """
        return self.repository.get_cuisine_recommendations(
            cuisine_id=cuisine_id,
            limit=limit
        )
    
    def get_dietary_recommendations(
        self,
        dietary_restriction_id: str,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT
    ) -> List[Dict[str, Any]]:
        """
        Get recommendations based on dietary restrictions.
        
        Args:
            dietary_restriction_id: The ID of the dietary restriction
            limit: Maximum number of recommendations
            
        Returns:
            List of meals matching the dietary restriction
        """
        return self.repository.get_dietary_recommendations(
            dietary_restriction_id=dietary_restriction_id,
            limit=limit
        )
////////////////////////////////////////////////////////////////////////////////

├── setup
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   └── setup.py

////////////////////////////////////////////////////////////////////////////////
"""
Database setup script.
Creates necessary database tables and indexes for the recommendation system.
"""
import logging
from sqlalchemy import text

from data.database import execute_query, get_transaction, test_connection
from config import EMBEDDING_DIMENSION
from data.queries import (
    ENABLE_PGVECTOR,
    CREATE_CONTENT_EMBEDDINGS_TABLE,
    CREATE_EMBEDDINGS_INDEX,
    CREATE_INTERACTIONS_TABLE,
    CREATE_INTERACTIONS_INDEXES,
    CREATE_CUISINE_TABLE,
    CREATE_DIETARY_RESTRICTION_TABLE,
    CREATE_USER_DIETARY_PREFERENCE_TABLE,
    CREATE_MEAL_DIETARY_RESTRICTION_TABLE,
    CREATE_INGREDIENT_TABLE,
    CREATE_MEAL_INGREDIENT_TABLE,
    INSERT_DEFAULT_CUISINES,
    INSERT_DEFAULT_DIETARY_RESTRICTIONS
)

logger = logging.getLogger(__name__)

def create_recommendation_tables():
    """Create all necessary tables and indexes for the recommendation system."""
    logger.info("Creating recommendation database tables and indexes...")
    
    try:
        with get_transaction() as conn:
            # Enable pgvector extension
            conn.execute(text(ENABLE_PGVECTOR))
            
            # Create a separate table for content embeddings
            # Format the query with the embedding dimension
            formatted_embeddings_table = CREATE_CONTENT_EMBEDDINGS_TABLE.format(
                embedding_dimension=EMBEDDING_DIMENSION
            )
            conn.execute(text(formatted_embeddings_table))
            
            # Create index for vector search
            conn.execute(text(CREATE_EMBEDDINGS_INDEX))
            
            # Create interactions table
            conn.execute(text(CREATE_INTERACTIONS_TABLE))
            
            # Create indexes for quick lookups
            conn.execute(text(CREATE_INTERACTIONS_INDEXES))
            
            # Create reference tables
            conn.execute(text(CREATE_CUISINE_TABLE))
            conn.execute(text(CREATE_DIETARY_RESTRICTION_TABLE))
            conn.execute(text(CREATE_USER_DIETARY_PREFERENCE_TABLE))
            conn.execute(text(CREATE_MEAL_DIETARY_RESTRICTION_TABLE))
            conn.execute(text(CREATE_INGREDIENT_TABLE))
            conn.execute(text(CREATE_MEAL_INGREDIENT_TABLE))
            
            # Insert default reference data
            conn.execute(text(INSERT_DEFAULT_CUISINES))
            conn.execute(text(INSERT_DEFAULT_DIETARY_RESTRICTIONS))
        
        logger.info("Database tables and indexes created successfully")
        return True
    except Exception as e:
        logger.error(f"Error creating database tables: {e}")
        return False

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # Test database connection
    if test_connection():
        # Create tables
        success = create_recommendation_tables()
        if success:
            logger.info("Database setup completed successfully")
        else:
            logger.error("Database setup failed")
    else:
        logger.error("Database connection test failed. Check your DATABASE_URL in .env file.")
////////////////////////////////////////////////////////////////////////////////

├── start.sh

////////////////////////////////////////////////////////////////////////////////
#!/bin/bash
# start.sh
# Startup script for the meal recommendation service

# Set the directory to the script's location
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd $DIR

# Function to check if a Python module exists
module_exists() {
    python3 -c "import $1" 2>/dev/null
    return $?
}

# Check for required Python packages
echo "Checking for required Python packages..."
required_packages=(
    "fastapi" 
    "uvicorn" 
    "sqlalchemy" 
    "psycopg2-binary" 
    "sentence-transformers" 
    "schedule" 
    "python-dotenv"
    "numpy"
)
missing_packages=()

for package in "${required_packages[@]}"; do
    if ! module_exists $package; then
        missing_packages+=($package)
    fi
done

# Install missing packages if any
if [ ${#missing_packages[@]} -ne 0 ]; then
    echo "Installing missing packages: ${missing_packages[*]}"
    pip install "${missing_packages[@]}"
fi

# Check if pgvector extension is installed in PostgreSQL
echo "Checking pgvector extension..."
python3 -c "
from data.database import execute_query
try:
    result = execute_query('SELECT COUNT(*) FROM pg_extension WHERE extname = \\'vector\\'')
    count = result.fetchone()[0]
    if count == 0:
        print('pgvector extension is not installed in the database.')
        print('You may need to run: CREATE EXTENSION vector;')
    else:
        print('pgvector extension is properly installed.')
except Exception as e:
    print(f'Error checking pgvector extension: {e}')
"

# Create necessary database tables
echo "Setting up database tables..."
python3 -m setup

# Generate initial embeddings
echo "Generating initial embeddings..."
python3 -c "
from embeddings.generator import EmbeddingGenerator
generator = EmbeddingGenerator()
result = generator.generate_all_embeddings()
print(f'Initial embeddings generated: {result}')
"

# Start the API server
echo "Starting API server..."
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
////////////////////////////////////////////////////////////////////////////////

└── util
    ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

    └── scheduler.py

////////////////////////////////////////////////////////////////////////////////
"""
Background task scheduler.
Runs periodic tasks for the recommendation system.
"""
import schedule
import time
import threading
import logging

from embeddings.embedding_generator import EmbeddingGenerator
from config.settings import EMBEDDING_GENERATION_INTERVAL, SCHEDULER_SLEEP_INTERVAL

logger = logging.getLogger(__name__)

def run_embedding_generation():
    """Generate embeddings for content that doesn't have them yet."""
    logger.info("Running scheduled embedding generation...")
    try:
        generator = EmbeddingGenerator()
        result = generator.generate_all_embeddings()
        logger.info(f"Embedding generation completed: {result}")
    except Exception as e:
        logger.error(f"Error during embedding generation: {e}")

def run_scheduler():
    """Run the scheduler loop to execute pending tasks."""
    while True:
        schedule.run_pending()
        time.sleep(SCHEDULER_SLEEP_INTERVAL)

def start_scheduler():
    """Configure and start the scheduler in a background thread."""
    # Schedule embedding generation job
    schedule.every(EMBEDDING_GENERATION_INTERVAL).minutes.do(run_embedding_generation)
    
    logger.info(f"Scheduled embedding generation every {EMBEDDING_GENERATION_INTERVAL} minutes")
    
    # Start scheduler in background thread
    scheduler_thread = threading.Thread(target=run_scheduler)
    scheduler_thread.daemon = True
    scheduler_thread.start()
    logger.info("Scheduler started in background thread")
    
    return scheduler_thread

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Run immediately on first execution
    run_embedding_generation()
    
    # Start scheduler
    thread = start_scheduler()
    
    logger.info("Scheduler running. Press Ctrl+C to exit.")
    try:
        # Keep the main thread alive
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Scheduler stopped.")
////////////////////////////////////////////////////////////////////////////////

