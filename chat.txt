Directory Tree: ./
================================================================================

├── README.md

////////////////////////////////////////////////////////////////////////////////
# Python Recommendation Service

A Python-based recommendation service designed to integrate with Node.js applications REST service without modifying existing Prisma schema which made by the node js application service.

## Overview

This recommendation service provides multiple recommendation strategies with fallbacks:
1. **User-based collaborative filtering** based on similar users' interactions on meals
2. **Item-based collaborative filtering** based on co-occurrence patterns 
3. **Content-based recommendations** using text embeddings of meals content 
4. **Popularity-based recommendations** as a last resort

The service is highly configurable and allows switching between recommendation algorithms based on your needs. In this project I will be mixing scores of different returned values of the above approaches

## System Architecture

The service is built with FastAPI and uses PostgreSQL with pgvector extension for vector similarity search. It stores embeddings and interaction data in separate tables without modifying your existing database schema.

## Features

### Multiple Recommendation Strategies

The service implements several recommendation algorithms:

- **Hybrid Recommender**: Combines multiple strategies with fallbacks for robust recommendations
- **User-Based Collaborative Filtering**: Finds users with similar tastes and recommends what they liked
- **Item-Based Collaborative Filtering**: Recommends items similar to those the user has interacted with
- **Content-Based Recommendations**: Uses vector embeddings to find similar content
- **Popularity-Based Recommendations**: Recommends trending content as a fallback

### Flexible API

- Choose which recommendation strategy to use via API parameters
- Filter by content type
- Adjust time windows for trending content
- Get category-based recommendations

### Background Processing

- Automatic embedding generation for new content
- Scheduled tasks for keeping recommendations fresh

## Setup Instructions

### Prerequisites

- Python 3.8+
- PostgreSQL with pgvector extension
- Node.js (for client integration)

### Installation

1. Install required Python packages:

```bash
pip install fastapi uvicorn sqlalchemy psycopg2-binary sentence-transformers pandas scikit-learn numpy python-dotenv schedule
```

2. Make the startup script executable:

```bash
chmod +x start_recommendation_service.sh
```

3. Update your .env file with the DATABASE_URL:

```
DATABASE_URL=postgresql://username:password@localhost:5432/yourdb
```

### Starting the Service

Use the provided startup script:

```bash
./start_recommendation_service.sh
```

This will:
- Check for and install required packages
- Create necessary database tables if they don't exist
- Generate initial embeddings for content
- Start the background scheduler
- Start the FastAPI server

## API Endpoints

### User Recommendations

```
GET /recommend/user/{user_id}?content_type=post&limit=10&recommendation_type=hybrid
```

Get personalized recommendations for a user with options to use hybrid, user-based, or item-based algorithms.

### Similar Content

```
GET /recommend/similar/{content_type}/{meal_id}?limit=10&similarity_method=content
```

Get content similar to the specified item. Choose between content-based similarity (using embeddings) or interaction-based similarity (based on co-occurrence patterns).

### Trending Content

```
GET /trending/{content_type}?time_window=day&limit=10
```

Get trending content based on recent interactions.

### Category Recommendations

```
GET /recommend/category/{category_id}?limit=10
```

Get communities in the specified category.

### Record Interactions

```
POST /interactions

{
  "user_id": "123",
  "meal_id": "456",
  "content_type": "post",
  "interaction_type": "view"
}
```

Record user interactions with content.

## Integration with Node.js

Use the provided recommendation-client.js:

```javascript
const recommendations = require('./recommendation-service/client/recommendation-client');

// Get user recommendations with hybrid algorithm
async function getUserFeed(userId) {
  const items = await recommendations.getUserRecommendations(userId, 'post', 20, 'hybrid');
  
  // Fetch additional data using Prisma if needed
  const posts = await prisma.post.findMany({
    where: {
      id: { in: items.map(item => item.id) }
    },
    include: {
      author: true,
      community: true
    }
  });
  
  return posts;
}

// Get similar content using item-based collaborative filtering
async function getSimilarPosts(postId) {
  return await recommendations.getSimilarContent('post', postId, 5, 'interaction');
}

// Record a view
async function recordView(userId, postId) {
  await recommendations.recordInteraction(userId, postId, 'post', 'view');
  // Other application logic...
}

// Get trending content
async function getTrendingPosts() {
  return await recommendations.getTrendingContent('post', 'week', 10);
}
```

## Customization

### Configuration Settings

Edit `config/settings.py` to customize:

- Database connection parameters
- API settings
- Embedding model and dimension
- Default recommendation limits
- Scheduler intervals

### Recommendation Algorithms

You can customize the recommendation algorithms by:

1. Adjusting parameters in the API requests
2. Modifying the implementation in the respective strategy files
3. Creating new recommender classes that implement the BaseRecommender interface

### Embedding Model

You can change the embedding model in `config/settings.py`:

```python
# Default model
EMBEDDING_MODEL = "all-MiniLM-L6-v2"

# For better multilingual support
# EMBEDDING_MODEL = "paraphrase-multilingual-MiniLM-L12-v2"

# For better semantic understanding but slower processing
# EMBEDDING_MODEL = "all-mpnet-base-v2"
```

## Performance Considerations

- The vector index is essential for fast similarity search
- Background embedding generation prevents API slowdowns
- Queries include appropriate indexes and limits

## Troubleshooting

### Connection Issues

If you encounter database connection issues:

```bash
python -m data.database
```

This will test the database connection and report any errors.

### Missing Embeddings

If content isn't showing up in recommendations:

```bash
python -m embeddings.embedding_generator
```

This will generate embeddings for any missing content.

### API Issues

You can check the API documentation at:

```
http://localhost:8000/docs
```

This provides an interactive OpenAPI interface for testing endpoints.
////////////////////////////////////////////////////////////////////////////////

├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

├── api
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////
"""
Recommendation Service API Package.
"""
# This file enables the directory to be imported as a package
////////////////////////////////////////////////////////////////////////////////

│   ├── api.py

////////////////////////////////////////////////////////////////////////////////
"""
Main FastAPI application module.
Integrates all API routes and serves as the entry point for the meal recommendation service.
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from config.settings import API_HOST, API_PORT, RELOAD
from api import user_recommendations, similar_meal_routes, trending_routes, interactions

def create_app():
    """Create and configure the FastAPI application."""
    app = FastAPI(
        title="Meal Recommendation Service",
        description="API for personalized meal recommendations",
        version="1.0.0"
    )
    
    # Add CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Allow all origins in development
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Include all route modules
    app.include_router(user_recommendations.router)
    app.include_router(similar_meal_routes.router)
    app.include_router(trending_routes.router)
    app.include_router(interactions.router)
    
    @app.get("/", tags=["status"])
    def read_root():
        """Root endpoint for API status check."""
        return {"status": "Meal recommendation service is running"}
    
    return app

app = create_app()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app:app", 
        host=API_HOST, 
        port=API_PORT,
        reload=RELOAD
    )
////////////////////////////////////////////////////////////////////////////////

│   ├── base.py

////////////////////////////////////////////////////////////////////////////////
"""
API base module.
Contains common API dependencies and configurations for meal recommendations.
"""
from fastapi import Depends, HTTPException, status
from sqlalchemy import text
from typing import Generator

from data.database import get_connection
from config.settings import CONTENT_TYPES

def get_db():
    """Database connection dependency."""
    with get_connection() as conn:
        yield conn

def validate_content_type(content_type: str, allow_all: bool = False) -> str:
    """
    Validate meal content type parameter.
    
    Args:
        content_type: The content type to validate
        allow_all: Whether to allow 'all' as a valid content type
        
    Returns:
        The validated content type
        
    Raises:
        HTTPException: If the content type is invalid
    """
    valid_types = CONTENT_TYPES.copy()
    if allow_all:
        valid_types.append('all')
        
    if content_type not in valid_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Content type must be one of: {', '.join(valid_types)}"
        )
    
    return content_type
////////////////////////////////////////////////////////////////////////////////

│   ├── by_preference.py

////////////////////////////////////////////////////////////////////////////////
"""
User meal recommendations API routes.
Endpoints for personalized meal recommendations.
"""
from fastapi import APIRouter, Depends, Query, HTTPException, status
from typing import Optional, List, Dict, Any

from base import get_db, validate_content_type
from services.hybrid_recommender import HybridRecommender
from services.item_based_recommender import ItemBasedRecommender
from services.collaborative_recommender import CollaborativeRecommender
from config.settings import DEFAULT_RECOMMENDATION_LIMIT, CONTENT_TYPES

router = APIRouter(prefix="/recommend", tags=["recommendations"])

@router.get("/user/{user_id}")
def get_user_recommendations(
    user_id: str,
    content_type: Optional[str] = Query(None, description="Filter by content type (meal, recipe)"),
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of recommendations"),
    recommendation_type: str = Query("hybrid", description="Recommendation algorithm to use (hybrid, item-based, user-based)"),
    cuisine: Optional[str] = Query(None, description="Filter by cuisine type"),
    dietary_restriction: Optional[str] = Query(None, description="Filter by dietary restriction"),
    db=Depends(get_db)
):
    """
    Get personalized meal recommendations for a user.
    
    Uses a hybrid approach with multiple recommendation strategies:
    1. Collaborative filtering based on similar users
    2. Content-based recommendations using recent interactions
    3. Popularity-based recommendations as fallback
    
    Parameters:
    - user_id: The ID of the user
    - content_type: Optional filter by content type ('meal', 'recipe')
    - limit: Maximum number of recommendations to return
    - recommendation_type: Algorithm to use (hybrid, item-based, user-based)
    - cuisine: Optional filter by cuisine type
    - dietary_restriction: Optional filter by dietary restriction
    
    Returns:
    - List of recommended meals
    """
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    # Choose the recommendation strategy based on the type parameter
    if recommendation_type == "hybrid":
        recommender = HybridRecommender()
    elif recommendation_type == "item-based":
        recommender = ItemBasedRecommender()
    elif recommendation_type == "user-based":
        recommender = CollaborativeRecommender()
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid recommendation type. Must be 'hybrid', 'item-based', or 'user-based'."
        )
    
    # Get recommendations
    recommended_items = recommender.get_recommendations(
        user_id=user_id,
        content_type=content_type,
        limit=limit,
        cuisine=cuisine,
        dietary_restriction=dietary_restriction
    )
    
    return recommender.format_recommendations(recommended_items)
////////////////////////////////////////////////////////////////////////////////

│   ├── interactions.py

////////////////////////////////////////////////////////////////////////////////
"""
User meal interaction API routes.
Endpoints for tracking user interactions with meals.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from typing import Optional

from base import get_db, validate_content_type
from data.repositories.interaction_repository import InteractionRepository

router = APIRouter(tags=["interactions"])

class InteractionCreate(BaseModel):
    """Request model for creating a meal interaction record."""
    user_id: str
    meal_id: str
    content_type: str
    interaction_type: str

@router.post("/interactions")
def record_interaction(
    interaction: InteractionCreate,
    db=Depends(get_db)
):
    """
    Record a user interaction with a meal.
    
    Parameters:
    - user_id: ID of the user
    - meal_id: ID of the meal
    - content_type: Type of content ('meal' or 'recipe')
    - interaction_type: Type of interaction ('view', 'like', 'save', 'cook')
    
    Returns:
    - Status confirmation
    """
    # Validate content type
    try:
        validate_content_type(interaction.content_type)
    except HTTPException as e:
        raise e
    
    # Record the interaction
    repository = InteractionRepository()
    success = repository.record_interaction(
        user_id=interaction.user_id,
        meal_id=interaction.meal_id,
        content_type=interaction.content_type,
        interaction_type=interaction.interaction_type
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to record interaction"
        )
    
    return {"status": "recorded"}

@router.get("/user/{user_id}/history")
def get_user_meal_history(
    user_id: str,
    content_type: Optional[str] = None,
    limit: int = 10,
    db=Depends(get_db)
):
    """
    Get a user's meal interaction history.
    
    Parameters:
    - user_id: ID of the user
    - content_type: Optional filter by content type ('meal' or 'recipe')
    - limit: Maximum number of history items to return
    
    Returns:
    - List of user's recent meal interactions
    """
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    repository = InteractionRepository()
    history = repository.get_user_recent_interactions(
        user_id=user_id,
        content_type=content_type,
        limit=limit
    )
    
    return {"history": history}

@router.get("/user/{user_id}/dietary-preferences")
def get_user_dietary_preferences(
    user_id: str,
    db=Depends(get_db)
):
    """
    Get a user's dietary preferences.
    
    Parameters:
    - user_id: ID of the user
    
    Returns:
    - List of user's dietary preferences
    """
    repository = InteractionRepository()
    preferences = repository.get_user_dietary_preferences(user_id)
    
    return {"dietary_preferences": preferences}

@router.post("/user/{user_id}/dietary-preferences")
def set_user_dietary_preference(
    user_id: str,
    dietary_restriction_id: int,
    db=Depends(get_db)
):
    """
    Add a dietary preference for a user.
    
    Parameters:
    - user_id: ID of the user
    - dietary_restriction_id: ID of the dietary restriction
    
    Returns:
    - Status confirmation
    """
    repository = InteractionRepository()
    success = repository.add_user_dietary_preference(
        user_id=user_id,
        dietary_restriction_id=dietary_restriction_id
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to add dietary preference"
        )
    
    return {"status": "added"}
////////////////////////////////////////////////////////////////////////////////

│   ├── similar.py

////////////////////////////////////////////////////////////////////////////////
"""
Similar meal API routes.
Endpoints for finding meals similar to a given item.
"""
from fastapi import APIRouter, Depends, Query, HTTPException, status
from typing import Optional

from base import get_db, validate_content_type
from services.content_based_recommender import ContentBasedRecommender
from services.item_based_recommender import ItemBasedRecommender
from config.settings import DEFAULT_RECOMMENDATION_LIMIT

router = APIRouter(prefix="/recommend", tags=["recommendations"])

@router.get("/similar/{content_type}/{meal_id}")
def get_similar_meals(
    content_type: str,
    meal_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of similar meals"),
    similarity_method: str = Query("content", description="Method to determine similarity (content, interaction, ingredient)"),
    db=Depends(get_db)
):
    """
    Get meals similar to the specified item.
    
    Supports three similarity methods:
    - content: Uses vector embeddings to find similar meals based on textual features
    - interaction: Uses co-occurrence patterns to find meals that users interact with together
    - ingredient: Uses common ingredients to find similar meals
    
    Parameters:
    - content_type: Type of content ('meal' or 'recipe')
    - meal_id: ID of the meal
    - limit: Maximum number of similar meals to return
    - similarity_method: Method to determine similarity (content, interaction, ingredient)
    
    Returns:
    - List of similar meals with similarity scores
    """
    # Validate content type
    content_type = validate_content_type(content_type)
    
    # Choose similarity method
    if similarity_method == "content":
        # Content-based similarity using vector embeddings
        recommender = ContentBasedRecommender()
    elif similarity_method == "interaction":
        # Item-based collaborative filtering using interaction patterns
        recommender = ItemBasedRecommender()
    elif similarity_method == "ingredient":
        # Ingredient-based similarity
        recommender = ContentBasedRecommender()
        return recommender.get_similar_by_ingredients(
            meal_id=meal_id,
            content_type=content_type,
            limit=limit
        )
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid similarity method. Must be 'content', 'interaction', or 'ingredient'."
        )
    
    # Get similar meals
    similar_items = recommender.get_recommendations(
        meal_id=meal_id,
        content_type=content_type,
        limit=limit
    )
    
    return recommender.format_recommendations(similar_items)
////////////////////////////////////////////////////////////////////////////////

│   └── trending.py

////////////////////////////////////////////////////////////////////////////////
"""
Trending meals and cuisine-based recommendation API routes.
Endpoints for trending meals and cuisine-based recommendations.
"""
from fastapi import APIRouter, Depends, Query, HTTPException, status
from typing import Optional

from base import get_db, validate_content_type
from services.popularity_recommender import PopularityRecommender
from config.settings import DEFAULT_RECOMMENDATION_LIMIT, ALLOWED_TRENDING_WINDOWS

router = APIRouter(tags=["recommendations"])

@router.get("/trending/{content_type}")
def get_trending_meals(
    content_type: str,
    time_window: str = Query("day", description="Time window for trending meals"),
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db=Depends(get_db)
):
    """
    Get trending meals based on recent interactions.
    
    Parameters:
    - content_type: Type of content ('meal', 'recipe', or 'all')
    - time_window: Time window to consider ('day', 'week', 'month')
    - limit: Maximum number of meals to return
    
    Returns:
    - List of trending meals with popularity scores
    """
    # Validate content type (allowing 'all' as a valid option)
    content_type = validate_content_type(content_type, allow_all=True)
    
    # Validate time window
    if time_window not in ALLOWED_TRENDING_WINDOWS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Time window must be one of: {', '.join(ALLOWED_TRENDING_WINDOWS)}"
        )
    
    # Get trending meals
    recommender = PopularityRecommender()
    trending_items = recommender.get_recommendations(
        content_type=content_type,
        time_window=time_window,
        limit=limit
    )
    
    return recommender.format_recommendations(trending_items)

@router.get("/recommend/cuisine/{cuisine_id}")
def get_cuisine_recommendations(
    cuisine_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db=Depends(get_db)
):
    """
    Get meal recommendations based on cuisine.
    
    Parameters:
    - cuisine_id: ID of the cuisine
    - limit: Maximum number of meals to return
    
    Returns:
    - List of meals in the specified cuisine
    """
    recommender = PopularityRecommender()
    cuisine_items = recommender.get_cuisine_recommendations(
        cuisine_id=cuisine_id,
        limit=limit
    )
    
    return recommender.format_recommendations(cuisine_items)

@router.get("/recommend/dietary/{dietary_restriction_id}")
def get_dietary_recommendations(
    dietary_restriction_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of items"),
    db=Depends(get_db)
):
    """
    Get meal recommendations based on dietary restrictions.
    
    Parameters:
    - dietary_restriction_id: ID of the dietary restriction
    - limit: Maximum number of meals to return
    
    Returns:
    - List of meals that match the dietary restriction
    """
    recommender = PopularityRecommender()
    dietary_items = recommender.get_dietary_recommendations(
        dietary_restriction_id=dietary_restriction_id,
        limit=limit
    )
    
    return recommender.format_recommendations(dietary_items)
"""
////////////////////////////////////////////////////////////////////////////////

├── chat.txt

////////////////////////////////////////////////////////////////////////////////
Directory Tree: ./
================================================================================

├── README.md

////////////////////////////////////////////////////////////////////////////////
# Python Recommendation Service

A Python-based recommendation service designed to integrate with Node.js applications REST service without modifying existing Prisma schema which made by the node js application service.

## Overview

This recommendation service provides multiple recommendation strategies with fallbacks:
1. **User-based collaborative filtering** based on similar users' interactions on meals
2. **Item-based collaborative filtering** based on co-occurrence patterns 
3. **Content-based recommendations** using text embeddings of meals content 
4. **Popularity-based recommendations** as a last resort

The service is highly configurable and allows switching between recommendation algorithms based on your needs. In this project I will be mixing scores of different returned values of the above approaches

## System Architecture

The service is built with FastAPI and uses PostgreSQL with pgvector extension for vector similarity search. It stores embeddings and interaction data in separate tables without modifying your existing database schema.

## Features

### Multiple Recommendation Strategies

The service implements several recommendation algorithms:

- **Hybrid Recommender**: Combines multiple strategies with fallbacks for robust recommendations
- **User-Based Collaborative Filtering**: Finds users with similar tastes and recommends what they liked
- **Item-Based Collaborative Filtering**: Recommends items similar to those the user has interacted with
- **Content-Based Recommendations**: Uses vector embeddings to find similar content
- **Popularity-Based Recommendations**: Recommends trending content as a fallback

### Flexible API

- Choose which recommendation strategy to use via API parameters
- Filter by content type
- Adjust time windows for trending content
- Get category-based recommendations

### Background Processing

- Automatic embedding generation for new content
- Scheduled tasks for keeping recommendations fresh

## Setup Instructions

### Prerequisites

- Python 3.8+
- PostgreSQL with pgvector extension
- Node.js (for client integration)

### Installation

1. Install required Python packages:

```bash
pip install fastapi uvicorn sqlalchemy psycopg2-binary sentence-transformers pandas scikit-learn numpy python-dotenv schedule
```

2. Make the startup script executable:

```bash
chmod +x start_recommendation_service.sh
```

3. Update your .env file with the DATABASE_URL:

```
DATABASE_URL=postgresql://username:password@localhost:5432/yourdb
```

### Starting the Service

Use the provided startup script:

```bash
./start_recommendation_service.sh
```

This will:
- Check for and install required packages
- Create necessary database tables if they don't exist
- Generate initial embeddings for content
- Start the background scheduler
- Start the FastAPI server

## API Endpoints

### User Recommendations

```
GET /recommend/user/{user_id}?content_type=post&limit=10&recommendation_type=hybrid
```

Get personalized recommendations for a user with options to use hybrid, user-based, or item-based algorithms.

### Similar Content

```
GET /recommend/similar/{content_type}/{meal_id}?limit=10&similarity_method=content
```

Get content similar to the specified item. Choose between content-based similarity (using embeddings) or interaction-based similarity (based on co-occurrence patterns).

### Trending Content

```
GET /trending/{content_type}?time_window=day&limit=10
```

Get trending content based on recent interactions.

### Category Recommendations

```
GET /recommend/category/{category_id}?limit=10
```

Get communities in the specified category.

### Record Interactions

```
POST /interactions

{
  "user_id": "123",
  "meal_id": "456",
  "content_type": "post",
  "interaction_type": "view"
}
```

Record user interactions with content.

## Integration with Node.js

Use the provided recommendation-client.js:

```javascript
const recommendations = require('./recommendation-service/client/recommendation-client');

// Get user recommendations with hybrid algorithm
async function getUserFeed(userId) {
  const items = await recommendations.getUserRecommendations(userId, 'post', 20, 'hybrid');
  
  // Fetch additional data using Prisma if needed
  const posts = await prisma.post.findMany({
    where: {
      id: { in: items.map(item => item.id) }
    },
    include: {
      author: true,
      community: true
    }
  });
  
  return posts;
}

// Get similar content using item-based collaborative filtering
async function getSimilarPosts(postId) {
  return await recommendations.getSimilarContent('post', postId, 5, 'interaction');
}

// Record a view
async function recordView(userId, postId) {
  await recommendations.recordInteraction(userId, postId, 'post', 'view');
  // Other application logic...
}

// Get trending content
async function getTrendingPosts() {
  return await recommendations.getTrendingContent('post', 'week', 10);
}
```

## Customization

### Configuration Settings

Edit `config/settings.py` to customize:

- Database connection parameters
- API settings
- Embedding model and dimension
- Default recommendation limits
- Scheduler intervals

### Recommendation Algorithms

You can customize the recommendation algorithms by:

1. Adjusting parameters in the API requests
2. Modifying the implementation in the respective strategy files
3. Creating new recommender classes that implement the BaseRecommender interface

### Embedding Model

You can change the embedding model in `config/settings.py`:

```python
# Default model
EMBEDDING_MODEL = "all-MiniLM-L6-v2"

# For better multilingual support
# EMBEDDING_MODEL = "paraphrase-multilingual-MiniLM-L12-v2"

# For better semantic understanding but slower processing
# EMBEDDING_MODEL = "all-mpnet-base-v2"
```

## Performance Considerations

- The vector index is essential for fast similarity search
- Background embedding generation prevents API slowdowns
- Queries include appropriate indexes and limits

## Troubleshooting

### Connection Issues

If you encounter database connection issues:

```bash
python -m data.database
```

This will test the database connection and report any errors.

### Missing Embeddings

If content isn't showing up in recommendations:

```bash
python -m embeddings.embedding_generator
```

This will generate embeddings for any missing content.

### API Issues

You can check the API documentation at:

```
http://localhost:8000/docs
```

This provides an interactive OpenAPI interface for testing endpoints.
////////////////////////////////////////////////////////////////////////////////

├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

├── api
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////
"""
Recommendation Service API Package.
"""
# This file enables the directory to be imported as a package
////////////////////////////////////////////////////////////////////////////////

│   ├── api.py

////////////////////////////////////////////////////////////////////////////////
"""
Main FastAPI application module.
Integrates all API routes and serves as the entry point for the meal recommendation service.
"""
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from config.settings import API_HOST, API_PORT, RELOAD
from api import user_recommendations, similar_meal_routes, trending_routes, interactions

def create_app():
    """Create and configure the FastAPI application."""
    app = FastAPI(
        title="Meal Recommendation Service",
        description="API for personalized meal recommendations",
        version="1.0.0"
    )
    
    # Add CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],  # Allow all origins in development
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Include all route modules
    app.include_router(user_recommendations.router)
    app.include_router(similar_meal_routes.router)
    app.include_router(trending_routes.router)
    app.include_router(interactions.router)
    
    @app.get("/", tags=["status"])
    def read_root():
        """Root endpoint for API status check."""
        return {"status": "Meal recommendation service is running"}
    
    return app

app = create_app()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "app:app", 
        host=API_HOST, 
        port=API_PORT,
        reload=RELOAD
    )
////////////////////////////////////////////////////////////////////////////////

│   ├── base.py

////////////////////////////////////////////////////////////////////////////////
"""
API base module.
Contains common API dependencies and configurations for meal recommendations.
"""
from fastapi import Depends, HTTPException, status
from sqlalchemy import text
from typing import Generator

from data.database import get_connection
from config.settings import CONTENT_TYPES

def get_db():
    """Database connection dependency."""
    with get_connection() as conn:
        yield conn

def validate_content_type(content_type: str, allow_all: bool = False) -> str:
    """
    Validate meal content type parameter.
    
    Args:
        content_type: The content type to validate
        allow_all: Whether to allow 'all' as a valid content type
        
    Returns:
        The validated content type
        
    Raises:
        HTTPException: If the content type is invalid
    """
    valid_types = CONTENT_TYPES.copy()
    if allow_all:
        valid_types.append('all')
        
    if content_type not in valid_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Content type must be one of: {', '.join(valid_types)}"
        )
    
    return content_type
////////////////////////////////////////////////////////////////////////////////

│   ├── by_preference.py

////////////////////////////////////////////////////////////////////////////////
"""
User meal recommendations API routes.
Endpoints for personalized meal recommendations.
"""
from fastapi import APIRouter, Depends, Query, HTTPException, status
from typing import Optional, List, Dict, Any

from base import get_db, validate_content_type
from services.hybrid_recommender import HybridRecommender
from services.item_based_recommender import ItemBasedRecommender
from services.collaborative_recommender import CollaborativeRecommender
from config.settings import DEFAULT_RECOMMENDATION_LIMIT, CONTENT_TYPES

router = APIRouter(prefix="/recommend", tags=["recommendations"])

@router.get("/user/{user_id}")
def get_user_recommendations(
    user_id: str,
    content_type: Optional[str] = Query(None, description="Filter by content type (meal, recipe)"),
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of recommendations"),
    recommendation_type: str = Query("hybrid", description="Recommendation algorithm to use (hybrid, item-based, user-based)"),
    cuisine: Optional[str] = Query(None, description="Filter by cuisine type"),
    dietary_restriction: Optional[str] = Query(None, description="Filter by dietary restriction"),
    db=Depends(get_db)
):
    """
    Get personalized meal recommendations for a user.
    
    Uses a hybrid approach with multiple recommendation strategies:
    1. Collaborative filtering based on similar users
    2. Content-based recommendations using recent interactions
    3. Popularity-based recommendations as fallback
    
    Parameters:
    - user_id: The ID of the user
    - content_type: Optional filter by content type ('meal', 'recipe')
    - limit: Maximum number of recommendations to return
    - recommendation_type: Algorithm to use (hybrid, item-based, user-based)
    - cuisine: Optional filter by cuisine type
    - dietary_restriction: Optional filter by dietary restriction
    
    Returns:
    - List of recommended meals
    """
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    # Choose the recommendation strategy based on the type parameter
    if recommendation_type == "hybrid":
        recommender = HybridRecommender()
    elif recommendation_type == "item-based":
        recommender = ItemBasedRecommender()
    elif recommendation_type == "user-based":
        recommender = CollaborativeRecommender()
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid recommendation type. Must be 'hybrid', 'item-based', or 'user-based'."
        )
    
    # Get recommendations
    recommended_items = recommender.get_recommendations(
        user_id=user_id,
        content_type=content_type,
        limit=limit,
        cuisine=cuisine,
        dietary_restriction=dietary_restriction
    )
    
    return recommender.format_recommendations(recommended_items)
////////////////////////////////////////////////////////////////////////////////

│   ├── interactions.py

////////////////////////////////////////////////////////////////////////////////
"""
User meal interaction API routes.
Endpoints for tracking user interactions with meals.
"""
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from typing import Optional

from base import get_db, validate_content_type
from data.repositories.interaction_repository import InteractionRepository

router = APIRouter(tags=["interactions"])

class InteractionCreate(BaseModel):
    """Request model for creating a meal interaction record."""
    user_id: str
    meal_id: str
    content_type: str
    interaction_type: str

@router.post("/interactions")
def record_interaction(
    interaction: InteractionCreate,
    db=Depends(get_db)
):
    """
    Record a user interaction with a meal.
    
    Parameters:
    - user_id: ID of the user
    - meal_id: ID of the meal
    - content_type: Type of content ('meal' or 'recipe')
    - interaction_type: Type of interaction ('view', 'like', 'save', 'cook')
    
    Returns:
    - Status confirmation
    """
    # Validate content type
    try:
        validate_content_type(interaction.content_type)
    except HTTPException as e:
        raise e
    
    # Record the interaction
    repository = InteractionRepository()
    success = repository.record_interaction(
        user_id=interaction.user_id,
        meal_id=interaction.meal_id,
        content_type=interaction.content_type,
        interaction_type=interaction.interaction_type
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to record interaction"
        )
    
    return {"status": "recorded"}

@router.get("/user/{user_id}/history")
def get_user_meal_history(
    user_id: str,
    content_type: Optional[str] = None,
    limit: int = 10,
    db=Depends(get_db)
):
    """
    Get a user's meal interaction history.
    
    Parameters:
    - user_id: ID of the user
    - content_type: Optional filter by content type ('meal' or 'recipe')
    - limit: Maximum number of history items to return
    
    Returns:
    - List of user's recent meal interactions
    """
    # Validate content type if provided
    if content_type:
        content_type = validate_content_type(content_type)
    
    repository = InteractionRepository()
    history = repository.get_user_recent_interactions(
        user_id=user_id,
        content_type=content_type,
        limit=limit
    )
    
    return {"history": history}

@router.get("/user/{user_id}/dietary-preferences")
def get_user_dietary_preferences(
    user_id: str,
    db=Depends(get_db)
):
    """
    Get a user's dietary preferences.
    
    Parameters:
    - user_id: ID of the user
    
    Returns:
    - List of user's dietary preferences
    """
    repository = InteractionRepository()
    preferences = repository.get_user_dietary_preferences(user_id)
    
    return {"dietary_preferences": preferences}

@router.post("/user/{user_id}/dietary-preferences")
def set_user_dietary_preference(
    user_id: str,
    dietary_restriction_id: int,
    db=Depends(get_db)
):
    """
    Add a dietary preference for a user.
    
    Parameters:
    - user_id: ID of the user
    - dietary_restriction_id: ID of the dietary restriction
    
    Returns:
    - Status confirmation
    """
    repository = InteractionRepository()
    success = repository.add_user_dietary_preference(
        user_id=user_id,
        dietary_restriction_id=dietary_restriction_id
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to add dietary preference"
        )
    
    return {"status": "added"}
////////////////////////////////////////////////////////////////////////////////

│   ├── similar.py

////////////////////////////////////////////////////////////////////////////////
"""
Similar meal API routes.
Endpoints for finding meals similar to a given item.
"""
from fastapi import APIRouter, Depends, Query, HTTPException, status
from typing import Optional

from base import get_db, validate_content_type
from services.content_based_recommender import ContentBasedRecommender
from services.item_based_recommender import ItemBasedRecommender
from config.settings import DEFAULT_RECOMMENDATION_LIMIT

router = APIRouter(prefix="/recommend", tags=["recommendations"])

@router.get("/similar/{content_type}/{meal_id}")
def get_similar_meals(
    content_type: str,
    meal_id: str,
    limit: int = Query(DEFAULT_RECOMMENDATION_LIMIT, description="Maximum number of similar meals"),
    similarity_method: str = Query("content", description="Method to determine similarity (content, interaction, ingredient)"),
    db=Depends(get_db)
):
    """
    Get meals similar to the specified item.
    
    Supports three similarity methods:
    - content: Uses vector embeddings to find similar meals based on textual features
    - interaction: Uses co-occurrence patterns to find meals that users interact with together
    - ingredient: Uses common ingredients to find similar meals
    
    Parameters:
    - content_type: Type of content ('meal' or 'recipe')
    - meal_id: ID of the meal
    - limit: Maximum number of similar meals to return
    - similarity_method: Method to determine similarity (content, interaction, ingredient)
    
    Returns:
    - List of similar meals with similarity scores
    """
    # Validate content type
    content_type = validate_content_type(content_type)
    
    # Choose similarity method
    if similarity_method == "content":
        # Content-based similarity using vector embeddings
        recommender = ContentBasedRecommender()
    elif similarity_method == "interaction":
        # Item-based collaborative filtering using interaction patterns
        recommender = ItemBasedRecommender()
    elif similarity_method == "ingredient":
        # Ingredient-based similarity
        recommender = ContentBasedRecommender()
        return recommender.get_similar_by_ingredients(
            meal_id=meal_id,
            content_type=content_type,
            limit=limit
        )
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid similarity method. Must be 'content', 'interaction', or 'ingredient'."
        )
    
    # Get similar meals
    similar_items = recommender.get_recommendations(
        meal_id=meal_id,
        content_type=content_type,
        limit=limit
    )
    
    return recommender.format_recommendations(similar_items)
////////////////////////////////////////////////////////////////////////////////

│   └── trending.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

├── client
│   └── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

├── config
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   └── settings.py

////////////////////////////////////////////////////////////////////////////////
"""
Configuration settings for the meal recommendation service.
Centralizes all configuration parameters.
"""
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Database settings
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://postgres:postgres@localhost:5432/postgres")

# API settings
API_HOST = os.getenv("API_HOST", "0.0.0.0")
API_PORT = int(os.getenv("API_PORT", "8000"))
RELOAD = os.getenv("RELOAD", "True").lower() == "true"

# Embedding model settings
EMBEDDING_MODEL = os.getenv("EMBEDDING_MODEL", "all-MiniLM-L6-v2")
EMBEDDING_DIMENSION = int(os.getenv("EMBEDDING_DIMENSION", "768"))

# Recommendation settings
DEFAULT_RECOMMENDATION_LIMIT = int(os.getenv("DEFAULT_RECOMMENDATION_LIMIT", "10"))
CONTENT_TYPES = ["meal", "recipe"]
ALLOWED_TRENDING_WINDOWS = ["day", "week", "month"]

# Scheduler settings
EMBEDDING_GENERATION_INTERVAL = int(os.getenv("EMBEDDING_GENERATION_INTERVAL", "60"))  # minutes
SCHEDULER_SLEEP_INTERVAL = int(os.getenv("SCHEDULER_SLEEP_INTERVAL", "60"))  # seconds

# Client settings
RECOMMENDATION_API_URL = os.getenv("RECOMMENDATION_API_URL", "http://localhost:8000")

# Meal-specific settings
CUISINE_TYPES = ["italian", "mexican", "chinese", "indian", "american", "french", "japanese", "mediterranean", "thai", "other"]
DIETARY_RESTRICTIONS = ["vegetarian", "vegan", "gluten-free", "dairy-free", "keto", "paleo", "low-carb", "low-fat"]
////////////////////////////////////////////////////////////////////////////////

├── data
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   ├── database.py

////////////////////////////////////////////////////////////////////////////////
"""
Database connection module.
Provides database connection pool and transaction management.
"""
from sqlalchemy import create_engine, text
from contextlib import contextmanager
from typing import Generator

from config.settings import DATABASE_URL

# Create database engine with connection pooling
engine = create_engine(DATABASE_URL, pool_size=10, max_overflow=20)

@contextmanager
def get_connection():
    """Get a database connection from the pool."""
    connection = engine.connect()
    try:
        yield connection
    finally:
        connection.close()

@contextmanager
def get_transaction():
    """Get a database connection with transaction."""
    connection = engine.connect()
    transaction = connection.begin()
    try:
        yield connection
        transaction.commit()
    except Exception:
        transaction.rollback()
        raise
    finally:
        connection.close()

def execute_query(query, params=None, is_transaction=False):
    """Execute a database query with parameters."""
    manager = get_transaction if is_transaction else get_connection
    
    with manager() as conn:
        result = conn.execute(text(query), params or {})
        return result

def test_connection():
    """Test the database connection."""
    try:
        with get_connection() as conn:
            result = conn.execute(text("SELECT 1"))
            print("Database connection successful!")
            return True
    except Exception as e:
        print(f"Database connection failed: {e}")
        return False
////////////////////////////////////////////////////////////////////////////////

│   ├── queries
│   │   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////
"""
SQL Queries module.
This package contains SQL query constants and templates organized by domain.
"""
////////////////////////////////////////////////////////////////////////////////

│   │   ├── content_embedding_queries.py

////////////////////////////////////////////////////////////////////////////////
"""
SQL query constants for meal embedding operations.
Contains all the queries used by the ContentEmbeddingRepository.
"""

# Query to save or update a meal embedding
SAVE_EMBEDDING = """
INSERT INTO content_embeddings (meal_id, content_type, embedding)
VALUES (:meal_id, :content_type, :embedding)
ON CONFLICT (meal_id, content_type) 
DO UPDATE SET embedding = :embedding, updated_at = CURRENT_TIMESTAMP
"""

# Query to get the embedding for specific meal
GET_EMBEDDING = """
SELECT embedding
FROM content_embeddings
WHERE meal_id = :meal_id AND content_type = :content_type
"""

# Base query for finding similar meals (without filter clauses)
FIND_SIMILAR_CONTENT_BASE = """
SELECT ce.meal_id, ce.content_type,
       CASE WHEN ce.content_type = 'meal' THEN m.title
            WHEN ce.content_type = 'recipe' THEN r.name
       END as title,
       1 - (ce.embedding <=> :embedding) AS similarity
FROM content_embeddings ce
LEFT JOIN "Meal" m ON ce.meal_id = m.id AND ce.content_type = 'meal'
LEFT JOIN "Recipe" r ON ce.meal_id = r.id AND ce.content_type = 'recipe'
WHERE 1=1
{type_filter}
{exclude_clause}
ORDER BY similarity DESC
LIMIT :limit
"""

# Query to get meals that don't have embeddings yet
GET_MEALS_WITHOUT_EMBEDDINGS = """
SELECT m.id, m.title, m.description
FROM "Meal" m
LEFT JOIN content_embeddings ce ON ce.meal_id = m.id AND ce.content_type = 'meal'
WHERE ce.id IS NULL
LIMIT :limit
"""

# Query to get recipes that don't have embeddings yet
GET_RECIPES_WITHOUT_EMBEDDINGS = """
SELECT r.id, r.name, r.instructions
FROM "Recipe" r
LEFT JOIN content_embeddings ce ON ce.meal_id = r.id AND ce.content_type = 'recipe'
WHERE ce.id IS NULL
LIMIT :limit
"""

# Query to find meals by cuisine
FIND_MEALS_BY_CUISINE = """
SELECT m.id, m.title, ce.embedding
FROM "Meal" m
JOIN content_embeddings ce ON ce.meal_id = m.id AND ce.content_type = 'meal'
WHERE m.cuisine_id = :cuisine_id
LIMIT :limit
"""

# Query to find meals by dietary preferences
FIND_MEALS_BY_DIETARY_PREFERENCE = """
SELECT m.id, m.title, ce.embedding
FROM "Meal" m
JOIN "MealDietaryRestriction" mdr ON m.id = mdr.meal_id
JOIN content_embeddings ce ON ce.meal_id = m.id AND ce.content_type = 'meal'
WHERE mdr.dietary_restriction_id = :dietary_restriction_id
LIMIT :limit
"""
////////////////////////////////////////////////////////////////////////////////

│   │   ├── interaction_queries.py

////////////////////////////////////////////////////////////////////////////////
"""
SQL query constants for user meal interaction operations.
Contains all the queries used by the InteractionRepository.
"""

# Query to record a user interaction with a meal
RECORD_INTERACTION = """
INSERT INTO recommendation_interactions
(user_id, meal_id, content_type, interaction_type)
VALUES (:user_id, :meal_id, :content_type, :interaction_type)
"""

# Query to get recent interactions for a user
GET_USER_RECENT_INTERACTIONS_BASE = """
SELECT meal_id, content_type, interaction_type, created_at
FROM recommendation_interactions
WHERE user_id = :user_id
{type_filter}
ORDER BY created_at DESC
LIMIT :limit
"""

# Base query for getting trending meals
GET_TRENDING_MEALS_BASE = """
SELECT ri.meal_id, ri.content_type,
       CASE WHEN ri.content_type = 'meal' THEN m.title
            WHEN ri.content_type = 'recipe' THEN r.name
       END as title,
       COUNT(*) as popularity
FROM recommendation_interactions ri
LEFT JOIN "Meal" m ON ri.meal_id = m.id AND ri.content_type = 'meal'
LEFT JOIN "Recipe" r ON ri.meal_id = r.id AND ri.content_type = 'recipe'
WHERE ri.created_at > {time_clause}
{type_filter}
GROUP BY ri.meal_id, ri.content_type, m.title, r.name
ORDER BY popularity DESC
LIMIT :limit
"""

# Query to find users with similar meal preferences
FIND_SIMILAR_USERS = """
SELECT DISTINCT ri2.user_id
FROM recommendation_interactions ri1
JOIN recommendation_interactions ri2 ON ri1.meal_id = ri2.meal_id 
                                  AND ri1.content_type = ri2.content_type
WHERE ri1.user_id = :user_id
AND ri2.user_id != :user_id
GROUP BY ri2.user_id
HAVING COUNT(DISTINCT ri1.meal_id) > :min_common_items
LIMIT :limit
"""

# Base query for getting meals from similar users
GET_MEALS_FROM_SIMILAR_USERS_BASE = """
SELECT DISTINCT ri.meal_id, ri.content_type, COUNT(*) as interaction_count,
       CASE WHEN ri.content_type = 'meal' THEN m.title
            WHEN ri.content_type = 'recipe' THEN r.name
       END as title
FROM recommendation_interactions ri
LEFT JOIN "Meal" m ON ri.meal_id = m.id AND ri.content_type = 'meal'
LEFT JOIN "Recipe" r ON ri.meal_id = r.id AND ri.content_type = 'recipe'
WHERE ri.user_id IN ({user_placeholders})
AND ri.meal_id NOT IN (
    SELECT meal_id 
    FROM recommendation_interactions 
    WHERE user_id = :user_id
)
{type_filter}
GROUP BY ri.meal_id, ri.content_type, m.title, r.name
ORDER BY interaction_count DESC
LIMIT :limit
"""

# Query to get meals by cuisine
GET_CUISINE_MEALS = """
SELECT m.id, m.title
FROM "Meal" m
WHERE m.cuisine_id = :cuisine_id
LIMIT :limit
"""

# Query to get meals by dietary preference
GET_DIETARY_PREFERENCE_MEALS = """
SELECT m.id, m.title
FROM "Meal" m
JOIN "MealDietaryRestriction" mdr ON m.id = mdr.meal_id
WHERE mdr.dietary_restriction_id = :dietary_restriction_id
LIMIT :limit
"""

# Query to get user's dietary preferences
GET_USER_DIETARY_PREFERENCES = """
SELECT dietary_restriction_id
FROM "UserDietaryPreference"
WHERE user_id = :user_id
"""

# Query to get similar meals based on ingredients
GET_SIMILAR_MEALS_BY_INGREDIENTS = """
SELECT m1.id, m1.title, COUNT(mi1.ingredient_id) as ingredient_match_count
FROM "Meal" m1
JOIN "MealIngredient" mi1 ON m1.id = mi1.meal_id
JOIN "MealIngredient" mi2 ON mi1.ingredient_id = mi2.ingredient_id
WHERE mi2.meal_id = :meal_id
AND m1.id != :meal_id
GROUP BY m1.id, m1.title
ORDER BY ingredient_match_count DESC
LIMIT :limit
"""
////////////////////////////////////////////////////////////////////////////////

│   │   ├── service_queries.py

////////////////////////////////////////////////////////////////////////////////
"""
SQL query constants for meal recommendation service operations.
Contains queries used by service classes.
"""

# Query for finding similar meals based on co-occurrence patterns
FIND_SIMILAR_ITEMS = """
WITH users_who_interacted AS (
    SELECT DISTINCT user_id
    FROM recommendation_interactions
    WHERE meal_id = :meal_id
)
SELECT ri2.meal_id, ri2.content_type,
       CASE WHEN ri2.content_type = 'meal' THEN m.title
            WHEN ri2.content_type = 'recipe' THEN r.name
       END as title,
       COUNT(DISTINCT ri2.user_id) as co_occurrence_count
FROM recommendation_interactions ri2
JOIN users_who_interacted uwi ON ri2.user_id = uwi.user_id
LEFT JOIN "Meal" m ON ri2.meal_id = m.id AND ri2.content_type = 'meal'
LEFT JOIN "Recipe" r ON ri2.meal_id = r.id AND ri2.content_type = 'recipe'
WHERE ri2.meal_id != :meal_id
{type_filter}
GROUP BY ri2.meal_id, ri2.content_type, m.title, r.name
ORDER BY co_occurrence_count DESC
LIMIT :limit
"""

# Query for finding meals filtered by user dietary preferences
FIND_MEALS_WITH_DIETARY_PREFERENCES = """
SELECT m.id, m.title, m.description
FROM "Meal" m
JOIN "MealDietaryRestriction" mdr ON m.id = mdr.meal_id
JOIN "UserDietaryPreference" udp ON mdr.dietary_restriction_id = udp.dietary_restriction_id
WHERE udp.user_id = :user_id
GROUP BY m.id, m.title, m.description
LIMIT :limit
"""

# Query for finding meals with similar ingredients
FIND_MEALS_BY_INGREDIENT_SIMILARITY = """
WITH meal_ingredients AS (
    SELECT mi.ingredient_id
    FROM "MealIngredient" mi
    WHERE mi.meal_id = :meal_id
)
SELECT m.id, m.title, m.description,
       COUNT(mi.ingredient_id) AS matching_ingredients,
       (COUNT(mi.ingredient_id) * 100.0 / ingredient_count.total) AS match_percentage
FROM "Meal" m
JOIN "MealIngredient" mi ON m.id = mi.meal_id
JOIN meal_ingredients source_ingredients ON mi.ingredient_id = source_ingredients.ingredient_id
JOIN (
    SELECT meal_id, COUNT(ingredient_id) AS total
    FROM "MealIngredient"
    GROUP BY meal_id
) ingredient_count ON m.id = ingredient_count.meal_id
WHERE m.id != :meal_id
GROUP BY m.id, m.title, m.description, ingredient_count.total
ORDER BY matching_ingredients DESC, match_percentage DESC
LIMIT :limit
"""

# Query for getting popular meals by cuisine
GET_POPULAR_MEALS_BY_CUISINE = """
SELECT m.id, m.title, m.description, COUNT(ri.id) AS popularity
FROM "Meal" m
LEFT JOIN recommendation_interactions ri ON m.id = ri.meal_id AND ri.content_type = 'meal'
WHERE m.cuisine_id = :cuisine_id
GROUP BY m.id, m.title, m.description
ORDER BY popularity DESC
LIMIT :limit
"""

# Query for getting meal recommendations based on time of day
GET_MEALS_BY_TIME_OF_DAY = """
SELECT m.id, m.title, m.description
FROM "Meal" m
WHERE m.meal_type = :meal_type  -- 'breakfast', 'lunch', 'dinner', 'snack'
ORDER BY 
    CASE WHEN m.cuisine_id = :preferred_cuisine_id THEN 0 ELSE 1 END,
    RANDOM()
LIMIT :limit
"""

# Query for getting recommended meal pairings
GET_MEAL_PAIRINGS = """
WITH meal_pairs AS (
    SELECT ri1.meal_id AS meal1_id, ri2.meal_id AS meal2_id, COUNT(*) AS pair_count
    FROM recommendation_interactions ri1
    JOIN recommendation_interactions ri2 
        ON ri1.user_id = ri2.user_id 
        AND ri1.meal_id != ri2.meal_id
        AND ri1.content_type = 'meal'
        AND ri2.content_type = 'meal'
    WHERE ri1.meal_id = :meal_id
    GROUP BY ri1.meal_id, ri2.meal_id
    ORDER BY pair_count DESC
)
SELECT mp.meal2_id, m.title, m.description, mp.pair_count
FROM meal_pairs mp
JOIN "Meal" m ON mp.meal2_id = m.id
LIMIT :limit
"""
////////////////////////////////////////////////////////////////////////////////

│   │   └── setup_queries.py

////////////////////////////////////////////////////////////////////////////////
"""
SQL query constants for database setup.
Contains all the queries used for creating tables and indexes for meal recommendations.
"""

# Query to enable pgvector extension
ENABLE_PGVECTOR = """
CREATE EXTENSION IF NOT EXISTS vector
"""

# Query to create meal embeddings table
CREATE_CONTENT_EMBEDDINGS_TABLE = """
CREATE TABLE IF NOT EXISTS content_embeddings (
    id SERIAL PRIMARY KEY,
    meal_id TEXT NOT NULL,
    content_type TEXT NOT NULL,  -- 'meal' or 'recipe'
    embedding vector({embedding_dimension}),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(meal_id, content_type)
)
"""

# Query to create index for vector search
CREATE_EMBEDDINGS_INDEX = """
CREATE INDEX IF NOT EXISTS content_embeddings_idx 
ON content_embeddings USING ivfflat (embedding vector_cosine_ops)
"""

# Query to create meal interactions table
CREATE_INTERACTIONS_TABLE = """
CREATE TABLE IF NOT EXISTS recommendation_interactions (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    meal_id TEXT NOT NULL,
    content_type TEXT NOT NULL,  -- 'meal', 'recipe'
    interaction_type TEXT NOT NULL,  -- 'view', 'like', 'save', 'cook'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
"""

# Query to create indexes for quick lookups
CREATE_INTERACTIONS_INDEXES = """
CREATE INDEX IF NOT EXISTS rec_interactions_user_idx ON recommendation_interactions(user_id);
CREATE INDEX IF NOT EXISTS rec_interactions_meal_idx ON recommendation_interactions(meal_id, content_type);
CREATE INDEX IF NOT EXISTS rec_interactions_type_idx ON recommendation_interactions(interaction_type);
CREATE INDEX IF NOT EXISTS rec_interactions_created_idx ON recommendation_interactions(created_at);
"""

# Query to create cuisine reference table
CREATE_CUISINE_TABLE = """
CREATE TABLE IF NOT EXISTS "Cuisine" (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
)
"""

# Query to create dietary restriction reference table
CREATE_DIETARY_RESTRICTION_TABLE = """
CREATE TABLE IF NOT EXISTS "DietaryRestriction" (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
)
"""

# Query to create user dietary preferences table
CREATE_USER_DIETARY_PREFERENCE_TABLE = """
CREATE TABLE IF NOT EXISTS "UserDietaryPreference" (
    id SERIAL PRIMARY KEY,
    user_id TEXT NOT NULL,
    dietary_restriction_id INTEGER NOT NULL REFERENCES "DietaryRestriction"(id),
    UNIQUE(user_id, dietary_restriction_id)
)
"""

# Query to create meal dietary restrictions table
CREATE_MEAL_DIETARY_RESTRICTION_TABLE = """
CREATE TABLE IF NOT EXISTS "MealDietaryRestriction" (
    id SERIAL PRIMARY KEY,
    meal_id TEXT NOT NULL,
    dietary_restriction_id INTEGER NOT NULL REFERENCES "DietaryRestriction"(id),
    UNIQUE(meal_id, dietary_restriction_id)
)
"""

# Query to create ingredients table
CREATE_INGREDIENT_TABLE = """
CREATE TABLE IF NOT EXISTS "Ingredient" (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
)
"""

# Query to create meal ingredients table
CREATE_MEAL_INGREDIENT_TABLE = """
CREATE TABLE IF NOT EXISTS "MealIngredient" (
    id SERIAL PRIMARY KEY,
    meal_id TEXT NOT NULL,
    ingredient_id INTEGER NOT NULL REFERENCES "Ingredient"(id),
    amount TEXT,
    UNIQUE(meal_id, ingredient_id)
)
"""

# Query to insert default cuisines
INSERT_DEFAULT_CUISINES = """
INSERT INTO "Cuisine" (name) VALUES
('italian'), ('mexican'), ('chinese'), ('indian'), ('american'),
('french'), ('japanese'), ('mediterranean'), ('thai'), ('other')
ON CONFLICT (name) DO NOTHING
"""

# Query to insert default dietary restrictions
INSERT_DEFAULT_DIETARY_RESTRICTIONS = """
INSERT INTO "DietaryRestriction" (name) VALUES
('vegetarian'), ('vegan'), ('gluten-free'), ('dairy-free'),
('keto'), ('paleo'), ('low-carb'), ('low-fat')
ON CONFLICT (name) DO NOTHING
"""
////////////////////////////////////////////////////////////////////////////////

│   └── repositories
│       ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│       ├── content_embedding_repository.py

////////////////////////////////////////////////////////////////////////////////
"""
Repository for content embeddings.
Handles database operations for content embeddings.
"""
from typing import List, Dict, Any, Optional, Tuple
import numpy as np

from data.database import execute_query
from config.settings import EMBEDDING_DIMENSION
from data.queries.content_embedding_queries import (
    SAVE_EMBEDDING,
    GET_EMBEDDING,
    FIND_SIMILAR_CONTENT_BASE,
    GET_POSTS_WITHOUT_EMBEDDINGS,
    GET_COMMUNITIES_WITHOUT_EMBEDDINGS
)

class ContentEmbeddingRepository:
    """Repository for content embeddings."""
    
    def save_embedding(self, meal_id: str, content_type: str, embedding: List[float]) -> bool:
        """
        Save or update a content embedding.
        
        Args:
            meal_id: The ID of the content
            content_type: The type of content ('post', 'community', etc.)
            embedding: The vector embedding
            
        Returns:
            bool: Success status
        """
        try:
            execute_query(
                SAVE_EMBEDDING,
                {
                    "meal_id": meal_id,
                    "content_type": content_type,
                    "embedding": embedding
                },
                is_transaction=True
            )
            return True
        except Exception as e:
            print(f"Error saving embedding: {e}")
            return False
    
    def get_embedding(self, meal_id: str, content_type: str) -> Optional[List[float]]:
        """
        Get the embedding for specific content.
        
        Args:
            meal_id: The ID of the content
            content_type: The type of content
            
        Returns:
            The embedding vector or None if not found
        """
        result = execute_query(
            GET_EMBEDDING,
            {"meal_id": meal_id, "content_type": content_type}
        )
        
        row = result.fetchone()
        return row[0] if row else None
    
    def find_similar_content(
        self, 
        embedding: List[float], 
        content_type: Optional[str] = None, 
        exclude_ids: List[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Find content with similar embeddings.
        
        Args:
            embedding: The source embedding to compare against
            content_type: Optional filter for content type
            exclude_ids: List of content IDs to exclude
            limit: Maximum number of results
            
        Returns:
            List of similar content items with similarity scores
        """
        params = {"embedding": embedding, "limit": limit}
        
        # Build query parts
        type_filter = ""
        if content_type:
            type_filter = "AND ce.content_type = :content_type"
            params["content_type"] = content_type
        
        exclude_clause = ""
        if exclude_ids and len(exclude_ids) > 0:
            placeholder_list = ','.join([f':exclude_{i}' for i in range(len(exclude_ids))])
            exclude_clause = f"AND ce.meal_id NOT IN ({placeholder_list})"
            for i, id_val in enumerate(exclude_ids):
                params[f"exclude_{i}"] = id_val
        
        # Execute query
        formatted_query = FIND_SIMILAR_CONTENT_BASE.format(
            type_filter=type_filter,
            exclude_clause=exclude_clause
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        items = []
        for row in result:
            items.append({
                "id": row[0],
                "content_type": row[1],
                "title": row[2],
                "similarity": row[3]
            })
        
        return items
    
    def get_content_without_embeddings(self, content_type: str, limit: int = 500) -> List[Tuple[str, str, str]]:
        """
        Get content items that don't have embeddings yet.
        
        Args:
            content_type: The type of content
            limit: Maximum number of items to retrieve
            
        Returns:
            List of tuples (id, title, content) for items without embeddings
        """
        if content_type == 'post':
            result = execute_query(
                GET_POSTS_WITHOUT_EMBEDDINGS,
                {"limit": limit}
            )
        elif content_type == 'community':
            result = execute_query(
                GET_COMMUNITIES_WITHOUT_EMBEDDINGS,
                {"limit": limit}
            )
        else:
            return []
        
        return [(row[0], row[1] or '', row[2] or '') for row in result.fetchall()]
////////////////////////////////////////////////////////////////////////////////

│       └── interaction_repository.py

////////////////////////////////////////////////////////////////////////////////
"""
Repository for user interactions.
Handles database operations for user interactions with content.
"""
from typing import List, Dict, Any, Optional
from datetime import datetime

from data.database import execute_query
from config.settings import CONTENT_TYPES
from data.queries.interaction_queries import (
    RECORD_INTERACTION,
    GET_USER_RECENT_INTERACTIONS_BASE,
    GET_TRENDING_CONTENT_BASE,
    FIND_SIMILAR_USERS,
    GET_CONTENT_FROM_SIMILAR_USERS_BASE,
    GET_CATEGORY_COMMUNITIES
)

class InteractionRepository:
    """Repository for user interactions."""
    
    def record_interaction(
        self, 
        user_id: str, 
        meal_id: str, 
        content_type: str, 
        interaction_type: str
    ) -> bool:
        """
        Record a user interaction with content.
        
        Args:
            user_id: The ID of the user
            meal_id: The ID of the content
            content_type: The type of content ('post', 'community', 'comment')
            interaction_type: The type of interaction ('view', 'click', 'vote', etc.)
            
        Returns:
            bool: Success status
        """
        try:
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
                
            execute_query(
                RECORD_INTERACTION,
                {
                    "user_id": user_id,
                    "meal_id": meal_id,
                    "content_type": content_type,
                    "interaction_type": interaction_type
                },
                is_transaction=True
            )
            return True
        except Exception as e:
            print(f"Error recording interaction: {e}")
            return False
    
    def get_user_recent_interactions(
        self, 
        user_id: str, 
        content_type: Optional[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get recent interactions for a user.
        
        Args:
            user_id: The ID of the user
            content_type: Optional filter for content type
            limit: Maximum number of interactions to retrieve
            
        Returns:
            List of recent interactions
        """
        params = {"user_id": user_id, "limit": limit}
        
        type_filter = ""
        if content_type:
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
            type_filter = "AND content_type = :content_type"
            params["content_type"] = content_type
            
        # Format the query with the type filter
        formatted_query = GET_USER_RECENT_INTERACTIONS_BASE.format(
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        interactions = []
        for row in result:
            interactions.append({
                "meal_id": row[0],
                "content_type": row[1],
                "interaction_type": row[2],
                "created_at": row[3]
            })
        
        return interactions
    
    def get_trending_content(
        self, 
        content_type: str = 'all', 
        time_window: str = 'day',
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get trending content based on recent interactions.
        
        Args:
            content_type: The type of content ('post', 'community', 'all')
            time_window: Time window ('day', 'week', 'month')
            limit: Maximum number of items
            
        Returns:
            List of trending content items with popularity scores
        """
        # Determine time interval
        time_clause = "NOW() - INTERVAL '1 day'"
        if time_window == "week":
            time_clause = "NOW() - INTERVAL '7 days'"
        elif time_window == "month":
            time_clause = "NOW() - INTERVAL '30 days'"
        
        type_filter = ""
        params = {"limit": limit}
        
        if content_type != 'all':
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
            type_filter = "AND ri.content_type = :content_type"
            params["content_type"] = content_type
        
        # Format the query with the time clause and type filter
        formatted_query = GET_TRENDING_CONTENT_BASE.format(
            time_clause=time_clause,
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        trending_items = []
        for row in result:
            trending_items.append({
                "id": row[0],
                "content_type": row[1],
                "title": row[2],
                "popularity": row[3]
            })
        
        return trending_items
    
    def find_similar_users(self, user_id: str, min_common_items: int = 2, limit: int = 10) -> List[str]:
        """
        Find users with similar interaction patterns.
        
        Args:
            user_id: The ID of the user
            min_common_items: Minimum number of common items to consider users similar
            limit: Maximum number of similar users to retrieve
            
        Returns:
            List of similar user IDs
        """
        result = execute_query(
            FIND_SIMILAR_USERS,
            {
                "user_id": user_id, 
                "min_common_items": min_common_items,
                "limit": limit
            }
        )
        
        return [row[0] for row in result]
    
    def get_content_from_similar_users(
        self, 
        similar_users: List[str],
        user_id: str,
        content_type: Optional[str] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """
        Get content items that similar users interacted with.
        
        Args:
            similar_users: List of similar user IDs
            user_id: The ID of the current user (to exclude content they've already interacted with)
            content_type: Optional filter for content type
            limit: Maximum number of content items to retrieve
            
        Returns:
            List of content items with interaction counts
        """
        if not similar_users:
            return []
        
        # Create parameter placeholders for similar users
        user_placeholders = ','.join([f':user_{i}' for i in range(len(similar_users))])
        params = {"user_id": user_id, "limit": limit}
        
        # Add similar user IDs to parameters
        for i, similar_user in enumerate(similar_users):
            params[f"user_{i}"] = similar_user
        
        # Add content type filter if specified
        type_filter = ""
        if content_type:
            if content_type not in CONTENT_TYPES:
                raise ValueError(f"Invalid content type: {content_type}")
            type_filter = "AND ri.content_type = :content_type"
            params["content_type"] = content_type
        
        # Format the query with the user placeholders and type filter
        formatted_query = GET_CONTENT_FROM_SIMILAR_USERS_BASE.format(
            user_placeholders=user_placeholders,
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        content_items = []
        for row in result:
            content_items.append({
                "id": row[0],
                "content_type": row[1],
                "interaction_count": row[2],
                "title": row[3]
            })
        
        return content_items
        
    def get_category_communities(self, category_id: str, limit: int = 10) -> List[Dict[str, Any]]:
        """
        Get communities in a specific category.
        
        Args:
            category_id: The ID of the category
            limit: Maximum number of communities to retrieve
            
        Returns:
            List of communities in the category
        """
        result = execute_query(
            GET_CATEGORY_COMMUNITIES,
            {"category_id": category_id, "limit": limit}
        )
        
        communities = []
        for row in result:
            communities.append({
                "id": row[0],
                "content_type": "community",
                "title": row[1]
            })
        
        return communities
////////////////////////////////////////////////////////////////////////////////

├── db_utils.py

////////////////////////////////////////////////////////////////////////////////
# db_utils.py
import os
import sqlalchemy
from sqlalchemy import create_engine
from dotenv import load_dotenv

# Load environment variables from your existing Node.js .env file
load_dotenv()

def get_db_engine():
    db_url = os.getenv("DATABASE_URL")
    engine = create_engine(db_url)
    return engine

def test_connection():
    engine = get_db_engine()
    try:
        with engine.connect() as conn:
            result = conn.execute(sqlalchemy.text("SELECT 1"))
            print("Database connection successful!")
            return True
    except Exception as e:
        print(f"Database connection failed: {e}")
        return False

if __name__ == "__main__":
    test_connection()
////////////////////////////////////////////////////////////////////////////////

├── documentation
│   ├── API_DOCUMENTATION.md

////////////////////////////////////////////////////////////////////////////////
# Recommendation Service API Documentation

This guide provides instructions for using the Recommendation Service API and testing it with Postman.

## Overview

The Recommendation Service API provides several types of recommendations:

- **User Recommendations**: Personalized content recommendations for users
- **Similar Content**: Finding content similar to a specific item
- **Trending Content**: Popular content based on recent interactions
- **Category Recommendations**: Communities within specific categories
- **Interaction Tracking**: Recording user interactions with content

## Getting Started with Postman

### Importing the Collection

1. Open Postman
2. Click "Import" in the top left
3. Select the `recommendation_service.postman_collection.json` file from this directory
4. The collection will appear in your Postman workspace

### Setting Environment Variables

The collection uses several variables that you can customize:

- `baseUrl`: The base URL of the API (default: `http://localhost:8000`)
- `userId`: The user ID for testing user recommendations
- `contentId`: The content ID for testing similar content recommendations
- `contentType`: The content type (post, community) for testing
- `categoryId`: The category ID for testing category recommendations

You can either:

1. Edit these in the collection variables section
2. Create a Postman environment with these variables
3. Manually replace them in each request

## API Endpoints

### Service Status

```
GET /
```

Checks if the recommendation service is running.

### User Recommendations

```
GET /recommend/user/{userId}?recommendation_type={type}&content_type={contentType}&limit={limit}
```

Parameters:
- `userId`: The ID of the user
- `recommendation_type`: Algorithm to use (hybrid, item-based, user-based)
- `content_type` (optional): Filter by content type (post, community)
- `limit` (optional): Maximum number of recommendations

#### Recommendation Types

1. **hybrid**: Combines multiple strategies with fallbacks
   - Starts with collaborative filtering
   - Falls back to content-based recommendations
   - Finally uses popularity-based recommendations if needed

2. **item-based**: Item-based collaborative filtering
   - Finds items similar to those the user has interacted with
   - Based on co-occurrence patterns in user interactions

3. **user-based**: User-based collaborative filtering
   - Finds users with similar tastes
   - Recommends content they interacted with

### Similar Content

```
GET /recommend/similar/{contentType}/{contentId}?similarity_method={method}&limit={limit}
```

Parameters:
- `contentType`: The type of content (post, community)
- `contentId`: The ID of the content
- `similarity_method`: Method to determine similarity (content, interaction)
- `limit` (optional): Maximum number of similar items

#### Similarity Methods

1. **content**: Content-based similarity
   - Uses vector embeddings to find similar content
   - Based on text features and semantic similarity

2. **interaction**: Interaction-based similarity
   - Uses co-occurrence patterns to find similar content
   - Based on how users interact with content

### Trending Content

```
GET /trending/{contentType}?time_window={window}&limit={limit}
```

Parameters:
- `contentType`: The type of content (post, community, all)
- `time_window` (optional): Time window (day, week, month)
- `limit` (optional): Maximum number of items

### Category Recommendations

```
GET /recommend/category/{categoryId}?limit={limit}
```

Parameters:
- `categoryId`: The ID of the category
- `limit` (optional): Maximum number of communities to return

### Record Interactions

```
POST /interactions
```

Request body:
```json
{
  "user_id": "123",
  "meal_id": "post-456",
  "content_type": "post",
  "interaction_type": "view"
}
```

Parameters:
- `user_id`: The ID of the user
- `meal_id`: The ID of the content
- `content_type`: The type of content (post, community, comment)
- `interaction_type`: The type of interaction (view, click, vote, etc.)

## Testing Strategies

### Testing User Recommendations

1. Start by recording some interactions for a user
2. Then request recommendations for that user
3. Try different recommendation types to compare results

### Testing Similar Content

1. Select a piece of content with known features or interactions
2. Request similar content using both similarity methods
3. Compare the results to understand the differences

### Testing Trending Content

1. Record multiple interactions for different content
2. Try different time windows to see how trends change

## Example Workflow

1. Record interactions for user "123" with several posts
2. Get hybrid recommendations for user "123"
3. Get similar content to a post the user interacted with
4. Compare with trending content

## Common Issues

- If no recommendations are returned, it may be because:
  - The user has no recorded interactions
  - No similar users or content could be found
  - The content type filter is too restrictive
  
- If similarity scores are low, it may be because:
  - The embedding model needs more data
  - The content is genuinely dissimilar

## Advanced Usage

### Customizing Recommendation Behavior

You can modify the following files to customize the recommendation behavior:

- `services/hybrid_recommender.py`: Change the fallback strategy order
- `services/content_based_recommender.py`: Adjust similarity thresholds
- `services/collaborative_recommender.py`: Change the minimum common items threshold
- `config/settings.py`: Adjust global settings like limits and embedding dimensions
////////////////////////////////////////////////////////////////////////////////

│   └── README.md

////////////////////////////////////////////////////////////////////////////////
# Meal Recommendation Service

A Python-based recommendation service designed to provide personalized meal recommendations.

## Overview

This meal recommendation service provides multiple recommendation strategies with fallbacks:
1. **User-based collaborative filtering** based on similar users' interactions with meals
2. **Item-based collaborative filtering** based on co-occurrence patterns
3. **Content-based recommendations** using text embeddings of meal details
4. **Popularity-based recommendations** as a last resort

The service is highly configurable and allows switching between recommendation algorithms based on your needs. The system uses a hybrid approach that combines scores from different recommendation strategies.

## System Architecture

The service is built with FastAPI and uses PostgreSQL with pgvector extension for vector similarity search. It stores embeddings and interaction data in separate tables without modifying your existing database schema.

## Features

### Multiple Recommendation Strategies

The service implements several recommendation algorithms:

- **Hybrid Recommender**: Combines multiple strategies with fallbacks for robust recommendations
- **User-Based Collaborative Filtering**: Finds users with similar tastes and recommends what they liked
- **Item-Based Collaborative Filtering**: Recommends meals similar to those the user has interacted with
- **Content-Based Recommendations**: Uses vector embeddings to find similar content
- **Ingredient-Based Recommendations**: Suggests meals with similar ingredients
- **Cuisine-Based Recommendations**: Recommends meals from specific cuisines
- **Dietary Preference Filtering**: Filters recommendations based on dietary needs
- **Popularity-Based Recommendations**: Recommends trending meals as a fallback

### Flexible API

- Choose which recommendation strategy to use via API parameters
- Filter by meal type or recipe
- Filter by cuisine or dietary restrictions
- Adjust time windows for trending content
- Get meal recommendations based on time of day

### Background Processing

- Automatic embedding generation for new meals
- Scheduled tasks for keeping recommendations fresh

## Setup Instructions

### Prerequisites

- Python 3.8+
- PostgreSQL with pgvector extension
- Node.js (for client integration)

### Installation

1. Install required Python packages:

```bash
pip install fastapi uvicorn sqlalchemy psycopg2-binary sentence-transformers pandas scikit-learn numpy python-dotenv schedule
```

2. Make the startup script executable:

```bash
chmod +x start_recommendation_service.sh
```

3. Update your .env file with the DATABASE_URL:

```
DATABASE_URL=postgresql://username:password@localhost:5432/yourdb
```

### Starting the Service

Use the provided startup script:

```bash
./start_recommendation_service.sh
```

This will:
- Check for and install required packages
- Create necessary database tables if they don't exist
- Generate initial embeddings for meals
- Start the background scheduler
- Start the FastAPI server

## API Endpoints

### User Recommendations

```
GET /recommend/user/{user_id}?content_type=meal&limit=10&recommendation_type=hybrid
```

Get personalized meal recommendations for a user with options to use hybrid, user-based, or item-based algorithms.

### Similar Meals

```
GET /recommend/similar/{content_type}/{meal_id}?limit=10&similarity_method=content
```

Get meals similar to the specified item. Choose between content-based similarity (using embeddings), interaction-based similarity (based on co-occurrence patterns), or ingredient-based similarity.

### Trending Meals

```
GET /trending/{content_type}?time_window=day&limit=10
```

Get trending meals based on recent interactions.

### Cuisine Recommendations

```
GET /recommend/cuisine/{cuisine_id}?limit=10
```

Get meals in the specified cuisine.

### Dietary Restriction Recommendations

```
GET /recommend/dietary/{dietary_restriction_id}?limit=10
```

Get meals that conform to specific dietary restrictions.

### Record Interactions

```
POST /interactions

{
  "user_id": "123",
  "meal_id": "456",
  "content_type": "meal",
  "interaction_type": "view"
}
```

Record user interactions with meals.

## Integration with Node.js

Use the provided recommendation-client.js:

```javascript
const recommendations = require('./recommendation-service/client/recommendation-client');

// Get user recommendations with hybrid algorithm
async function getUserMealRecommendations(userId) {
  const items = await recommendations.getUserRecommendations(userId, 'meal', 20, 'hybrid');
  
  // Fetch additional data using Prisma if needed
  const meals = await prisma.meal.findMany({
    where: {
      id: { in: items.map(item => item.id) }
    },
    include: {
      ingredients: true,
      cuisine: true
    }
  });
  
  return meals;
}

// Get similar meals using item-based collaborative filtering
async function getSimilarMeals(mealId) {
  return await recommendations.getSimilarContent('meal', mealId, 5, 'interaction');
}

// Record a view
async function recordMealView(userId, mealId) {
  await recommendations.recordInteraction(userId, mealId, 'meal', 'view');
  // Other application logic...
}

// Get trending meals
async function getTrendingMeals() {
  return await recommendations.getTrendingContent('meal', 'week', 10);
}
```

## Customization

### Configuration Settings

Edit `config/settings.py` to customize:

- Database connection parameters
- API settings
- Embedding model and dimension
- Default recommendation limits
- Scheduler intervals

### Recommendation Algorithms

You can customize the recommendation algorithms by:

1. Adjusting parameters in the API requests
2. Modifying the implementation in the respective strategy files
3. Creating new recommender classes that implement the BaseRecommender interface

### Embedding Model

You can change the embedding model in `config/settings.py`:

```python
# Default model
EMBEDDING_MODEL = "all-MiniLM-L6-v2"

# For better multilingual support
# EMBEDDING_MODEL = "paraphrase-multilingual-MiniLM-L12-v2"

# For better semantic understanding but slower processing
# EMBEDDING_MODEL = "all-mpnet-base-v2"
```

## Performance Considerations

- The vector index is essential for fast similarity search
- Background embedding generation prevents API slowdowns
- Queries include appropriate indexes and limits

## Troubleshooting

### Connection Issues

If you encounter database connection issues:

```bash
python -m data.database
```

This will test the database connection and report any errors.

### Missing Embeddings

If meals aren't showing up in recommendations:

```bash
python -m embeddings.embedding_generator
```

This will generate embeddings for any missing meals.

### API Issues

You can check the API documentation at:

```
http://localhost:8000/docs
```

This provides an interactive OpenAPI interface for testing endpoints.
////////////////////////////////////////////////////////////////////////////////

├── embedding_generator.py

////////////////////////////////////////////////////////////////////////////////
# embedding_generator.py
from sentence_transformers import SentenceTransformer
from sqlalchemy import text
from db_utils import get_db_engine
import time

def generate_post_embeddings():
    engine = get_db_engine()
    model = SentenceTransformer('all-MiniLM-L6-v2')
    
    with engine.connect() as conn:
        # Get posts that don't have embeddings yet
        result = conn.execute(text("""
            SELECT p.id, p.title, p.content
            FROM "Post" p
            LEFT JOIN content_embeddings ce ON ce.meal_id = p.id AND ce.content_type = 'post'
            WHERE ce.id IS NULL
            LIMIT 500
        """))
        
        posts = result.fetchall()
        print(f"Processing {len(posts)} posts")
        
        for post in posts:
            post_id = post[0]
            title = post[1] or ''
            content = post[2] or ''
            
            # Generate text for embedding
            text_for_embedding = f"{title} {content}"
            
            # Generate embedding
            embedding = model.encode(text_for_embedding)
            
            # Store embedding
            conn.execute(text("""
                INSERT INTO content_embeddings (meal_id, content_type, embedding)
                VALUES (:meal_id, 'post', :embedding)
                ON CONFLICT (meal_id, content_type) 
                DO UPDATE SET embedding = :embedding, updated_at = CURRENT_TIMESTAMP
            """), {
                "meal_id": post_id,
                "embedding": embedding.tolist()
            })
            
            conn.commit()
            
    print("Post embeddings generated")

def generate_community_embeddings():
    engine = get_db_engine()
    model = SentenceTransformer('all-MiniLM-L6-v2')
    
    with engine.connect() as conn:
        # Get communities that don't have embeddings yet
        result = conn.execute(text("""
            SELECT c.id, c.name, c.description
            FROM "Community" c
            LEFT JOIN content_embeddings ce ON ce.meal_id = c.id AND ce.content_type = 'community'
            WHERE ce.id IS NULL
        """))
        
        communities = result.fetchall()
        print(f"Processing {len(communities)} communities")
        
        for community in communities:
            community_id = community[0]
            name = community[1] or ''
            description = community[2] or ''
            
            # Generate text for embedding
            text_for_embedding = f"{name} {description}"
            
            # Generate embedding
            embedding = model.encode(text_for_embedding)
            
            # Store embedding
            conn.execute(text("""
                INSERT INTO content_embeddings (meal_id, content_type, embedding)
                VALUES (:meal_id, 'community', :embedding)
                ON CONFLICT (meal_id, content_type) 
                DO UPDATE SET embedding = :embedding, updated_at = CURRENT_TIMESTAMP
            """), {
                "meal_id": community_id,
                "embedding": embedding.tolist()
            })
            
            conn.commit()
            
    print("Community embeddings generated")

if __name__ == "__main__":
    generate_post_embeddings()
    generate_community_embeddings()
////////////////////////////////////////////////////////////////////////////////

├── embeddings
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   └── embedding_generator.py

////////////////////////////////////////////////////////////////////////////////
"""
Embedding generator service.
Generates and stores vector embeddings for meals and recipes.
"""
from sentence_transformers import SentenceTransformer
from typing import List, Dict, Any, Optional
import time
import logging

from config.settings import EMBEDDING_MODEL
from data.repositories.content_embedding_repository import ContentEmbeddingRepository

logger = logging.getLogger(__name__)

class EmbeddingGenerator:
    """Service for generating and managing meal embeddings."""
    
    def __init__(self, model_name: str = EMBEDDING_MODEL):
        """
        Initialize the embedding generator.
        
        Args:
            model_name: The name of the sentence transformer model to use
        """
        self.model = SentenceTransformer(model_name)
        self.repository = ContentEmbeddingRepository()
    
    def generate_meal_embeddings(self, batch_size: int = 500) -> int:
        """
        Generate embeddings for meals that don't have them yet.
        
        Args:
            batch_size: Maximum number of meals to process at once
            
        Returns:
            Number of meals processed
        """
        meals = self.repository.get_content_without_embeddings('meal', batch_size)
        logger.info(f"Processing {len(meals)} meals for embedding generation")
        
        count = 0
        for meal_id, title, description in meals:
            # Get ingredients for this meal
            ingredients = self.repository.get_meal_ingredients(meal_id)
            ingredients_text = ", ".join([ing['name'] for ing in ingredients])
            
            # Generate text for embedding - include title, description, and ingredients
            text_for_embedding = f"{title} {description} Ingredients: {ingredients_text}"
            
            # Generate embedding
            embedding = self.model.encode(text_for_embedding)
            
            # Store embedding
            if self.repository.save_embedding(meal_id, 'meal', embedding.tolist()):
                count += 1
            
        logger.info(f"Generated embeddings for {count} meals")
        return count
    
    def generate_recipe_embeddings(self, batch_size: int = 500) -> int:
        """
        Generate embeddings for recipes that don't have them yet.
        
        Args:
            batch_size: Maximum number of recipes to process at once
            
        Returns:
            Number of recipes processed
        """
        recipes = self.repository.get_content_without_embeddings('recipe', batch_size)
        logger.info(f"Processing {len(recipes)} recipes for embedding generation")
        
        count = 0
        for recipe_id, name, instructions in recipes:
            # Get ingredients for this recipe
            ingredients = self.repository.get_recipe_ingredients(recipe_id)
            ingredients_text = ", ".join([ing['name'] for ing in ingredients])
            
            # Generate text for embedding - include name, instructions, and ingredients
            text_for_embedding = f"{name} {instructions} Ingredients: {ingredients_text}"
            
            # Generate embedding
            embedding = self.model.encode(text_for_embedding)
            
            # Store embedding
            if self.repository.save_embedding(recipe_id, 'recipe', embedding.tolist()):
                count += 1
            
        logger.info(f"Generated embeddings for {count} recipes")
        return count
    
    def generate_embedding_for_text(self, text: str) -> List[float]:
        """
        Generate an embedding for arbitrary text.
        
        Args:
            text: The text to encode
            
        Returns:
            The embedding vector
        """
        embedding = self.model.encode(text)
        return embedding.tolist()
    
    def generate_embedding_for_meal(self, meal_id: str, title: str, description: str, ingredients: List[str]) -> bool:
        """
        Generate and store an embedding for a specific meal.
        
        Args:
            meal_id: The ID of the meal
            title: The meal title
            description: The meal description
            ingredients: List of ingredient names
            
        Returns:
            Success status
        """
        ingredients_text = ", ".join(ingredients)
        text_for_embedding = f"{title} {description} Ingredients: {ingredients_text}"
        
        embedding = self.model.encode(text_for_embedding)
        return self.repository.save_embedding(meal_id, 'meal', embedding.tolist())
    
    def generate_all_embeddings(self) -> Dict[str, int]:
        """
        Generate embeddings for all content types.
        
        Returns:
            Dictionary with counts of processed items by type
        """
        meal_count = self.generate_meal_embeddings()
        recipe_count = self.generate_recipe_embeddings()
        
        return {
            "meals": meal_count,
            "recipes": recipe_count
        }


# For command-line execution
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    generator = EmbeddingGenerator()
    result = generator.generate_all_embeddings()
    print(f"Generated embeddings: {result}")
////////////////////////////////////////////////////////////////////////////////

├── init_dataset
│   └── kaggle.py

////////////////////////////////////////////////////////////////////////////////
import kagglehub

# Download latest version
path = kagglehub.dataset_download("kriishukla/recipe-db")

print("Path to dataset files:", path)
////////////////////////////////////////////////////////////////////////////////

├── main.py

////////////////////////////////////////////////////////////////////////////////
# main.py
from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import text
from typing import List, Optional, Dict
from pydantic import BaseModel
from db_utils import get_db_engine
from sentence_transformers import SentenceTransformer
import uvicorn

app = FastAPI(title="Recommendation Service")
model = SentenceTransformer('all-MiniLM-L6-v2')

def get_db():
    engine = get_db_engine()
    db = engine.connect()
    try:
        yield db
    finally:
        db.close()

class ContentItem(BaseModel):
    id: str
    title: Optional[str] = None
    content_type: str
    similarity: Optional[float] = None

class ContentList(BaseModel):
    items: List[ContentItem]

@app.get("/")
def read_root():
    return {"status": "Recommendation service is running"}

@app.get("/recommend/similar/{content_type}/{meal_id}", response_model=ContentList)
def get_similar_content(
    content_type: str,
    meal_id: str,
    limit: int = 10,
    db = Depends(get_db)
):
    # Validate content type
    if content_type not in ['post', 'community']:
        raise HTTPException(status_code=400, detail="Content type must be 'post' or 'community'")
    
    # Get embedding for the source content
    result = db.execute(
        text("""
            SELECT embedding
            FROM content_embeddings
            WHERE meal_id = :meal_id AND content_type = :content_type
        """),
        {"meal_id": meal_id, "content_type": content_type}
    )
    
    item = result.fetchone()
    if not item:
        raise HTTPException(status_code=404, detail=f"{content_type} not found or embedding not generated")
    
    embedding = item[0]
    
    # Find similar content
    result = db.execute(
        text(f"""
            SELECT ce.meal_id, ce.content_type,
                   CASE WHEN ce.content_type = 'post' THEN p.title
                        WHEN ce.content_type = 'community' THEN c.name
                   END as title,
                   1 - (ce.embedding <=> :embedding) AS similarity
            FROM content_embeddings ce
            LEFT JOIN "Post" p ON ce.meal_id = p.id AND ce.content_type = 'post'
            LEFT JOIN "Community" c ON ce.meal_id = c.id AND ce.content_type = 'community'
            WHERE ce.meal_id != :meal_id
            ORDER BY similarity DESC
            LIMIT :limit
        """),
        {"embedding": embedding, "meal_id": meal_id, "limit": limit}
    )
    
    items = []
    for row in result:
        items.append({
            "id": row[0],
            "content_type": row[1],
            "title": row[2],
            "similarity": row[3]
        })
    
    return {"items": items}

@app.get("/recommend/user/{user_id}", response_model=ContentList)
def get_user_recommendations(
    user_id: str,
    content_type: Optional[str] = None,
    limit: int = 10,
    db = Depends(get_db)
):
    # Get user's interactions
    type_filter = ""
    params = {"user_id": user_id, "limit": limit}
    
    if content_type:
        if content_type not in ['post', 'community']:
            raise HTTPException(status_code=400, detail="Content type must be 'post' or 'community'")
        type_filter = "AND content_type = :content_type"
        params["content_type"] = content_type
    
    # First try collaborative filtering based on what similar users interacted with
    result = db.execute(
        text(f"""
            -- Find users with similar interaction patterns
            WITH similar_users AS (
                SELECT DISTINCT ri2.user_id
                FROM recommendation_interactions ri1
                JOIN recommendation_interactions ri2 ON ri1.meal_id = ri2.meal_id 
                                                  AND ri1.content_type = ri2.content_type
                WHERE ri1.user_id = :user_id
                AND ri2.user_id != :user_id
                GROUP BY ri2.user_id
                HAVING COUNT(DISTINCT ri1.meal_id) > 2
                LIMIT 10
            ),
            -- Get content these similar users interacted with
            candidate_content AS (
                SELECT DISTINCT ri.meal_id, ri.content_type, COUNT(*) as interaction_count
                FROM recommendation_interactions ri
                JOIN similar_users su ON ri.user_id = su.user_id
                WHERE ri.meal_id NOT IN (
                    SELECT meal_id 
                    FROM recommendation_interactions 
                    WHERE user_id = :user_id
                )
                {type_filter}
                GROUP BY ri.meal_id, ri.content_type
                ORDER BY interaction_count DESC
                LIMIT :limit
            )
            -- Get content details
            SELECT cc.meal_id, cc.content_type,
                   CASE WHEN cc.content_type = 'post' THEN p.title
                        WHEN cc.content_type = 'community' THEN c.name
                   END as title
            FROM candidate_content cc
            LEFT JOIN "Post" p ON cc.meal_id = p.id AND cc.content_type = 'post'
            LEFT JOIN "Community" c ON cc.meal_id = c.id AND cc.content_type = 'community'
        """),
        params
    )
    
    items = []
    for row in result:
        items.append({
            "id": row[0],
            "content_type": row[1],
            "title": row[2]
        })
    
    # If we didn't get enough recommendations from collaborative filtering,
    # fall back to content-based recommendations
    if len(items) < limit:
        remaining = limit - len(items)
        
        # Get user's most recent interactions
        result = db.execute(
            text("""
                SELECT meal_id, content_type
                FROM recommendation_interactions
                WHERE user_id = :user_id
                ORDER BY created_at DESC
                LIMIT 1
            """),
            {"user_id": user_id}
        )
        
        recent = result.fetchone()
        
        # If user has recent interactions, get similar content
        if recent:
            meal_id, content_type = recent
            
            # Get similar content embedding
            result = db.execute(
                text("""
                    SELECT embedding
                    FROM content_embeddings
                    WHERE meal_id = :meal_id AND content_type = :content_type
                """),
                {"meal_id": meal_id, "content_type": content_type}
            )
            
            embedding_row = result.fetchone()
            
            if embedding_row:
                # Exclude already recommended items
                existing_ids = [item["id"] for item in items]
                exclude_clause = ""
                exclude_params = {}
                
                if existing_ids:
                    placeholder_list = ','.join([f':exclude_{i}' for i in range(len(existing_ids))])
                    exclude_clause = f"AND ce.meal_id NOT IN ({placeholder_list})"
                    for i, id_val in enumerate(existing_ids):
                        exclude_params[f"exclude_{i}"] = id_val
                
                type_filter = ""
                if content_type:
                    type_filter = "AND ce.content_type = :content_type"
                
                result = db.execute(
                    text(f"""
                        SELECT ce.meal_id, ce.content_type,
                               CASE WHEN ce.content_type = 'post' THEN p.title
                                    WHEN ce.content_type = 'community' THEN c.name
                               END as title,
                               1 - (ce.embedding <=> :embedding) AS similarity
                        FROM content_embeddings ce
                        LEFT JOIN "Post" p ON ce.meal_id = p.id AND ce.content_type = 'post'
                        LEFT JOIN "Community" c ON ce.meal_id = c.id AND ce.content_type = 'community'
                        WHERE ce.meal_id != :meal_id
                        {exclude_clause}
                        {type_filter}
                        ORDER BY similarity DESC
                        LIMIT :limit
                    """),
                    {
                        "embedding": embedding_row[0], 
                        "meal_id": meal_id, 
                        "content_type": content_type,
                        "limit": remaining,
                        **exclude_params
                    }
                )
                
                for row in result:
                    items.append({
                        "id": row[0],
                        "content_type": row[1],
                        "title": row[2],
                        "similarity": row[3]
                    })
    
    # If still not enough recommendations, get popular content
    if len(items) < limit:
        remaining = limit - len(items)
        existing_ids = [item["id"] for item in items]
        
        exclude_clause = ""
        exclude_params = {}
        
        if existing_ids:
            placeholder_list = ','.join([f':exclude_{i}' for i in range(len(existing_ids))])
            exclude_clause = f"AND meal_id NOT IN ({placeholder_list})"
            for i, id_val in enumerate(existing_ids):
                exclude_params[f"exclude_{i}"] = id_val
        
        type_filter = ""
        if content_type:
            type_filter = "AND content_type = :content_type"
            
        result = db.execute(
            text(f"""
                SELECT ri.meal_id, ri.content_type,
                       CASE WHEN ri.content_type = 'post' THEN p.title
                            WHEN ri.content_type = 'community' THEN c.name
                       END as title,
                       COUNT(*) as popularity
                FROM recommendation_interactions ri
                LEFT JOIN "Post" p ON ri.meal_id = p.id AND ri.content_type = 'post'
                LEFT JOIN "Community" c ON ri.meal_id = c.id AND ri.content_type = 'community'
                WHERE 1=1
                {exclude_clause}
                {type_filter}
                GROUP BY ri.meal_id, ri.content_type, p.title, c.name
                ORDER BY popularity DESC
                LIMIT :limit
            """),
            {"limit": remaining, **exclude_params, **({"content_type": content_type} if content_type else {})}
        )
        
        for row in result:
            items.append({
                "id": row[0],
                "content_type": row[1],
                "title": row[2]
            })
    
    return {"items": items}

class Interaction(BaseModel):
    user_id: str
    meal_id: str
    content_type: str
    interaction_type: str

@app.post("/interactions")
def record_interaction(interaction: Interaction, db = Depends(get_db)):
    # Validate content type
    if interaction.content_type not in ['post', 'community', 'comment']:
        raise HTTPException(status_code=400, detail="Content type must be 'post', 'community', or 'comment'")
    
    # Record the interaction
    db.execute(
        text("""
            INSERT INTO recommendation_interactions
            (user_id, meal_id, content_type, interaction_type)
            VALUES (:user_id, :meal_id, :content_type, :interaction_type)
        """),
        {
            "user_id": interaction.user_id,
            "meal_id": interaction.meal_id,
            "content_type": interaction.content_type,
            "interaction_type": interaction.interaction_type
        }
    )
    db.commit()
    
    return {"status": "recorded"}

@app.get("/trending/{content_type}", response_model=ContentList)
def get_trending_content(
    content_type: str,
    time_window: str = "day",  # day, week, month
    limit: int = 10,
    db = Depends(get_db)
):
    # Validate content type
    if content_type not in ['post', 'community', 'all']:
        raise HTTPException(status_code=400, detail="Content type must be 'post', 'community', or 'all'")
    
    # Determine time interval
    time_clause = "NOW() - INTERVAL '1 day'"
    if time_window == "week":
        time_clause = "NOW() - INTERVAL '7 days'"
    elif time_window == "month":
        time_clause = "NOW() - INTERVAL '30 days'"
    
    type_filter = ""
    if content_type != 'all':
        type_filter = "AND ri.content_type = :content_type"
    
    # Get trending content based on recent interactions
    result = db.execute(
        text(f"""
            SELECT ri.meal_id, ri.content_type,
                   CASE WHEN ri.content_type = 'post' THEN p.title
                        WHEN ri.content_type = 'community' THEN c.name
                   END as title,
                   COUNT(*) as popularity
            FROM recommendation_interactions ri
            LEFT JOIN "Post" p ON ri.meal_id = p.id AND ri.content_type = 'post'
            LEFT JOIN "Community" c ON ri.meal_id = c.id AND ri.content_type = 'community'
            WHERE ri.created_at > {time_clause}
            {type_filter}
            GROUP BY ri.meal_id, ri.content_type, p.title, c.name
            ORDER BY popularity DESC
            LIMIT :limit
        """),
        {"limit": limit, **({"content_type": content_type} if content_type != 'all' else {})}
    )
    
    items = []
    for row in result:
        items.append({
            "id": row[0],
            "content_type": row[1],
            "title": row[2],
            "popularity": row[3]
        })
    
    return {"items": items}

@app.get("/recommend/category/{category_id}", response_model=ContentList)
def get_category_recommendations(
    category_id: str,
    limit: int = 10,
    db = Depends(get_db)
):
    # Get communities in this category
    result = db.execute(
        text("""
            SELECT c.id, c.name
            FROM "Community" c
            JOIN "CommunityCategory" cc ON c.id = cc."communityId"
            WHERE cc."categoryId" = :category_id
            LIMIT :limit
        """),
        {"category_id": category_id, "limit": limit}
    )
    
    items = []
    for row in result:
        items.append({
            "id": row[0],
            "content_type": "community",
            "title": row[1]
        })
    
    return {"items": items}

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8000, reload=True)
////////////////////////////////////////////////////////////////////////////////

├── recommendation-service
├── scheduler
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   └── scheduler.py

////////////////////////////////////////////////////////////////////////////////
"""
Background task scheduler.
Runs periodic tasks for the recommendation system.
"""
import schedule
import time
import threading
import logging

from embeddings.embedding_generator import EmbeddingGenerator
from config.settings import EMBEDDING_GENERATION_INTERVAL, SCHEDULER_SLEEP_INTERVAL

logger = logging.getLogger(__name__)

def run_embedding_generation():
    """Generate embeddings for content that doesn't have them yet."""
    logger.info("Running scheduled embedding generation...")
    try:
        generator = EmbeddingGenerator()
        result = generator.generate_all_embeddings()
        logger.info(f"Embedding generation completed: {result}")
    except Exception as e:
        logger.error(f"Error during embedding generation: {e}")

def run_scheduler():
    """Run the scheduler loop to execute pending tasks."""
    while True:
        schedule.run_pending()
        time.sleep(SCHEDULER_SLEEP_INTERVAL)

def start_scheduler():
    """Configure and start the scheduler in a background thread."""
    # Schedule embedding generation job
    schedule.every(EMBEDDING_GENERATION_INTERVAL).minutes.do(run_embedding_generation)
    
    logger.info(f"Scheduled embedding generation every {EMBEDDING_GENERATION_INTERVAL} minutes")
    
    # Start scheduler in background thread
    scheduler_thread = threading.Thread(target=run_scheduler)
    scheduler_thread.daemon = True
    scheduler_thread.start()
    logger.info("Scheduler started in background thread")
    
    return scheduler_thread

if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Run immediately on first execution
    run_embedding_generation()
    
    # Start scheduler
    thread = start_scheduler()
    
    logger.info("Scheduler running. Press Ctrl+C to exit.")
    try:
        # Keep the main thread alive
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info("Scheduler stopped.")
////////////////////////////////////////////////////////////////////////////////

├── scheduler.py

////////////////////////////////////////////////////////////////////////////////
# scheduler.py
import schedule
import time
import subprocess
import threading

def run_embedding_generation():
    print("Running embedding generation...")
    subprocess.run(["python", "embedding_generator.py"])

# Schedule jobs
schedule.every(1).hours.do(run_embedding_generation)

def run_scheduler():
    while True:
        schedule.run_pending()
        time.sleep(60)

if __name__ == "__main__":
    # Run immediately on first execution
    run_embedding_generation()
    
    # Start scheduler in background thread
    scheduler_thread = threading.Thread(target=run_scheduler)
    scheduler_thread.daemon = True
    scheduler_thread.start()
    
    print("Scheduler started. Press Ctrl+C to exit.")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print("Scheduler stopped.")
////////////////////////////////////////////////////////////////////////////////

├── services
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   ├── base_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Base recommender interface.
Defines the common interface for all recommendation strategies.
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional

class BaseRecommender(ABC):
    """Base interface for all recommendation strategies."""
    
    @abstractmethod
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = 10,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get recommendations based on the strategy implementation.
        
        Args:
            user_id: Optional user ID for personalized recommendations
            meal_id: Optional content ID for similar content recommendations
            content_type: Optional content type filter
            limit: Maximum number of recommendations to return
            kwargs: Additional strategy-specific parameters
            
        Returns:
            List of recommended items
        """
        pass
    
    def format_recommendations(
        self, 
        items: List[Dict[str, Any]]
    ) -> Dict[str, List[Dict[str, Any]]]:
        """
        Format recommendations for API response.
        
        Args:
            items: List of recommendation items
            
        Returns:
            Formatted recommendations
        """
        return {"items": items}
////////////////////////////////////////////////////////////////////////////////

│   ├── collaborative_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Collaborative filtering recommender implementation.
Recommends items based on similar users' interactions.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories.interaction_repository import InteractionRepository
from config.settings import DEFAULT_RECOMMENDATION_LIMIT

logger = logging.getLogger(__name__)

class CollaborativeRecommender(BaseRecommender):
    """
    Collaborative filtering recommendation strategy.
    Finds users with similar interaction patterns and recommends items they've interacted with.
    This is a user-based collaborative filtering approach.
    """
    
    def __init__(self):
        """Initialize the collaborative recommender."""
        self.repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        min_common_items: int = 2,
        max_similar_users: int = 10,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get collaborative filtering recommendations.
        
        Args:
            user_id: The ID of the user
            meal_id: Not used for collaborative recommendations
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            min_common_items: Minimum number of items in common to consider users similar
            max_similar_users: Maximum number of similar users to consider
            
        Returns:
            List of recommended items based on similar users
        """
        if not user_id:
            logger.warning("User ID required for collaborative recommendations")
            return []
        
        # Find users with similar interaction patterns
        similar_users = self.repository.find_similar_users(
            user_id, 
            min_common_items=min_common_items,
            limit=max_similar_users
        )
        
        if not similar_users:
            logger.info(f"No similar users found for user {user_id}")
            return []
        
        # Get content that similar users have interacted with
        recommended_items = self.repository.get_content_from_similar_users(
            similar_users,
            user_id,
            content_type=content_type,
            limit=limit
        )
        
        return recommended_items
////////////////////////////////////////////////////////////////////////////////

│   ├── content_based_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Content-based recommender implementation.
Uses vector embeddings to find similar content.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories.content_embedding_repository import ContentEmbeddingRepository
from config.settings import DEFAULT_RECOMMENDATION_LIMIT, CONTENT_TYPES

logger = logging.getLogger(__name__)

class ContentBasedRecommender(BaseRecommender):
    """
    Content-based recommendation strategy.
    Uses vector embeddings to find similar content based on content features.
    """
    
    def __init__(self):
        """Initialize the content-based recommender."""
        self.repository = ContentEmbeddingRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get content-based recommendations.
        
        Args:
            user_id: Not used for content-based recommendations
            meal_id: The ID of the source content
            content_type: The type of content ('post', 'community')
            limit: Maximum number of recommendations
            
        Returns:
            List of similar content items
        """
        if not meal_id or not content_type:
            logger.warning("Content ID and type required for content-based recommendations")
            return []
        
        if content_type not in CONTENT_TYPES:
            logger.warning(f"Invalid content type: {content_type}")
            return []
        
        # Get the embedding for the source content
        embedding = self.repository.get_embedding(meal_id, content_type)
        if not embedding:
            logger.warning(f"No embedding found for {content_type} with ID {meal_id}")
            return []
        
        # Find similar content
        exclude_ids = [meal_id]  # Exclude the source content
        similar_items = self.repository.find_similar_content(
            embedding, 
            content_type=content_type,
            exclude_ids=exclude_ids,
            limit=limit
        )
        
        return similar_items
////////////////////////////////////////////////////////////////////////////////

│   ├── hybrid_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Hybrid recommender implementation.
Combines multiple recommendation strategies to provide robust recommendations.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from services.collaborative_recommender import CollaborativeRecommender
from services.content_based_recommender import ContentBasedRecommender
from services.popularity_recommender import PopularityRecommender
from data.repositories.interaction_repository import InteractionRepository
from config.settings import DEFAULT_RECOMMENDATION_LIMIT

logger = logging.getLogger(__name__)

class HybridRecommender(BaseRecommender):
    """
    Hybrid recommendation strategy.
    Combines multiple recommendation strategies with fallbacks:
    1. Collaborative filtering (user-based)
    2. Content-based recommendations
    3. Popularity-based recommendations
    """
    
    def __init__(self):
        """Initialize the hybrid recommender with various strategies."""
        self.collaborative_recommender = CollaborativeRecommender()
        self.content_based_recommender = ContentBasedRecommender()
        self.popularity_recommender = PopularityRecommender()
        self.interaction_repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get hybrid recommendations using multiple strategies with fallbacks.
        
        Args:
            user_id: The ID of the user for personalized recommendations
            meal_id: Optional content ID for similar content recommendations
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            
        Returns:
            List of recommended items
        """
        recommended_items = []
        
        # Step 1: Try collaborative filtering first (if we have a user_id)
        if user_id:
            collaborative_items = self.collaborative_recommender.get_recommendations(
                user_id=user_id,
                content_type=content_type,
                limit=limit,
                **kwargs
            )
            
            recommended_items.extend(collaborative_items)
            logger.info(f"Collaborative filtering returned {len(collaborative_items)} items")
        
        # Step 2: If we don't have enough recommendations yet, try content-based
        if len(recommended_items) < limit and user_id:
            # Get user's most recent interaction for content-based recommendations
            recent_interactions = self.interaction_repository.get_user_recent_interactions(
                user_id=user_id,
                content_type=content_type,
                limit=1
            )
            
            if recent_interactions:
                recent = recent_interactions[0]
                meal_id = recent['meal_id']
                content_type_for_content = recent['content_type']
                
                # Get additional recommendations based on this content
                # Exclude already recommended items
                existing_ids = [item.get("id") for item in recommended_items]
                
                remaining = limit - len(recommended_items)
                content_based_items = self.content_based_recommender.get_recommendations(
                    meal_id=meal_id,
                    content_type=content_type_for_content,
                    limit=remaining,
                    **kwargs
                )
                
                # Filter out duplicates
                content_based_items = [
                    item for item in content_based_items 
                    if item.get("id") not in existing_ids
                ]
                
                recommended_items.extend(content_based_items)
                logger.info(f"Content-based filtering added {len(content_based_items)} items")
        
        # Step 3: If still not enough, use popularity-based recommendations
        if len(recommended_items) < limit:
            # Exclude already recommended items
            existing_ids = [item.get("id") for item in recommended_items]
            
            remaining = limit - len(recommended_items)
            popularity_items = self.popularity_recommender.get_recommendations(
                content_type=content_type,
                limit=remaining,
                exclude_ids=existing_ids,
                **kwargs
            )
            
            recommended_items.extend(popularity_items)
            logger.info(f"Popularity-based filtering added {len(popularity_items)} items")
        
        # Return the combined recommendations (limited to the requested number)
        return recommended_items[:limit]
////////////////////////////////////////////////////////////////////////////////

│   ├── item_based_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Item-based collaborative filtering recommender implementation.
Recommends items based on co-occurrence patterns with items the user has interacted with.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories.interaction_repository import InteractionRepository
from config.settings import DEFAULT_RECOMMENDATION_LIMIT
from data.queries.service_queries import FIND_SIMILAR_ITEMS
from data.database import execute_query

logger = logging.getLogger(__name__)

class ItemBasedRecommender(BaseRecommender):
    """
    Item-based collaborative filtering recommendation strategy.
    Finds items similar to those the user has already interacted with,
    based on how frequently items co-occur in user interactions.
    """
    
    def __init__(self):
        """Initialize the item-based recommender."""
        self.repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get item-based collaborative filtering recommendations.
        
        Args:
            user_id: The ID of the user
            meal_id: Optional specific content ID to find similar items for
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            
        Returns:
            List of recommended items based on item similarity
        """
        if not user_id and not meal_id:
            logger.warning("Either user_id or meal_id required for item-based recommendations")
            return []
        
        # If meal_id is provided, use it directly to find similar items
        if meal_id:
            return self._get_similar_items(meal_id, content_type, limit)
        
        # Otherwise, use the user's recent interactions to find similar items
        return self._get_user_item_based_recommendations(user_id, content_type, limit)
    
    def _get_similar_items(
        self,
        meal_id: str,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT
    ) -> List[Dict[str, Any]]:
        """
        Find items similar to a specific content item based on co-occurrence patterns.
        
        Args:
            meal_id: The ID of the content to find similar items for
            content_type: Optional content type filter
            limit: Maximum number of similar items to return
            
        Returns:
            List of similar items
        """
        # Execute SQL to find items that frequently co-occur with the given meal_id
        # This is done by finding users who interacted with meal_id and then
        # counting other items they interacted with
        
        params = {
            "meal_id": meal_id,
            "limit": limit
        }
        
        type_filter = ""
        if content_type:
            type_filter = "AND ri2.content_type = :content_type"
            params["content_type"] = content_type
        
        # Format the query with the type filter
        formatted_query = FIND_SIMILAR_ITEMS.format(
            type_filter=type_filter
        )
        
        result = execute_query(
            formatted_query,
            params
        )
        
        similar_items = []
        for row in result:
            similar_items.append({
                "id": row[0],
                "content_type": row[1],
                "title": row[2],
                "co_occurrence_count": row[3]
            })
        
        return similar_items
    
    def _get_user_item_based_recommendations(
        self,
        user_id: str,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT
    ) -> List[Dict[str, Any]]:
        """
        Get item-based recommendations for a user by finding items similar
        to those they've already interacted with.
        
        Args:
            user_id: The ID of the user
            content_type: Optional content type filter
            limit: Maximum number of recommendations
            
        Returns:
            List of recommended items
        """
        # Get user's recent interactions
        recent_interactions = self.repository.get_user_recent_interactions(
            user_id=user_id,
            content_type=content_type,
            limit=5  # Use top 5 recent interactions
        )
        
        if not recent_interactions:
            logger.info(f"No recent interactions found for user {user_id}")
            return []
        
        all_recommendations = []
        user_items = [interaction["meal_id"] for interaction in recent_interactions]
        
        # For each item the user has interacted with, find similar items
        for interaction in recent_interactions:
            meal_id = interaction["meal_id"]
            similar_items = self._get_similar_items(
                meal_id=meal_id,
                content_type=content_type,
                limit=limit
            )
            
            # Filter out items the user has already interacted with
            filtered_items = [item for item in similar_items if item["id"] not in user_items]
            all_recommendations.extend(filtered_items)
        
        # Remove duplicates by creating a dictionary keyed by item ID
        unique_items = {}
        for item in all_recommendations:
            item_id = item["id"]
            if item_id not in unique_items or item.get("co_occurrence_count", 0) > unique_items[item_id].get("co_occurrence_count", 0):
                unique_items[item_id] = item
        
        # Sort by co-occurrence count and limit results
        sorted_items = sorted(
            unique_items.values(), 
            key=lambda x: x.get("co_occurrence_count", 0), 
            reverse=True
        )
        
        return sorted_items[:limit]
////////////////////////////////////////////////////////////////////////////////

│   └── popularity_recommender.py

////////////////////////////////////////////////////////////////////////////////
"""
Popularity-based recommender implementation.
Recommends trending or popular content based on interaction counts.
"""
from typing import List, Dict, Any, Optional
import logging

from services.base_recommender import BaseRecommender
from data.repositories.interaction_repository import InteractionRepository
from config.settings import DEFAULT_RECOMMENDATION_LIMIT, ALLOWED_TRENDING_WINDOWS

logger = logging.getLogger(__name__)

class PopularityRecommender(BaseRecommender):
    """
    Popularity-based recommendation strategy.
    Recommends trending or popular content based on interaction counts.
    This is a non-personalized strategy that can be used as a fallback.
    """
    
    def __init__(self):
        """Initialize the popularity recommender."""
        self.repository = InteractionRepository()
    
    def get_recommendations(
        self, 
        user_id: Optional[str] = None,
        meal_id: Optional[str] = None,
        content_type: Optional[str] = None,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT,
        time_window: str = "day",
        exclude_ids: List[str] = None,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """
        Get popularity-based recommendations.
        
        Args:
            user_id: Optional user ID (used for filtering recommendations)
            meal_id: Not used for popularity recommendations
            content_type: Optional content type filter ('post', 'community', 'all')
            limit: Maximum number of recommendations
            time_window: Time window for trending content ('day', 'week', 'month')
            exclude_ids: Optional list of content IDs to exclude
            
        Returns:
            List of popular content items
        """
        if time_window not in ALLOWED_TRENDING_WINDOWS:
            logger.warning(f"Invalid time window: {time_window}. Using 'day' instead.")
            time_window = "day"
        
        content_type_filter = content_type if content_type else 'all'
        
        # Get trending content
        popular_items = self.repository.get_trending_content(
            content_type=content_type_filter,
            time_window=time_window,
            limit=limit
        )
        
        # Filter out excluded IDs if specified
        if exclude_ids:
            popular_items = [item for item in popular_items if item["id"] not in exclude_ids]
        
        return popular_items
    
    def get_category_recommendations(
        self,
        category_id: str,
        limit: int = DEFAULT_RECOMMENDATION_LIMIT
    ) -> List[Dict[str, Any]]:
        """
        Get recommendations for a specific category.
        
        Args:
            category_id: The ID of the category
            limit: Maximum number of recommendations
            
        Returns:
            List of communities in the category
        """
        return self.repository.get_category_communities(
            category_id=category_id,
            limit=limit
        )
////////////////////////////////////////////////////////////////////////////////

├── setup
│   ├── __init__.py

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

│   └── setup_tables.py

////////////////////////////////////////////////////////////////////////////////
"""
Database setup script.
Creates necessary database tables and indexes for the recommendation system.
"""
import logging
from sqlalchemy import text

from data.database import get_transaction, test_connection
from config.settings import EMBEDDING_DIMENSION
from data.queries.setup_queries import (
    ENABLE_PGVECTOR,
    CREATE_CONTENT_EMBEDDINGS_TABLE,
    CREATE_EMBEDDINGS_INDEX,
    CREATE_INTERACTIONS_TABLE,
    CREATE_INTERACTIONS_INDEXES
)

logger = logging.getLogger(__name__)

def create_recommendation_tables():
    """Create all necessary tables and indexes for the recommendation system."""
    logger.info("Creating recommendation database tables and indexes...")
    
    try:
        with get_transaction() as conn:
            # Enable pgvector extension
            conn.execute(text(ENABLE_PGVECTOR))
            
            # Create a separate table for content embeddings
            # Format the query with the embedding dimension
            formatted_embeddings_table = CREATE_CONTENT_EMBEDDINGS_TABLE.format(
                embedding_dimension=EMBEDDING_DIMENSION
            )
            conn.execute(text(formatted_embeddings_table))
            
            # Create index for vector search
            conn.execute(text(CREATE_EMBEDDINGS_INDEX))
            
            # Create interactions table
            conn.execute(text(CREATE_INTERACTIONS_TABLE))
            
            # Create indexes for quick lookups
            conn.execute(text(CREATE_INTERACTIONS_INDEXES))
        
        logger.info("Database tables and indexes created successfully")
        return True
    except Exception as e:
        logger.error(f"Error creating database tables: {e}")
        return False

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # Test database connection
    if test_connection():
        # Create tables
        success = create_recommendation_tables()
        if success:
            logger.info("Database setup completed successfully")
        else:
            logger.error("Database setup failed")
    else:
        logger.error("Database connection test failed. Check your DATABASE_URL in .env file.")
////////////////////////////////////////////////////////////////////////////////

├── setup_tables.py

////////////////////////////////////////////////////////////////////////////////
# setup_tables.py
from sqlalchemy import text
from db_utils import get_db_engine

def create_recommendation_tables():
    engine = get_db_engine()
    
    with engine.connect() as conn:
        # Enable pgvector extension
        conn.execute(text("CREATE EXTENSION IF NOT EXISTS vector"))
        conn.commit()
        
        # Create a separate table for content embeddings (doesn't modify your schema)
        conn.execute(text("""
            CREATE TABLE IF NOT EXISTS content_embeddings (
                id SERIAL PRIMARY KEY,
                meal_id TEXT NOT NULL,
                content_type TEXT NOT NULL,  -- 'post' or 'community'
                embedding vector(768),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(meal_id, content_type)
            )
        """))
        
        # Create index for vector search
        conn.execute(text("""
            CREATE INDEX IF NOT EXISTS content_embeddings_idx 
            ON content_embeddings USING ivfflat (embedding vector_cosine_ops)
        """))
        
        # Create a table for tracking user interactions (if you don't want to use your existing tables)
        conn.execute(text("""
            CREATE TABLE IF NOT EXISTS recommendation_interactions (
                id SERIAL PRIMARY KEY,
                user_id TEXT NOT NULL,
                meal_id TEXT NOT NULL,
                content_type TEXT NOT NULL,  -- 'post', 'community', 'comment'
                interaction_type TEXT NOT NULL,  -- 'view', 'click', 'vote', etc.
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """))
        
        # Create indexes for quick lookups
        conn.execute(text("""
            CREATE INDEX IF NOT EXISTS rec_interactions_user_idx ON recommendation_interactions(user_id);
            CREATE INDEX IF NOT EXISTS rec_interactions_meal_idx ON recommendation_interactions(meal_id, content_type);
            CREATE INDEX IF NOT EXISTS rec_interactions_type_idx ON recommendation_interactions(interaction_type);
        """))
        
        conn.commit()
        print("Recommendation tables created successfully")

if __name__ == "__main__":
    create_recommendation_tables()
////////////////////////////////////////////////////////////////////////////////

└── start_recommendation_service.sh

////////////////////////////////////////////////////////////////////////////////
#!/bin/bash
# start_recommendation_service.sh
# Startup script for the recommendation service

# Set the directory to the script's location
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd $DIR

# Function to check if a Python module exists
module_exists() {
    python3 -c "import $1" 2>/dev/null
    return $?
}

# Check for required Python packages
echo "Checking for required Python packages..."
required_packages=("fastapi" "uvicorn" "sqlalchemy" "sentence-transformers" "schedule" "python-dotenv")
missing_packages=()

for package in "${required_packages[@]}"; do
    if ! module_exists $package; then
        missing_packages+=($package)
    fi
done

# Install missing packages if any
if [ ${#missing_packages[@]} -ne 0 ]; then
    echo "Installing missing packages: ${missing_packages[*]}"
    pip install "${missing_packages[@]}"
fi

# Create necessary database tables
echo "Setting up database tables..."
python3 -m setup.setup_tables

# Generate initial embeddings
echo "Generating initial embeddings..."
python3 -m embeddings.embedding_generator

# Start the scheduler in the background
echo "Starting background scheduler..."
python3 -m scheduler.scheduler &
SCHEDULER_PID=$!

# Register a trap to kill the scheduler when the script exits
trap "echo 'Stopping scheduler...'; kill $SCHEDULER_PID 2>/dev/null" EXIT

# Start the API server
echo "Starting API server..."
python3 -m api.app

echo "Recommendation service stopped."
////////////////////////////////////////////////////////////////////////////////

